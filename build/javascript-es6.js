// THIS FILE IS AUTOGENERATED FROM ../resources/todomvc/vanilla-examples/javascript-es6/index.js

/*<!DOCTYPE html>
<html lang="en" data-framework="javascript" data-version="es6" data-features="">
    <head>
        <meta charset="UTF-8" />
        <meta name="description" content="A TodoMVC workload app for Speedometer!" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta http-equiv="X-UA-Compatible" content="ie=edge" />
        <title>TodoMVC: JavaScript Es6</title>
        <link rel="stylesheet" href="node_modules/todomvc-common/base.css" />
        <link rel="stylesheet" href="node_modules/todomvc-app-css/index.css" />
    </head>
    <body>
        <section class="todoapp">
            <header class="header">
                <h1>todos</h1>
                <input class="new-todo" placeholder="What needs to be done?" autofocus />
            </header>
            <section class="main">
                <input class="toggle-all" type="checkbox" />
                <label class="toggle-all-label" for="toggle-all">Mark all as complete</label>
                <ul class="todo-list"></ul>
            </section>
            <footer class="footer">
                <span class="todo-count"></span>
                <ul class="filters">
                    <li>
                        <a href="#/" class="selected">All</a>
                    </li>
                    <li>
                        <a href="#/active">Active</a>
                    </li>
                    <li>
                        <a href="#/completed">Completed</a>
                    </li>
                </ul>
                <button class="clear-completed">Clear completed</button>
            </footer>
        </section>
        <footer class="info">
            <p>Click on input field to write your todo.</p>
            <p>At least two characters are needed to be a valid entry.</p>
            <p>Press 'enter' to add the todo.</p>
            <p>Double-click to edit a todo</p>
        </footer>*/
        

// Load contents of ../resources/todomvc/vanilla-examples/javascript-es6/shell-polyfill-hack.js
;// Helper class for debugging
function DumpMissingPropertiesBase() { }
DumpMissingPropertiesBase.prototype = new Proxy({}, {
    get(target, prop, receiver) {
        console.log("PROP", prop.toString());
        return target[prop];
    }
});

var timeoutHandlers = [];

if (!globalThis.console) {
    globalThis.console = { log: (msg) => print(msg) }
}
if (!("assert" in console)) {
    console["assert"] = function(value) {
        if (!value) {
            console.log("assertion failed")
            throw value
        }
    }
}
globalThis.console.error = globalThis.console.log;
globalThis.console.warn = globalThis.console.log;
// For JSC
if (!globalThis.performance) {
    globalThis.performance = { now: () => preciseTime() * 1000 }
}


// In jsshell, mock just enough details of DOM for matrix to work.
if (!("window" in globalThis)) {
    globalThis.window = globalThis;
    globalThis.self = globalThis;

    let lastTimeoutId = 0;
    globalThis.setTimeout = function (callback, delay) {
        console.log("setTimeout")
        timeoutHandlers.push(callback);
        lastTimeoutId++;
        return lastTimeoutId;
    }
    var event_listeners = {}

    globalThis.clearTimeout = () => null;
    globalThis.removeEventListener = () => null;

    globalThis.XMLHttpRequest = function () { }
    globalThis.Worker = function () { };
    globalThis.history = { pushState() {}, popState() {}, replaceState() {} }
    globalThis.uuid_seed = 0;
    globalThis.crypto = {
        randomUUID() {
            function randomHex() {
                uuid_seed = (1103515245 * uuid_seed + 12345) % 2147483647;
                return uuid_seed.toString(16).padStart(8, '0');
            }
            let mid = randomHex()
            return `${randomHex()}-${mid.slice(0, 4)}-${mid.slice(4,8)}-${randomHex().slice(0, 4)}-${randomHex()}`
        }
    }

    globalThis.NodeList = class { }

    // A live lazily populated collection of nodes that have query(node) == true
    class HTMLCollection {
        constructor(document, node, query) {
            this.elements = [];
            this.document = document;
            this.node = node;
            this.query = query;
            this.version = document.version;
        }
        update(index) {
            if (this.version != this.document.version) {
                this.elements.length = 0;
                this.version = this.document.version;
            }
            let node = this.node;
            while (node && (this.elements.length <= index || index == -1)) {
                if (this.query(node)) {
                    this.elements.push(node)
                }
                if (node.firstChild) {
                    node = node.firstChild;
                } else if (node.nextSibling) {
                    node = node.nextSibling;
                } else {
                    while (node) {
                        if (node.parentNode && node.parentNode.nextSibling) {
                            node = node.parentNode.nextSibling;
                            break;
                        }
                        node = node.parentNode
                    }
                }
            }
            this.node = node;
        }
        item(index) {
            this.update(index);
            return this.elements[index];
        }
        get length() {
            this.update(-1)
            return this.elements.length;
        }
    };

    function makeArrayLike(o) {
        return new Proxy(o, {
            get: function (target, propKey) {
		if (Number.isInteger(Number(propKey))) {
                    const index = Number(propKey);
                    return target.item(index);
                }
                var p = Reflect.get(target, propKey);
                return p
            },
            has: function (target, P) {
                if (Number.isInteger(Number(P))) {
                    const index = Number(P);
                    // we don't want has() to use the length getter
                    // so that we can avoid loading the entire list 
                    if (index < 0) {
                        return false;
                    }
                    target.update(index)
                    return index < target.elements.length;
                }
                return Reflect.has(target, P)
            },
        });
    }

    function _GetElementConstructor(tagName) {
        switch (tagName.toLowerCase()) {
            case "html":
                return globalThis.HTMLHtmlElement;
            case "body":
                return globalThis.HTMLBodyElement;
            case "b":
            case "main":
            case "strong":
                return globalThis.HTMLElement;
            case "div":
                return globalThis.HTMLDivElement;
            case "hr":
                return globalThis.HTMLHRElement;
            case "br":
                return globalThis.HTMLBRElement;
            case "h1":
            case "h2":
            case "h3":
                return globalThis.HTMLHeadingElement;
            case "li":
                return globalThis.HTMLLIElement;
            case "ol":
                return globalThis.HTMLOListElement;
            case "span":
                return globalThis.HTMLSpanElement;
            case "p":
                return globalThis.HTMLParagraphElement;
            case "a":
                return globalThis.HTMLAnchorElement;
            case "button":
                return globalThis.HTMLButtonElement;
            case "input":
                return globalThis.HTMLInputElement;
            case "img":
                return globalThis.HTMLImageElement;
            case "script":
                return globalThis.HTMLScriptElement;
            case "iframe":
                return globalThis.HTMLIFrameElement;
            case "canvas":
                return globalThis.HTMLCanvasElement;
            case "label":
                return globalThis.HTMLLabelElement;
            case "react":
                return globalThis.HTMLUnknownElement;
        }
        console.log("UNKNOWN-HTMLELEMENT", tagName);
        return globalThis.HTMLElement;
    }

    globalThis.EventTarget = class {
        dispatchEvent(event) {
            event.target = this;
            if (event.type === "react-invokeguardedcallback") {
                if (this._react_callback) {
                    for (let cb of this._react_callback) {
                        cb(event);
                    }
                }
            } else {
                let current_target = this;
                while (current_target) {
                    let event_listeners = current_target.event_listeners;
                    if (event_listeners && event.type in event_listeners) {
                        for (const listener of event_listeners[event.type]) {
                            listener.call(current_target, event);
                        }
                        break;
                    } else {
                        current_target = current_target.parentNode;
                    }
                }
            }
            return true;
        }
        addEventListener(type, listener) {
            console.log("addEventListener: ", this.tagName, type, listener)
            if (type === "react-invokeguardedcallback") {
                if (!this._react_callback) {
                    this._react_callback = [];
                }
                this._react_callback.push(listener);
            } else {
                if (!this.event_listeners) {
                    this.event_listeners = {};
                }
                if (type in this.event_listeners) {
                    this.event_listeners[type].push(listener);
                } else {
                    this.event_listeners[type] = [listener];
                }
            }
        }
        removeEventListener(type, listener) {
            if (type === "react-invokeguardedcallback") {
                if (this._react_callback) {
                    this._react_callback = this._react_callback.filter(el => el !== listener);
                }
            }
        }
    };
    globalThis.dispatchEvent = EventTarget.prototype.dispatchEvent;
    globalThis.addEventListener = EventTarget.prototype.addEventListener;
    globalThis.Node = class extends globalThis.EventTarget {
        static ELEMENT_NODE = 1;
        static DOCUMENT_NODE = 9;
        static DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32;
        compareDocumentPosition(otherNode) {
            return globalThis.Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC;
        }
        parentNode = null;
        nextSibling = null;
        previousSibling = null;
        appendChild(childNode) {
            console.assert(!childNode.parentNode)
            if (!this.firstChild) {
                this.firstChild = childNode;
                this.lastChild = childNode;
            } else {
                childNode.previousSibling = this.lastChild;
                this.lastChild.nextSibling = childNode;
                this.lastChild = childNode;
            }
            if (childNode instanceof globalThis.Node) {
                childNode.parentNode = this;
            }
            return childNode;
        }
        cloneNode() {
            let result = new Node;
            result = Object.assign(result, this)
            return result
        }
        removeChild(child) {
            if (child.previousSibling) {
                child.previousSibling.nextSibling = child.nextSibling;
            } else {
                child.parentNode.firstChild = child.nextSibling;
            }
            if (child.nextSibling) {
                child.nextSibling.previousSibling = child.previousSibling;
            } else {
                child.parentNode.lastChild = child.previousSibling;
            }
            child.parentNode = null;
        }
        insertBefore(newNode, ref) {
            if (!ref) {
                this.appendChild(newNode)
            } else {
                console.assert(ref.parentNode == this);
                newNode.nextSibling = ref;
                newNode.previousSibling = ref.previousSibling;
                if (ref.previousSibling) {
                    ref.previousSibling.nextSibling = newNode;
                } else {
                    this.firstChild = newNode;
                }
                ref.previousSibling = newNode;
                newNode.parentNode = ref.parentNode;
            }
            return newNode;
        }
        get childNodes() {
            let result = [];
            let child = this.firstChild;
            while (child) {
                result.push(child)
                child = child.nextSibling;
            }
            return result;
        }
        get ownerDocument() {
            return globalThis.document;
        }
        get parentElement() {
            if (this.parentNode instanceof globalThis.Element) {
                return this.parentNode;
            } else {
                return null;
            }
        }
    };
    globalThis.Element = class extends globalThis.Node {
        constructor(tagName) {
            super();
            this.tagName = tagName.toUpperCase();
            this.nodeName = tagName.toUpperCase();
            this.onkeydown = null;
            this.onclick = null;
            this.onchange = null;
            this[Symbol.toStringTag] = _GetElementConstructor(tagName).name;
        }
        cloneNode(deep) {
            var result = new this.constructor(this.tagName)
            Object.assign(result, this)
            return result;
        }
        get nodeType() { return Node.ELEMENT_NODE; };
        get namespaceURI() { return "http://www.w3.org/1999/xhtml"; }
        getAttribute(key) { return this[key]; }
        get className() { return this["class"]; }
        set className(name) { this["class"] = name }
        setAttribute(key, val) { this[key] = val; }
        removeAttribute(key) { delete this[key] }

        get innerHTML() { return this._innerHTML ||
            `<${this.tagName}>\n${this.childNodes?.map(n => (" " + (n.innerHTML || "#text")).replaceAll("\n", "\n ")).join("\n")}\n</${this.tagName}>`
        }
        get attributes() { return [] }

        // TODO this doesn't handle '/' in attribute values and probably should switch
        // to using states for handling attributes.
        set innerHTML(html) {
            if (this.tagName == "SCRIPT") {
                this._innerHTML = html;
                return;
            }
            
            // remove existing content
            while (this.firstChild) {
                this.removeChild(this.lastChild);
            }

            let root = this;
            let currentNode = root;
            let stack = [];
          
            let state = 'text';
            let buffer = '';
          
            for (let i = 0; i < html.length; i++) {
              let char = html[i];
              switch (state) {
                case 'text':
                  if (char === '<') {
                    if (buffer.trim().length > 0) {
                      currentNode.appendChild(document.createTextNode(buffer.trim()));
                      buffer = '';
                    }
                    state = 'tag';
                  } else {
                    buffer += char;
                  }
                  break;
                case 'tag':
                  if (char === '/') {
                    state = 'close-tag';
                  } else if (char === '>') {
                    let tagName = buffer.trim().split(' ')[0];
                    let newNode = document.createElement(tagName);
          
                    let attributes = buffer.trim().slice(tagName.length + 1).trim();
                    if (attributes.length > 0) {
                      let j = 0;
                      while (j < attributes.length) {
                        let key = '';
                        let value = '';
                        let quote = '"';
          
                        while (j < attributes.length && attributes[j] != '=') {
                          key += attributes[j];
                          j++;
                        }
          
                        key = key.trim();
                        j++; // skip '='
                        j++; // skip '"'
          
                        while (j < attributes.length && attributes[j] !== quote) {
                          value += attributes[j];
                          j++;
                        }

                        j++; // skip '"'
                        newNode.setAttribute(key, value);
                      }
                    }
          
                    currentNode.appendChild(newNode);
                    stack.push(currentNode);
                    currentNode = newNode;
                    buffer = '';
                    state = 'text';
                    if (tagName == "input") {
                        currentNode = stack.pop();
                    }
                  } else {
                    buffer += char;
                  }
                  break;
                case 'close-tag':
                  if (char === '>') {
                    let tagName = buffer.trim();
                    if (currentNode.tagName === tagName.toUpperCase()) {
                      currentNode = stack.pop();
                    }
                    buffer = '';
                    state = 'text';
                  } else {
                    buffer += char;
                  }
                  break;
              }
            }
          
            if (buffer.trim().length > 0) {
              currentNode.appendChild(document.createTextNode(buffer.trim()));
            }
        }

        insertAdjacentHTML(position, html) {
            console.log("iAH")
            var position = position.toLowerCase();
            console.assert(position == "beforeend")
            var el = document.createElement('div');
            el.innerHTML = html;
            let curNode = el.firstChild;
            while (curNode) {
              let nextNode = curNode.nextSibling;
              this.appendChild(curNode);
              curNode = nextNode;
            }
        }
        get classList() {
            return {
                add: (name) => {},
                remove: (name) => {}
            };
        }
        get children() {
            console.log("children")
            return this.childNodes.filter(n => n instanceof globalThis.Element);
        }
        get firstElementChild() {
            console.log("fec")

            const elements = this.children;
            if (elements.length === 0) {
                return null;
            }
            return elements[0];
        }
        get lastElementChild() {
            console.log("lec")

            const elements = this.children;
            if (elements.length === 0) {
                return null;
            }
            return elements[elements.length - 1];
        }
        getElementsByTagName(tagName) {
            tagName = tagName.toUpperCase();
            return this.childNodes.filter(n => n.tagName === tagName);
        }
        getElementsByClassName(className) {
            return makeArrayLike(new HTMLCollection(document, this, (node) => node.class == className))
        }
        querySelector(sel) {
           if (sel == ".edit") {
                return this.getElementsByClassName("edit")[0]
           }

           print("querySelector", sel)
        }
        querySelectorAll(sel) {
            if (sel[0] == "." && sel.indexOf(' ') == -1) {
                return Array.prototype.slice.call(this.getElementsByClassName(sel.substring(1)))
            }
            print("querySelectorAll", sel)
        }
        getAttributeNode() {}
        get style() {
            let self = this;
            return {
                getPropertyValue() { },
                setProperty() { },
            };
        }
        getBoundingClientRect() {
            return {
                x: 100,
                y: 100,
                width: 100,
                height: 100,
                top: 100,
                right: 200,
                bottom: 200,
                left: 100,
            };
        }
    };
    globalThis.HTMLElement = class extends globalThis.Element {
        contentEditable = false;
        focus() { }
	get dataset() {
		if (this["data-id"]) {
			return {id: this["data-id"] }
		}
		return {}
	}
    };
    globalThis.HTMLHtmlElement = class extends globalThis.HTMLElement { };
    globalThis.HTMLAnchorElement = class extends globalThis.HTMLElement {
        get protocol() {
            var proto = this.href.split(":")[0]
            console.log("get proto", proto)
            return proto + ":"
        }
     };
    globalThis.HTMLDivElement = class extends globalThis.HTMLElement { };
    globalThis.HTMLParagraphElement = class extends globalThis.HTMLElement { };
    globalThis.HTMLHRElement = class extends globalThis.HTMLElement { };
    globalThis.HTMLBRElement = class extends globalThis.HTMLElement { };
    globalThis.HTMLHeadingElement = class extends globalThis.HTMLElement { };
    globalThis.HTMLBodyElement = class extends globalThis.HTMLElement { };
    globalThis.HTMLHeadElement = class extends globalThis.HTMLElement { };
    globalThis.HTMLIFrameElement = class extends globalThis.HTMLElement { };
    globalThis.HTMLScriptElement = class extends globalThis.HTMLElement { };
    globalThis.HTMLInputElement = class extends globalThis.HTMLElement {
        type = "text"
    };
    globalThis.HTMLButtonElement = class extends globalThis.HTMLElement { };
    globalThis.HTMLImageElement = class extends globalThis.HTMLElement { };
    globalThis.HTMLCanvasElement = class extends globalThis.HTMLElement {
        getContext() {
            return {
                fillRect() { },
            };
        }
        toDataURL() { return "data://"; }
    };
    globalThis.HTMLUnknownElement = class extends globalThis.HTMLElement { };
    globalThis.HTMLLIElement = class extends globalThis.HTMLElement { };
    globalThis.HTMLOListElement = class extends globalThis.HTMLElement { };
    globalThis.HTMLSpanElement = class extends globalThis.HTMLElement { };
    globalThis.HTMLLabelElement = class extends globalThis.HTMLElement { };
    globalThis.HTMLMediaElement = class extends globalThis.HTMLElement { };
    globalThis.HTMLFrameSetElement = class extends globalThis.HTMLElement { };
    globalThis.HTMLFrameElement = class extends globalThis.HTMLElement { };
    globalThis.CharacterData = class extends globalThis.Node { };
    globalThis.Text = class extends globalThis.CharacterData { nodeName = "#text" };

    globalThis.Event = class {
        constructor(type, options) {
            this.type = type
            this.options = options
        }
        preventDefault() {}

        initCustomEvent() { }
        initEvent() { }
    };
    globalThis.UIEvent = class extends globalThis.Event { };

    globalThis.Range = class {
        setStart() { }
        collapse() { }
    };
    globalThis.Selection = class {
        removeAllRanges() { }
        addRange() { }
    };

    globalThis.URL = class {
        get hostname() {
            return "example.com";
        }
    };

    globalThis.fetch = function () {
        return new Promise(function () { });
    }

    globalThis.navigator = {
        platform: "shell",
        userAgent: "shell",
    };

    globalThis.localStorage = {
        getItem: () => null,
        setItem: () => null,
    };
    globalThis.sessionStorage = globalThis.localStorage;

    globalThis.matchMedia = function () {
        return {
            matches: false,
        };
    }

    globalThis.location = {
        host: "example.com",
        pathname: "/",
        hash: "",
        get href() {
           return "http://" + this.host + this.pathname + this.hash
        },
        get origin() {
           return "http://" + this.host
        }

    };

    globalThis.Document = class extends globalThis.Node {};
    globalThis.document = {
        __proto__: globalThis.Node.prototype,
        body: new globalThis.HTMLBodyElement("body"),
        head: new globalThis.HTMLHeadElement("head"),
        documentElement: new globalThis.HTMLHtmlElement("html"),
        cookie: "",
        compatMode: "CSS1Compat",
        host: "example.com",
        readyState: "complete",
        nodeType: globalThis.Node.DOCUMENT_NODE,
        implementation: {
            createHTMLDocument() {
                // this is very wrong
                return globalThis.document
            }
        },
        createEvent: () => new globalThis.Event,
        createTextNode: (data) => {
            let node = new globalThis.Text;
            node.data = data;
            return node;
        },
        createElement: (tagName) => {
            let constructor = _GetElementConstructor(tagName);
            return new (constructor)(tagName);
        },
        createElementNS: (ns, tagName) => {
            let constructor = _GetElementConstructor(tagName);
            return new (constructor)(tagName);
        },
        createComment(data) {
           return new Node;
        },
        createDocumentFragment() {
           return new Node;
        },
        querySelector(sel) {
           if (sel == "app-root") {
                return document.body.childNodes[0]
           } else if (sel == "meta[name=\"todomvc/config/environment\"]") {
               return document.head.childNodes[0]
           } else if (sel == "body") {
               return document.body
           } else if (sel == ".todoapp") {
               return document.getElementsByClassName("todoapp")[0]
           } else if (sel == "head") {
               return document.head;
           } else if (sel == ".filters .selected") {
               var ancestors = document.getElementsByClassName("filters");
               var result = [];
               for (var a of Array.prototype.slice.call(ancestors)) {
                   for (var c of a.childNodes) {
                       result = result.concat(c.getElementsByClassName("selected"))
                   }
               }
               return result;
           } else if (sel == '.filters [href="#/"]') {
               var ancestors = document.getElementsByClassName("filters");
               var result = [];
               for (var a of Array.prototype.slice.call(ancestors)) {
                   for (var c of a.childNodes) {
                       result = result.concat(makeArrayLike(new HTMLCollection(document, this, (node) => node.href == "#/")))
                   }
                }
                return result;
            } else if (sel.startsWith('[data-id')) {
                var id_value = sel.match(/\d+/)
                return makeArrayLike(new HTMLCollection(document, this, (node) => node["data-id"] == id_value))[0];
            } else if (sel[0] == ".") {
                return document.getElementsByClassName(sel.substring(1))[0]
            }
            print("querySelector", sel)


        },
        querySelectorAll(sel) {
            print("querySelectorAll", sel)
            return []
        },
        getElementById(id) {
            return makeArrayLike(new HTMLCollection(document, this, (node) => node.id == id))[0]
        },
        getElementsByClassName(className) {
            return makeArrayLike(new HTMLCollection(document, this, (node) => node.class == className))
        },
        createRange: () => new globalThis.Range,
        getSelection: () => new globalThis.Selection,
        activeElement: null,
        location: globalThis.location,
        oninput: null,
        defaultView: window
    };

    globalThis.document.getElementsByClassName.toString = () => "getElementsByClassName() { [native code ] }"

    globalThis.document.appendChild(globalThis.document.documentElement);
    globalThis.document.documentElement.appendChild(globalThis.document.body);
    globalThis.onhashchange = null
} // !("window" in globalThis);
;
if ("drainMicrotasks" in globalThis) {
    print("jsc")
    // webkit
    globalThis["drainJobQueue"] = drainMicrotasks
} else if ("version" in globalThis) {
    // v8
    print("v8")
    // run with --allow-natives-syntax
    globalThis["drainJobQueue"] = eval("() => { %PerformMicrotaskCheckpoint(); }")
}

        var sectionTodoApp = document.createElement("section")
        sectionTodoApp.class = "todoapp";
        document.body.appendChild(sectionTodoApp);
        
        var header = document.createElement("header")
        header.class = "header";
        sectionTodoApp.appendChild(header)
        
        var input = document.createElement("input")
        input.class = "new-todo"
        header.appendChild(input)

        var main = document.createElement("section")
        main.class = "main";
        sectionTodoApp.appendChild(main)
        
        var input = document.createElement("input")
        input.class = "toggle-all"
        main.appendChild(input)

	var label = document.createElement("label")
        label.class = "toggle-all-label"
        main.appendChild(label)

        var ul = document.createElement("ul")
        ul.class = "todo-list"
        main.appendChild(ul)
        
        var footer = document.createElement("footer")
        footer.class = "footer";
        sectionTodoApp.appendChild(footer)
                
        var count = document.createElement("span")
	count.class = "todo-count";
	footer.appendChild(count)

	var clearCompleted = document.createElement("button")
        clearCompleted.class = "clear-completed";
	sectionTodoApp.appendChild(clearCompleted)
 
        

// Load contents of ../resources/todomvc/vanilla-examples/javascript-es6/src/helpers.js
;/* eslint no-unused-vars: 0 */
"use strict";

// Allow for looping on nodes by chaining:
// qsa('.foo').forEach(function () {})
NodeList.prototype.forEach = Array.prototype.forEach;

// Get element(s) by CSS selector:
function qs(selector, scope) {
    return (scope || document).querySelector(selector);
}

function qsa(selector, scope) {
    return (scope || document).querySelectorAll(selector);
}

// addEventListener wrapper:
function $on(target, type, callback, useCapture) {
    target.addEventListener(type, callback, !!useCapture);
}

// Attach a handler to event for all elements that match the selector,
// now or in the future, based on a root element
function $delegate(target, selector, type, handler) {
    let dispatchEvent = (event) => {
        const targetElement = event.target;
        const potentialElements = qsa(selector, target);
        const hasMatch = Array.prototype.indexOf.call(potentialElements, targetElement) >= 0;

        if (hasMatch)
            handler.call(targetElement, event);
    };

    // https://developer.mozilla.org/en-US/docs/Web/Events/blur
    const useCapture = type === "blur" || type === "focus";

    $on(target, type, dispatchEvent, useCapture);
}

// Find the element's parent with the given tag name:
// $parent(qs('a'), 'div')
function $parent(element, tagName) {
    if (!element.parentNode)
        return undefined;

    if (element.parentNode.tagName.toLowerCase() === tagName.toLowerCase())
        return element.parentNode;

    return $parent(element.parentNode, tagName);
};
;
        

// Load contents of ../resources/todomvc/vanilla-examples/javascript-es6/src/store.js
;/* eslint no-unused-vars: 0 */
"use strict";

let uniqueID = 1;

/**
 * Creates a new client side storage object and will create an empty
 * collection if no collection already exists.
 *
 * @param {string} name The name of our DB we want to use
 * @param {function} callback Our fake DB uses callbacks because in
 * real life you probably would be making AJAX calls
 */
class Store {
    constructor(name, callback) {
        this._dbName = name;
        this.memoryStorage = this.memoryStorage || {};

        if (!this.memoryStorage[name]) {
            let data = {
                todos: [],
            };

            this.memoryStorage[name] = JSON.stringify(data);
        }

        if (callback)
            callback.call(this, JSON.parse(this.memoryStorage[name]));
    }

    /**
     * Finds items based on a query given as a JS object
     *
     * @param {object} query The query to match against (i.e. {foo: 'bar'})
     * @param {function} callback   The callback to fire when the query has
     * completed running
     *
     * @example
     * db.find({foo: 'bar', hello: 'world'}, function (data) {
     *   // data will return any items that have foo: bar and
     *   // hello: world in their properties
     * })
     */
    find(query, callback) {
        if (!callback)
            return;

        let todos = JSON.parse(this.memoryStorage[this._dbName]).todos;

        callback.call(
            this,
            todos.filter((todo) => {
                for (let q in query) {
                    if (query[q] !== todo[q])
                        return false;
                }

                return true;
            })
        );
    }

    /**
     * Will retrieve all data from the collection
     *
     * @param {function} callback The callback to fire upon retrieving data
     */
    findAll(callback) {
        if (callback)
            callback.call(this, JSON.parse(this.memoryStorage[this._dbName]).todos);
    }

    /**
     * Will save the given data to the DB. If no item exists it will create a new
     * item, otherwise it'll simply update an existing item's properties
     *
     * @param {object} updateData The data to save back into the DB
     * @param {function} callback The callback to fire after saving
     * @param {number} id An optional param to enter an ID of an item to update
     */
    save(updateData, callback, id) {
        const data = JSON.parse(this.memoryStorage[this._dbName]);
        let todos = data.todos;
        const len = todos.length;

        // If an ID was actually given, find the item and update each property
        if (id) {
            for (let i = 0; i < len; i++) {
                if (todos[i].id === id) {
                    for (let key in updateData)
                        todos[i][key] = updateData[key];

                    break;
                }
            }

            this.memoryStorage[this._dbName] = JSON.stringify(data);

            if (callback)
                callback.call(this, JSON.parse(this.memoryStorage[this._dbName]).todos);
        } else {
            // Generate an ID
            updateData.id = uniqueID++;

            todos.push(updateData);
            this.memoryStorage[this._dbName] = JSON.stringify(data);

            if (callback)
                callback.call(this, [updateData]);
        }
    }

    /**
     * Will remove an item from the Store based on its ID
     *
     * @param {number} id The ID of the item you want to remove
     * @param {function} callback The callback to fire after saving
     */
    remove(id, callback) {
        const data = JSON.parse(this.memoryStorage[this._dbName]);
        let todos = data.todos;

        for (let i = 0; i < todos.length; i++) {
            if (todos[i].id === id) {
                todos.splice(i, 1);
                break;
            }
        }

        this.memoryStorage[this._dbName] = JSON.stringify(data);

        if (callback)
            callback.call(this, JSON.parse(this.memoryStorage[this._dbName]).todos);
    }

    /**
     * Will drop all storage and start fresh
     *
     * @param {function} callback The callback to fire after dropping the data
     */
    drop(callback) {
        this.memoryStorage[this._dbName] = JSON.stringify({ todos: [] });

        if (callback)
            callback.call(this, JSON.parse(this.memoryStorage[this._dbName]).todos);
    }
};
;
        

// Load contents of ../resources/todomvc/vanilla-examples/javascript-es6/src/model.js
;/* eslint no-unused-vars: 0 */
"use strict";

/**
 * Creates a new Model instance and hooks up the storage.
 * @constructor
 * @param {object} storage A reference to the client side storage class
 */
class Model {
    constructor(storage) {
        this.storage = storage;
    }

    /**
     * Creates a new todo model
     *
     * @param {string} [title] The title of the task
     * @param {function} [callback] The callback to fire after the model is created
     */
    create(title, callback) {
        title = title || "";

        let newItem = {
            title: title.trim(),
            completed: false,
        };

        this.storage.save(newItem, callback);
    }

    /**
     * Finds and returns a model in storage. If no query is given it'll simply
     * return everything. If you pass in a string or number it'll look that up as
     * the ID of the model to find. Lastly, you can pass it an object to match
     * against.
     *
     * @param {string|number|object} [query] A query to match models against
     * @param {function} [callback] The callback to fire after the model is found
     *
     * @example
     * model.read(1, func) // Will find the model with an ID of 1
     * model.read('1') // Same as above
     * //Below will find a model with foo equalling bar and hello equalling world.
     * model.read({ foo: 'bar', hello: 'world' })
     */
    read(query, callback) {
        const queryType = typeof query;

        if (queryType === "function") {
            callback = query;
            this.storage.findAll(callback);
        } else if (queryType === "string" || queryType === "number") {
            query = parseInt(query, 10);
            this.storage.find({ id: query }, callback);
        } else {
            this.storage.find(query, callback);
        }
    }

    /**
     * Updates a model by giving it an ID, data to update, and a callback to fire when
     * the update is complete.
     *
     * @param {number} id The id of the model to update
     * @param {object} data The properties to update and their new value
     * @param {function} callback The callback to fire when the update is complete.
     */
    update(id, data, callback) {
        this.storage.save(data, callback, id);
    }

    /**
     * Removes a model from storage
     *
     * @param {number} id The ID of the model to remove
     * @param {function} callback The callback to fire when the removal is complete.
     */
    remove(id, callback) {
        this.storage.remove(id, callback);
    }

    /**
     * WARNING: Will remove ALL data from storage.
     *
     * @param {function} callback The callback to fire when the storage is wiped.
     */
    removeAll(callback) {
        this.storage.drop(callback);
    }

    /**
     * Returns a count of all todos
     */
    getCount(callback) {
        let todos = {
            active: 0,
            completed: 0,
            total: 0,
        };

        this.storage.findAll((data) => {
            for (let todo of data) {
                if (todo.completed)
                    todos.completed++;
                else
                    todos.active++;

                todos.total++;
            }

            if (callback)
                callback(todos);
        });
    }
};
;
        

// Load contents of ../resources/todomvc/vanilla-examples/javascript-es6/src/template.js
;/* eslint no-unused-vars: 0 */
"use strict";

const htmlEscapes = {
    "&": "&amp",
    "<": "&lt",
    ">": "&gt",
    '"': "&quot",
    "'": "&#x27",
    "`": "&#x60",
};

const reUnescapedHtml = /[&<>"'`]/g;
const reHasUnescapedHtml = new RegExp(reUnescapedHtml.source);

let escape = (str) => str && reHasUnescapedHtml.test(str) ? str.replace(reUnescapedHtml, escapeHtmlChar) : str;
let escapeHtmlChar = (chr) => htmlEscapes[chr];

class Template {
    constructor() {
        this.defaultTemplate = `
            <li data-id="{{id}}" class="{{completed}}">
                <div class="view">
                    <input class="toggle" type="checkbox" {{checked}}>
                    <label>{{title}}</label>
                    <button class="destroy"></button>
                </div>
            </li>
        `;
    }

    /**
     * Creates an <li> HTML string and returns it for placement in your app.
     *
     * NOTE: In real life you should be using a templating engine such as Mustache
     * or Handlebars, however, this is a vanilla JS example.
     *
     * @param {object} data The object containing keys you want to find in the
     *                      template to replace.
     * @returns {string} HTML String of an <li> element
     *
     * @example
     * view.show({
     *  id: 1,
     *  title: "Hello World",
     *  completed: 0,
     * })
     */
    show(data) {
        let i = 0;
        let view = "";
        const len = data.length;

        for (i; i < len; i++) {
            let completed = "";
            let checked = "";
            let template = this.defaultTemplate;

            if (data[i].completed) {
                completed = "completed";
                checked = "checked";
            }

            template = template.replace("{{id}}", data[i].id);
            template = template.replace("{{title}}", escape(data[i].title));
            template = template.replace("{{completed}}", completed);
            template = template.replace("{{checked}}", checked);

            view += template;
        }

        return view;
    }

    /**
     * Displays a counter of how many to dos are left to complete
     *
     * @param {number} activeTodos The number of active todos.
     * @returns {string} String containing the count
     */
    itemCounter(activeTodos) {
        let plural = activeTodos === 1 ? "" : "s";
        return `<strong>${activeTodos}</strong> item${plural} left`;
    }

    /**
     * Updates the text within the "Clear completed" button
     *
     * @param  {[type]} completedTodos The number of completed todos.
     * @returns {string} String containing the count
     */
    clearCompletedButton(completedTodos) {
        return completedTodos > 0 ? "Clear completed" : "";
    }
};
;
        

// Load contents of ../resources/todomvc/vanilla-examples/javascript-es6/src/view.js
;"use strict";

// import {qs, qsa, $on, $parent, $delegate} from './helpers';

let _itemId = (element) => parseInt($parent(element, "li").dataset.id, 10);

let _setFilter = (currentPage) => {
    qs(".filters .selected").className = "";
    qs(`.filters [href="#/${currentPage}"]`).className = "selected";
};

let _elementComplete = (id, completed) => {
    let listItem = qs(`[data-id="${id}"]`);

    if (!listItem)
        return;

    listItem.className = completed ? "completed" : "";

    // In case it was toggled from an event and not by clicking the checkbox
    qs("input", listItem).checked = completed;
};

let _editItem = (id, title) => {
    let listItem = qs(`[data-id="${id}"]`);

    if (!listItem)
        return;

    listItem.className += " editing";

    let input = document.createElement("input");
    input.className = "edit";

    listItem.appendChild(input);
    input.focus();
    input.value = title;
};

/**
 * View that abstracts away the browser's DOM completely.
 * It has two simple entry points:
 *
 *   - bind(eventName, handler)
 *     Takes a todo application event and registers the handler
 *   - render(command, parameterObject)
 *     Renders the given command with the options
 */
/* eslint no-undef: 0 */
/* eslint no-unused-vars: 0 */
/* eslint no-return-assign: 0 */
class View {
    constructor(template) {
        this.template = template;

        this.ENTER_KEY = 13;
        this.ESCAPE_KEY = 27;

        this.$todoList = qs(".todo-list");
        this.$todoItemCounter = qs(".todo-count");
        this.$clearCompleted = qs(".clear-completed");
        this.$main = qs(".main");
        this.$footer = qs(".footer");
        this.$toggleAll = qs(".toggle-all-label");
        this.$toggleAllInput = qs(".toggle-all");
        this.$newTodo = qs(".new-todo");

        this.viewCommands = {
            showEntries: (parameter) => this.$todoList.innerHTML = this.template.show(parameter),
            removeItem: (parameter) => this._removeItem(parameter),
            updateElementCount: (parameter) => this.$todoItemCounter.innerHTML = this.template.itemCounter(parameter),
            clearCompletedButton: (parameter) => this._clearCompletedButton(parameter.completed, parameter.visible),
            contentBlockVisibility: (parameter) => this.$main.style.display = this.$footer.style.display = parameter.visible ? "block" : "none",
            toggleAll: (parameter) => this.$toggleAll.checked = parameter.checked,
            setFilter: (parameter) => _setFilter(parameter),
            clearNewTodo: (parameter) => this.$newTodo.value = "",
            elementComplete: (parameter) => _elementComplete(parameter.id, parameter.completed),
            editItem: (parameter) => _editItem(parameter.id, parameter.title),
            editItemDone: (parameter) => this._editItemDone(parameter.id, parameter.title),
        };
    }

    _removeItem(id) {
        let elem = qs(`[data-id="${id}"]`);

        if (elem)
            this.$todoList.removeChild(elem);
    }

    _clearCompletedButton(completedCount, visible) {
        this.$clearCompleted.innerHTML = this.template.clearCompletedButton(completedCount);
        this.$clearCompleted.style.display = visible ? "block" : "none";
    }

    _editItemDone(id, title) {
        let listItem = qs(`[data-id="${id}"]`);

        if (!listItem)
            return;

        let input = qs("input.edit", listItem);
        listItem.removeChild(input);

        listItem.className = listItem.className.replace(" editing", "");

        qsa("label", listItem).forEach((label) => label.textContent = title);
    }

    render(viewCmd, parameter) {
        this.viewCommands[viewCmd](parameter);
    }

    _bindItemEditDone(handler) {
        let self = this;

        $delegate(self.$todoList, "li .edit", "blur", function () {
            if (!this.dataset.iscanceled) {
                handler({
                    id: _itemId(this),
                    title: this.value,
                });
            }
        });

        // Remove the cursor from the input when you hit enter just like if it were a real form
        $delegate(self.$todoList, "li .edit", "keypress", function (event) {
            if (event.keyCode === self.ENTER_KEY)
                this.blur();
        });
    }

    _bindItemEditCancel(handler) {
        let self = this;

        $delegate(self.$todoList, "li .edit", "keyup", function (event) {
            if (event.keyCode === self.ESCAPE_KEY) {
                let id = _itemId(this);
                this.dataset.iscanceled = true;
                this.blur();

                handler({ id });
            }
        });
    }

    bind(event, handler) {
        var self = this;
        if (event === "newTodo") {
            $on(this.$newTodo, "change", () => handler(this.$newTodo.value));
        } else if (event === "removeCompleted") {
            $on(this.$clearCompleted, "click", handler);
        } else if (event === "toggleAll") {
            $on(this.$toggleAll, "click", function () {
                self.$toggleAllInput.click();
                handler({ completed: self.$toggleAllInput.checked });
            });
        } else if (event === "itemEdit") {
            $delegate(this.$todoList, "li label", "dblclick", function () {
                handler({ id: _itemId(this) });
            });
        } else if (event === "itemRemove") {
            $delegate(this.$todoList, ".destroy", "click", function () {
                handler({ id: _itemId(this) });
            });
        } else if (event === "itemToggle") {
            $delegate(this.$todoList, ".toggle", "click", function () {
                handler({
                    id: _itemId(this),
                    completed: this.checked,
                });
            });
        } else if (event === "itemEditDone") {
            this._bindItemEditDone(handler);
        } else if (event === "itemEditCancel") {
            this._bindItemEditCancel(handler);
        }
    }
};
;
        

// Load contents of ../resources/todomvc/vanilla-examples/javascript-es6/src/controller.js
;/* eslint no-unused-vars: 0 */
"use strict";

class Controller {
    /**
     * Take a model & view, then act as controller between them
     * @param  {object} model The model instance
     * @param  {object} view  The view instance
     */
    constructor(model, view) {
        this.model = model;
        this.view = view;

        this.view.bind("newTodo", (title) => this.addItem(title));
        this.view.bind("itemEdit", (item) => this.editItem(item.id));
        this.view.bind("itemEditDone", (item) => this.editItemSave(item.id, item.title));
        this.view.bind("itemEditCancel", (item) => this.editItemCancel(item.id));
        this.view.bind("itemRemove", (item) => this.removeItem(item.id));
        this.view.bind("itemToggle", (item) => this.toggleComplete(item.id, item.completed));
        this.view.bind("removeCompleted", () => this.removeCompletedItems());
        this.view.bind("toggleAll", (status) => this.toggleAll(status.completed));
    }

    /**
     * Load & Initialize the view
     * @param {string}  '' | 'active' | 'completed'
     */
    setView(hash) {
        let route = hash.split("/")[1];
        let page = route || "";
        this._updateFilter(page);
    }

    /**
     * Event fires on load. Gets all items & displays them
     */
    showAll() {
        this.model.read((data) => this.view.render("showEntries", data));
    }

    /**
     * Renders all active tasks
     */
    showActive() {
        this.model.read({ completed: false }, (data) => this.view.render("showEntries", data));
    }

    /**
     * Renders all completed tasks
     */
    showCompleted() {
        this.model.read({ completed: true }, (data) => this.view.render("showEntries", data));
    }

    /**
     * An event to fire whenever you want to add an item. Simply pass in the event
     * object and it'll handle the DOM insertion and saving of the new item.
     */
    addItem(title) {
        if (title.trim() === "")
            return;

        this.model.create(title, () => {
            this.view.render("clearNewTodo");
            this._filter(true);
        });
    }

    /*
     * Triggers the item editing mode.
     */
    editItem(id) {
        this.model.read(id, (data) => {
            let title = data[0].title;
            this.view.render("editItem", { id, title });
        });
    }

    /*
     * Finishes the item editing mode successfully.
     */
    editItemSave(id, title) {
        title = title.trim();

        if (title.length !== 0) {
            this.model.update(id, { title }, () => {
                this.view.render("editItemDone", { id, title });
            });
        } else {
            this.removeItem(id);
        }
    }

    /*
     * Cancels the item editing mode.
     */
    editItemCancel(id) {
        this.model.read(id, (data) => {
            let title = data[0].title;
            this.view.render("editItemDone", { id, title });
        });
    }

    /**
     * Find the DOM element with given ID,
     * Then remove it from DOM & Storage
     */
    removeItem(id) {
        this.model.remove(id, () => this.view.render("removeItem", id));
        this._filter();
    }

    /**
     * Will remove all completed items from the DOM and storage.
     */
    removeCompletedItems() {
        this.model.read({ completed: true }, (data) => {
            for (let item of data)
                this.removeItem(item.id);
        });

        this._filter();
    }

    /**
     * Give it an ID of a model and a checkbox and it will update the item
     * in storage based on the checkbox's state.
     *
     * @param {number} id The ID of the element to complete or uncomplete
     * @param {object} checkbox The checkbox to check the state of complete
     *                          or not
     * @param {boolean|undefined} silent Prevent re-filtering the todo items
     */
    toggleComplete(id, completed, silent) {
        this.model.update(id, { completed }, () => {
            this.view.render("elementComplete", { id, completed });
        });

        if (!silent)
            this._filter();
    }

    /**
     * Will toggle ALL checkboxes' on/off state and completeness of models.
     * Just pass in the event object.
     */
    toggleAll(completed) {
        this.model.read({ completed: !completed }, (data) => {
            for (let item of data)
                this.toggleComplete(item.id, completed, true);
        });

        this._filter();
    }

    /**
     * Updates the pieces of the page which change depending on the remaining
     * number of todos.
     */
    _updateCount() {
        this.model.getCount((todos) => {
            const completed = todos.completed;
            const visible = completed > 0;
            const checked = completed === todos.total;

            this.view.render("updateElementCount", todos.active);
            this.view.render("clearCompletedButton", { completed, visible });

            this.view.render("toggleAll", { checked });
            this.view.render("contentBlockVisibility", { visible: todos.total > 0 });
        });
    }

    /**
     * Re-filters the todo items, based on the active route.
     * @param {boolean|undefined} force  forces a re-painting of todo items.
     */
    _filter(force) {
        let active = this._activeRoute;
        const activeRoute = active.charAt(0).toUpperCase() + active.substr(1);

        // Update the elements on the page, which change with each completed todo
        this._updateCount();

        // If the last active route isn't "All", or we're switching routes, we
        // re-create the todo item elements, calling:
        //   this.show[All|Active|Completed]()
        if (force || this._lastActiveRoute !== "All" || this._lastActiveRoute !== activeRoute)
            this[`show${activeRoute}`]();

        this._lastActiveRoute = activeRoute;
    }

    /**
     * Simply updates the filter nav's selected states
     */
    _updateFilter(currentPage) {
        // Store a reference to the active route, allowing us to re-filter todo
        // items as they are marked complete or incomplete.
        this._activeRoute = currentPage;

        if (currentPage === "")
            this._activeRoute = "All";

        this._filter();

        this.view.render("setFilter", currentPage);
    }
};
;
        

// Load contents of ../resources/todomvc/vanilla-examples/javascript-es6/src/app.js
;/* eslint no-undef: 0 */
"use strict";

let todo;
const setView = () => todo.controller.setView(document.location.hash);

class Todo {
    /**
     * Init new Todo List
     * @param  {string} The name of your list
     */
    constructor(name) {
        this.storage = new Store(name);
        this.model = new Model(this.storage);

        this.template = new Template();
        this.view = new View(this.template);

        this.controller = new Controller(this.model, this.view);
    }
}

$on(window, "load", () => {
    todo = new Todo("javascript-es6");
    setView();
});

$on(window, "hashchange", setView);;
;
        window.dispatchEvent(new Event('load'))
	function benchmark() {
    let newTodo = document.getElementsByClassName("new-todo")[0];
    var ENTER_KEY = 13;
    var numberOfItemsToAdd = 100;
    let total = 0;
    let start = performance.now();
    function addingItems() {
        for (let i = 0; i < numberOfItemsToAdd; i++) {
            newTodo.value = 'Something to do ' + i;
            newTodo.dispatchEvent(new Event('change'))
            var e = new Event('keypress')
            e.keyCode = ENTER_KEY;
            e.key = "Enter"
            newTodo.dispatchEvent(e)
        }
        drainJobQueue()
    }
    addingItems()
    let end = performance.now();
    console.log(`RESULTS-Adding${numberOfItemsToAdd}Items ${end - start}`);
    function toggleItems() {
        let checkboxes = Array.prototype.slice.call(document.getElementsByClassName("toggle"));
        console.log(checkboxes.length)
        for (let i = 0; i < numberOfItemsToAdd; i++) {
            checkboxes[i].dispatchEvent(new Event('change'));
        }
        drainJobQueue()

    }
    toggleItems()
    end = performance.now();
    console.log(`RESULTS-CompletingAllItems ${end - start}`);
    total += end - start;

    start = performance.now();
    function removeItems() {
        let deleteButtons = Array.prototype.slice.call(document.getElementsByClassName("destroy"));
        let start = performance.now();
        for (let i = 0; i < numberOfItemsToAdd; i++) {
            deleteButtons[i].dispatchEvent(new Event('click'));
        }
        drainJobQueue()
    }
    removeItems()
    end = performance.now();
    console.log(`RESULTS-DeletingAllItems ${end - start}`);
    total += end - start;
    console.log(`RESULTS-Total ${total}`);
}
benchmark()
	/*
    </body>
</html>*/
