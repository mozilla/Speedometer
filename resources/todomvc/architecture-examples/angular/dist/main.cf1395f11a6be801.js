"use strict";

(self["webpackChunkangular"] = self["webpackChunkangular"] || []).push([ [ 179 ], {
    677: () => {
        function isFunction(value) {
            return typeof value === "function";
        }
        function createErrorClass(createImpl) {
            const _super = instance => {
                Error.call(instance);
                instance.stack = (new Error).stack;
            };
            const ctorFunc = createImpl(_super);
            ctorFunc.prototype = Object.create(Error.prototype);
            ctorFunc.prototype.constructor = ctorFunc;
            return ctorFunc;
        }
        const UnsubscriptionError = createErrorClass(_super => function UnsubscriptionErrorImpl(errors) {
            _super(this);
            this.message = errors ? `${errors.length} errors occurred during unsubscription:\n${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join("\n  ")}` : "";
            this.name = "UnsubscriptionError";
            this.errors = errors;
        });
        function arrRemove(arr, item) {
            if (arr) {
                const index = arr.indexOf(item);
                0 <= index && arr.splice(index, 1);
            }
        }
        class Subscription {
            constructor(initialTeardown) {
                this.initialTeardown = initialTeardown;
                this.closed = false;
                this._parentage = null;
                this._finalizers = null;
            }
            unsubscribe() {
                let errors;
                if (!this.closed) {
                    this.closed = true;
                    const {_parentage} = this;
                    if (_parentage) {
                        this._parentage = null;
                        if (Array.isArray(_parentage)) {
                            for (const parent of _parentage) {
                                parent.remove(this);
                            }
                        } else {
                            _parentage.remove(this);
                        }
                    }
                    const {initialTeardown: initialFinalizer} = this;
                    if (isFunction(initialFinalizer)) {
                        try {
                            initialFinalizer();
                        } catch (e) {
                            errors = e instanceof UnsubscriptionError ? e.errors : [ e ];
                        }
                    }
                    const {_finalizers} = this;
                    if (_finalizers) {
                        this._finalizers = null;
                        for (const finalizer of _finalizers) {
                            try {
                                execFinalizer(finalizer);
                            } catch (err) {
                                errors = errors !== null && errors !== void 0 ? errors : [];
                                if (err instanceof UnsubscriptionError) {
                                    errors = [ ...errors, ...err.errors ];
                                } else {
                                    errors.push(err);
                                }
                            }
                        }
                    }
                    if (errors) {
                        throw new UnsubscriptionError(errors);
                    }
                }
            }
            add(teardown) {
                var _a;
                if (teardown && teardown !== this) {
                    if (this.closed) {
                        execFinalizer(teardown);
                    } else {
                        if (teardown instanceof Subscription) {
                            if (teardown.closed || teardown._hasParent(this)) {
                                return;
                            }
                            teardown._addParent(this);
                        }
                        (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
                    }
                }
            }
            _hasParent(parent) {
                const {_parentage} = this;
                return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
            }
            _addParent(parent) {
                const {_parentage} = this;
                this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [ _parentage, parent ] : parent;
            }
            _removeParent(parent) {
                const {_parentage} = this;
                if (_parentage === parent) {
                    this._parentage = null;
                } else if (Array.isArray(_parentage)) {
                    arrRemove(_parentage, parent);
                }
            }
            remove(teardown) {
                const {_finalizers} = this;
                _finalizers && arrRemove(_finalizers, teardown);
                if (teardown instanceof Subscription) {
                    teardown._removeParent(this);
                }
            }
        }
        Subscription.EMPTY = (() => {
            const empty2 = new Subscription;
            empty2.closed = true;
            return empty2;
        })();
        const EMPTY_SUBSCRIPTION = Subscription.EMPTY;
        function isSubscription(value) {
            return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
        }
        function execFinalizer(finalizer) {
            if (isFunction(finalizer)) {
                finalizer();
            } else {
                finalizer.unsubscribe();
            }
        }
        const config = {
            onUnhandledError: null,
            onStoppedNotification: null,
            Promise: void 0,
            useDeprecatedSynchronousErrorHandling: false,
            useDeprecatedNextContext: false
        };
        const timeoutProvider = {
            setTimeout(handler, timeout, ...args) {
                const {delegate} = timeoutProvider;
                if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
                    return delegate.setTimeout(handler, timeout, ...args);
                }
                return setTimeout(handler, timeout, ...args);
            },
            clearTimeout(handle) {
                const {delegate} = timeoutProvider;
                return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
            },
            delegate: void 0
        };
        function reportUnhandledError(err) {
            timeoutProvider.setTimeout(() => {
                const {onUnhandledError} = config;
                if (onUnhandledError) {
                    onUnhandledError(err);
                } else {
                    throw err;
                }
            });
        }
        function noop() {}
        const COMPLETE_NOTIFICATION = (() => createNotification("C", void 0, void 0))();
        function errorNotification(error) {
            return createNotification("E", void 0, error);
        }
        function nextNotification(value) {
            return createNotification("N", value, void 0);
        }
        function createNotification(kind, value, error) {
            return {
                kind,
                value,
                error
            };
        }
        let context = null;
        function errorContext(cb) {
            if (config.useDeprecatedSynchronousErrorHandling) {
                const isRoot = !context;
                if (isRoot) {
                    context = {
                        errorThrown: false,
                        error: null
                    };
                }
                cb();
                if (isRoot) {
                    const {errorThrown, error} = context;
                    context = null;
                    if (errorThrown) {
                        throw error;
                    }
                }
            } else {
                cb();
            }
        }
        function captureError(err) {
            if (config.useDeprecatedSynchronousErrorHandling && context) {
                context.errorThrown = true;
                context.error = err;
            }
        }
        class Subscriber extends Subscription {
            constructor(destination) {
                super();
                this.isStopped = false;
                if (destination) {
                    this.destination = destination;
                    if (isSubscription(destination)) {
                        destination.add(this);
                    }
                } else {
                    this.destination = EMPTY_OBSERVER;
                }
            }
            static create(next, error, complete) {
                return new SafeSubscriber(next, error, complete);
            }
            next(value) {
                if (this.isStopped) {
                    handleStoppedNotification(nextNotification(value), this);
                } else {
                    this._next(value);
                }
            }
            error(err) {
                if (this.isStopped) {
                    handleStoppedNotification(errorNotification(err), this);
                } else {
                    this.isStopped = true;
                    this._error(err);
                }
            }
            complete() {
                if (this.isStopped) {
                    handleStoppedNotification(COMPLETE_NOTIFICATION, this);
                } else {
                    this.isStopped = true;
                    this._complete();
                }
            }
            unsubscribe() {
                if (!this.closed) {
                    this.isStopped = true;
                    super.unsubscribe();
                    this.destination = null;
                }
            }
            _next(value) {
                this.destination.next(value);
            }
            _error(err) {
                try {
                    this.destination.error(err);
                } finally {
                    this.unsubscribe();
                }
            }
            _complete() {
                try {
                    this.destination.complete();
                } finally {
                    this.unsubscribe();
                }
            }
        }
        const _bind = Function.prototype.bind;
        function bind(fn, thisArg) {
            return _bind.call(fn, thisArg);
        }
        class ConsumerObserver {
            constructor(partialObserver) {
                this.partialObserver = partialObserver;
            }
            next(value) {
                const {partialObserver} = this;
                if (partialObserver.next) {
                    try {
                        partialObserver.next(value);
                    } catch (error) {
                        handleUnhandledError(error);
                    }
                }
            }
            error(err) {
                const {partialObserver} = this;
                if (partialObserver.error) {
                    try {
                        partialObserver.error(err);
                    } catch (error) {
                        handleUnhandledError(error);
                    }
                } else {
                    handleUnhandledError(err);
                }
            }
            complete() {
                const {partialObserver} = this;
                if (partialObserver.complete) {
                    try {
                        partialObserver.complete();
                    } catch (error) {
                        handleUnhandledError(error);
                    }
                }
            }
        }
        class SafeSubscriber extends Subscriber {
            constructor(observerOrNext, error, complete) {
                super();
                let partialObserver;
                if (isFunction(observerOrNext) || !observerOrNext) {
                    partialObserver = {
                        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
                        error: error !== null && error !== void 0 ? error : void 0,
                        complete: complete !== null && complete !== void 0 ? complete : void 0
                    };
                } else {
                    let context2;
                    if (this && config.useDeprecatedNextContext) {
                        context2 = Object.create(observerOrNext);
                        context2.unsubscribe = () => this.unsubscribe();
                        partialObserver = {
                            next: observerOrNext.next && bind(observerOrNext.next, context2),
                            error: observerOrNext.error && bind(observerOrNext.error, context2),
                            complete: observerOrNext.complete && bind(observerOrNext.complete, context2)
                        };
                    } else {
                        partialObserver = observerOrNext;
                    }
                }
                this.destination = new ConsumerObserver(partialObserver);
            }
        }
        function handleUnhandledError(error) {
            if (config.useDeprecatedSynchronousErrorHandling) {
                captureError(error);
            } else {
                reportUnhandledError(error);
            }
        }
        function defaultErrorHandler(err) {
            throw err;
        }
        function handleStoppedNotification(notification, subscriber) {
            const {onStoppedNotification} = config;
            onStoppedNotification && timeoutProvider.setTimeout(() => onStoppedNotification(notification, subscriber));
        }
        const EMPTY_OBSERVER = {
            closed: true,
            next: noop,
            error: defaultErrorHandler,
            complete: noop
        };
        const observable = (() => typeof Symbol === "function" && Symbol.observable || "@@observable")();
        function identity(x) {
            return x;
        }
        function pipe(...fns) {
            return pipeFromArray(fns);
        }
        function pipeFromArray(fns) {
            if (fns.length === 0) {
                return identity;
            }
            if (fns.length === 1) {
                return fns[0];
            }
            return function piped(input) {
                return fns.reduce((prev, fn) => fn(prev), input);
            };
        }
        let Observable_Observable = (() => {
            class Observable2 {
                constructor(subscribe) {
                    if (subscribe) {
                        this._subscribe = subscribe;
                    }
                }
                lift(operator) {
                    const observable2 = new Observable2;
                    observable2.source = this;
                    observable2.operator = operator;
                    return observable2;
                }
                subscribe(observerOrNext, error, complete) {
                    const subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
                    errorContext(() => {
                        const {operator, source} = this;
                        subscriber.add(operator ? operator.call(subscriber, source) : source ? this._subscribe(subscriber) : this._trySubscribe(subscriber));
                    });
                    return subscriber;
                }
                _trySubscribe(sink) {
                    try {
                        return this._subscribe(sink);
                    } catch (err) {
                        sink.error(err);
                    }
                }
                forEach(next, promiseCtor) {
                    promiseCtor = getPromiseCtor(promiseCtor);
                    return new promiseCtor((resolve, reject) => {
                        const subscriber = new SafeSubscriber({
                            next: value => {
                                try {
                                    next(value);
                                } catch (err) {
                                    reject(err);
                                    subscriber.unsubscribe();
                                }
                            },
                            error: reject,
                            complete: resolve
                        });
                        this.subscribe(subscriber);
                    });
                }
                _subscribe(subscriber) {
                    var _a;
                    return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
                }
                [observable]() {
                    return this;
                }
                pipe(...operations) {
                    return pipeFromArray(operations)(this);
                }
                toPromise(promiseCtor) {
                    promiseCtor = getPromiseCtor(promiseCtor);
                    return new promiseCtor((resolve, reject) => {
                        let value;
                        this.subscribe(x => value = x, err => reject(err), () => resolve(value));
                    });
                }
            }
            Observable2.create = subscribe => new Observable2(subscribe);
            return Observable2;
        })();
        function getPromiseCtor(promiseCtor) {
            var _a;
            return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
        }
        function isObserver(value) {
            return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
        }
        function isSubscriber(value) {
            return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
        }
        const ObjectUnsubscribedError = createErrorClass(_super => function ObjectUnsubscribedErrorImpl() {
            _super(this);
            this.name = "ObjectUnsubscribedError";
            this.message = "object unsubscribed";
        });
        let Subject = (() => {
            class Subject2 extends Observable_Observable {
                constructor() {
                    super();
                    this.closed = false;
                    this.currentObservers = null;
                    this.observers = [];
                    this.isStopped = false;
                    this.hasError = false;
                    this.thrownError = null;
                }
                lift(operator) {
                    const subject = new AnonymousSubject(this, this);
                    subject.operator = operator;
                    return subject;
                }
                _throwIfClosed() {
                    if (this.closed) {
                        throw new ObjectUnsubscribedError;
                    }
                }
                next(value) {
                    errorContext(() => {
                        this._throwIfClosed();
                        if (!this.isStopped) {
                            if (!this.currentObservers) {
                                this.currentObservers = Array.from(this.observers);
                            }
                            for (const observer of this.currentObservers) {
                                observer.next(value);
                            }
                        }
                    });
                }
                error(err) {
                    errorContext(() => {
                        this._throwIfClosed();
                        if (!this.isStopped) {
                            this.hasError = this.isStopped = true;
                            this.thrownError = err;
                            const {observers} = this;
                            while (observers.length) {
                                observers.shift().error(err);
                            }
                        }
                    });
                }
                complete() {
                    errorContext(() => {
                        this._throwIfClosed();
                        if (!this.isStopped) {
                            this.isStopped = true;
                            const {observers} = this;
                            while (observers.length) {
                                observers.shift().complete();
                            }
                        }
                    });
                }
                unsubscribe() {
                    this.isStopped = this.closed = true;
                    this.observers = this.currentObservers = null;
                }
                get observed() {
                    var _a;
                    return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
                }
                _trySubscribe(subscriber) {
                    this._throwIfClosed();
                    return super._trySubscribe(subscriber);
                }
                _subscribe(subscriber) {
                    this._throwIfClosed();
                    this._checkFinalizedStatuses(subscriber);
                    return this._innerSubscribe(subscriber);
                }
                _innerSubscribe(subscriber) {
                    const {hasError, isStopped, observers} = this;
                    if (hasError || isStopped) {
                        return EMPTY_SUBSCRIPTION;
                    }
                    this.currentObservers = null;
                    observers.push(subscriber);
                    return new Subscription(() => {
                        this.currentObservers = null;
                        arrRemove(observers, subscriber);
                    });
                }
                _checkFinalizedStatuses(subscriber) {
                    const {hasError, thrownError, isStopped} = this;
                    if (hasError) {
                        subscriber.error(thrownError);
                    } else if (isStopped) {
                        subscriber.complete();
                    }
                }
                asObservable() {
                    const observable2 = new Observable_Observable;
                    observable2.source = this;
                    return observable2;
                }
            }
            Subject2.create = (destination, source) => new AnonymousSubject(destination, source);
            return Subject2;
        })();
        class AnonymousSubject extends Subject {
            constructor(destination, source) {
                super();
                this.destination = destination;
                this.source = source;
            }
            next(value) {
                var _a, _b;
                (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
            }
            error(err) {
                var _a, _b;
                (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
            }
            complete() {
                var _a, _b;
                (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
            }
            _subscribe(subscriber) {
                var _a, _b;
                return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
            }
        }
        function hasLift(source) {
            return isFunction(source === null || source === void 0 ? void 0 : source.lift);
        }
        function operate(init) {
            return source => {
                if (hasLift(source)) {
                    return source.lift(function(liftedSource) {
                        try {
                            return init(liftedSource, this);
                        } catch (err) {
                            this.error(err);
                        }
                    });
                }
                throw new TypeError("Unable to lift unknown Observable type");
            };
        }
        function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
            return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
        }
        class OperatorSubscriber extends Subscriber {
            constructor(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
                super(destination);
                this.onFinalize = onFinalize;
                this.shouldUnsubscribe = shouldUnsubscribe;
                this._next = onNext ? function(value) {
                    try {
                        onNext(value);
                    } catch (err) {
                        destination.error(err);
                    }
                } : super._next;
                this._error = onError ? function(err) {
                    try {
                        onError(err);
                    } catch (err2) {
                        destination.error(err2);
                    } finally {
                        this.unsubscribe();
                    }
                } : super._error;
                this._complete = onComplete ? function() {
                    try {
                        onComplete();
                    } catch (err) {
                        destination.error(err);
                    } finally {
                        this.unsubscribe();
                    }
                } : super._complete;
            }
            unsubscribe() {
                var _a;
                if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
                    const {closed} = this;
                    super.unsubscribe();
                    !closed && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
                }
            }
        }
        function map(project, thisArg) {
            return operate((source, subscriber) => {
                let index = 0;
                source.subscribe(createOperatorSubscriber(subscriber, value => {
                    subscriber.next(project.call(thisArg, value, index++));
                }));
            });
        }
        var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
            } || function(d2, b2) {
                for (var p in b2) {
                    if (Object.prototype.hasOwnProperty.call(b2, p)) {
                        d2[p] = b2[p];
                    }
                }
            };
            return extendStatics(d, b);
        };
        function __extends(d, b) {
            if (typeof b !== "function" && b !== null) {
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            }
            extendStatics(d, b);
            function __() {
                this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
        }
        var __assign = function() {
            __assign = Object.assign || function __assign2(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (var p in s) {
                        if (Object.prototype.hasOwnProperty.call(s, p)) {
                            t[p] = s[p];
                        }
                    }
                }
                return t;
            };
            return __assign.apply(this, arguments);
        };
        function __rest(s, e) {
            var t = {};
            for (var p in s) {
                if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) {
                    t[p] = s[p];
                }
            }
            if (s != null && typeof Object.getOwnPropertySymbols === "function") {
                for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) {
                        t[p[i]] = s[p[i]];
                    }
                }
            }
            return t;
        }
        function __decorate(decorators, target, key, desc) {
            var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
            if (typeof Reflect === "object" && typeof Reflect.decorate === "function") {
                r = Reflect.decorate(decorators, target, key, desc);
            } else {
                for (var i = decorators.length - 1; i >= 0; i--) {
                    if (d = decorators[i]) {
                        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    }
                }
            }
            return c > 3 && r && Object.defineProperty(target, key, r), r;
        }
        function __param(paramIndex, decorator) {
            return function(target, key) {
                decorator(target, key, paramIndex);
            };
        }
        function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
            function accept(f) {
                if (f !== void 0 && typeof f !== "function") {
                    throw new TypeError("Function expected");
                }
                return f;
            }
            var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
            var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
            var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
            var _, done = false;
            for (var i = decorators.length - 1; i >= 0; i--) {
                var context2 = {};
                for (var p in contextIn) {
                    context2[p] = p === "access" ? {} : contextIn[p];
                }
                for (var p in contextIn.access) {
                    context2.access[p] = contextIn.access[p];
                }
                context2.addInitializer = function(f) {
                    if (done) {
                        throw new TypeError("Cannot add initializers after decoration has completed");
                    }
                    extraInitializers.push(accept(f || null));
                };
                var result = (0, decorators[i])(kind === "accessor" ? {
                    get: descriptor.get,
                    set: descriptor.set
                } : descriptor[key], context2);
                if (kind === "accessor") {
                    if (result === void 0) {
                        continue;
                    }
                    if (result === null || typeof result !== "object") {
                        throw new TypeError("Object expected");
                    }
                    if (_ = accept(result.get)) {
                        descriptor.get = _;
                    }
                    if (_ = accept(result.set)) {
                        descriptor.set = _;
                    }
                    if (_ = accept(result.init)) {
                        initializers.push(_);
                    }
                } else if (_ = accept(result)) {
                    if (kind === "field") {
                        initializers.push(_);
                    } else {
                        descriptor[key] = _;
                    }
                }
            }
            if (target) {
                Object.defineProperty(target, contextIn.name, descriptor);
            }
            done = true;
        }
        function __runInitializers(thisArg, initializers, value) {
            var useValue = arguments.length > 2;
            for (var i = 0; i < initializers.length; i++) {
                value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
            }
            return useValue ? value : void 0;
        }
        function __propKey(x) {
            return typeof x === "symbol" ? x : "".concat(x);
        }
        function __setFunctionName(f, name, prefix) {
            if (typeof name === "symbol") {
                name = name.description ? "[".concat(name.description, "]") : "";
            }
            return Object.defineProperty(f, "name", {
                configurable: true,
                value: prefix ? "".concat(prefix, " ", name) : name
            });
        }
        function __metadata(metadataKey, metadataValue) {
            if (typeof Reflect === "object" && typeof Reflect.metadata === "function") {
                return Reflect.metadata(metadataKey, metadataValue);
            }
        }
        function __awaiter(thisArg, _arguments, P, generator) {
            function adopt(value) {
                return value instanceof P ? value : new P(function(resolve) {
                    resolve(value);
                });
            }
            return new (P || (P = Promise))(function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator["throw"](value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            });
        }
        function __generator(thisArg, body) {
            var _ = {
                label: 0,
                sent: function() {
                    if (t[0] & 1) {
                        throw t[1];
                    }
                    return t[1];
                },
                trys: [],
                ops: []
            }, f, y, t, g;
            return g = {
                next: verb(0),
                throw: verb(1),
                return: verb(2)
            }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
                return this;
            }), g;
            function verb(n) {
                return function(v) {
                    return step([ n, v ]);
                };
            }
            function step(op) {
                if (f) {
                    throw new TypeError("Generator is already executing.");
                }
                while (g && (g = 0, op[0] && (_ = 0)), _) {
                    try {
                        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 
                        0) : y.next) && !(t = t.call(y, op[1])).done) {
                            return t;
                        }
                        if (y = 0, t) {
                            op = [ op[0] & 2, t.value ];
                        }
                        switch (op[0]) {
                          case 0:
                          case 1:
                            t = op;
                            break;

                          case 4:
                            _.label++;
                            return {
                                value: op[1],
                                done: false
                            };

                          case 5:
                            _.label++;
                            y = op[1];
                            op = [ 0 ];
                            continue;

                          case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;

                          default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2]) {
                                _.ops.pop();
                            }
                            _.trys.pop();
                            continue;
                        }
                        op = body.call(thisArg, _);
                    } catch (e) {
                        op = [ 6, e ];
                        y = 0;
                    } finally {
                        f = t = 0;
                    }
                }
                if (op[0] & 5) {
                    throw op[1];
                }
                return {
                    value: op[0] ? op[1] : void 0,
                    done: true
                };
            }
        }
        var __createBinding = Object.create ? function(o, m, k, k2) {
            if (k2 === void 0) {
                k2 = k;
            }
            var desc = Object.getOwnPropertyDescriptor(m, k);
            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                desc = {
                    enumerable: true,
                    get: function() {
                        return m[k];
                    }
                };
            }
            Object.defineProperty(o, k2, desc);
        } : function(o, m, k, k2) {
            if (k2 === void 0) {
                k2 = k;
            }
            o[k2] = m[k];
        };
        function __exportStar(m, o) {
            for (var p in m) {
                if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) {
                    __createBinding(o, m, p);
                }
            }
        }
        function __values(o) {
            var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
            if (m) {
                return m.call(o);
            }
            if (o && typeof o.length === "number") {
                return {
                    next: function() {
                        if (o && i >= o.length) {
                            o = void 0;
                        }
                        return {
                            value: o && o[i++],
                            done: !o
                        };
                    }
                };
            }
            throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }
        function __read(o, n) {
            var m = typeof Symbol === "function" && o[Symbol.iterator];
            if (!m) {
                return o;
            }
            var i = m.call(o), r, ar = [], e;
            try {
                while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
                    ar.push(r.value);
                }
            } catch (error) {
                e = {
                    error
                };
            } finally {
                try {
                    if (r && !r.done && (m = i["return"])) {
                        m.call(i);
                    }
                } finally {
                    if (e) {
                        throw e.error;
                    }
                }
            }
            return ar;
        }
        function __spread() {
            for (var ar = [], i = 0; i < arguments.length; i++) {
                ar = ar.concat(__read(arguments[i]));
            }
            return ar;
        }
        function __spreadArrays() {
            for (var s = 0, i = 0, il = arguments.length; i < il; i++) {
                s += arguments[i].length;
            }
            for (var r = Array(s), k = 0, i = 0; i < il; i++) {
                for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {
                    r[k] = a[j];
                }
            }
            return r;
        }
        function __spreadArray(to, from2, pack) {
            if (pack || arguments.length === 2) {
                for (var i = 0, l = from2.length, ar; i < l; i++) {
                    if (ar || !(i in from2)) {
                        if (!ar) {
                            ar = Array.prototype.slice.call(from2, 0, i);
                        }
                        ar[i] = from2[i];
                    }
                }
            }
            return to.concat(ar || Array.prototype.slice.call(from2));
        }
        function __await(v) {
            return this instanceof __await ? (this.v = v, this) : new __await(v);
        }
        function __asyncGenerator(thisArg, _arguments, generator) {
            if (!Symbol.asyncIterator) {
                throw new TypeError("Symbol.asyncIterator is not defined.");
            }
            var g = generator.apply(thisArg, _arguments || []), i, q = [];
            return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
                return this;
            }, i;
            function verb(n) {
                if (g[n]) {
                    i[n] = function(v) {
                        return new Promise(function(a, b) {
                            q.push([ n, v, a, b ]) > 1 || resume(n, v);
                        });
                    };
                }
            }
            function resume(n, v) {
                try {
                    step(g[n](v));
                } catch (e) {
                    settle(q[0][3], e);
                }
            }
            function step(r) {
                r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
            }
            function fulfill(value) {
                resume("next", value);
            }
            function reject(value) {
                resume("throw", value);
            }
            function settle(f, v) {
                if (f(v), q.shift(), q.length) {
                    resume(q[0][0], q[0][1]);
                }
            }
        }
        function __asyncDelegator(o) {
            var i, p;
            return i = {}, verb("next"), verb("throw", function(e) {
                throw e;
            }), verb("return"), i[Symbol.iterator] = function() {
                return this;
            }, i;
            function verb(n, f) {
                i[n] = o[n] ? function(v) {
                    return (p = !p) ? {
                        value: __await(o[n](v)),
                        done: false
                    } : f ? f(v) : v;
                } : f;
            }
        }
        function __asyncValues(o) {
            if (!Symbol.asyncIterator) {
                throw new TypeError("Symbol.asyncIterator is not defined.");
            }
            var m = o[Symbol.asyncIterator], i;
            return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), 
            i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
                return this;
            }, i);
            function verb(n) {
                i[n] = o[n] && function(v) {
                    return new Promise(function(resolve, reject) {
                        v = o[n](v), settle(resolve, reject, v.done, v.value);
                    });
                };
            }
            function settle(resolve, reject, d, v) {
                Promise.resolve(v).then(function(v2) {
                    resolve({
                        value: v2,
                        done: d
                    });
                }, reject);
            }
        }
        function __makeTemplateObject(cooked, raw) {
            if (Object.defineProperty) {
                Object.defineProperty(cooked, "raw", {
                    value: raw
                });
            } else {
                cooked.raw = raw;
            }
            return cooked;
        }
        var __setModuleDefault = Object.create ? function(o, v) {
            Object.defineProperty(o, "default", {
                enumerable: true,
                value: v
            });
        } : function(o, v) {
            o["default"] = v;
        };
        function __importStar(mod) {
            if (mod && mod.__esModule) {
                return mod;
            }
            var result = {};
            if (mod != null) {
                for (var k in mod) {
                    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) {
                        __createBinding(result, mod, k);
                    }
                }
            }
            __setModuleDefault(result, mod);
            return result;
        }
        function __importDefault(mod) {
            return mod && mod.__esModule ? mod : {
                default: mod
            };
        }
        function __classPrivateFieldGet(receiver, state, kind, f) {
            if (kind === "a" && !f) {
                throw new TypeError("Private accessor was defined without a getter");
            }
            if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) {
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            }
            return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
        }
        function __classPrivateFieldSet(receiver, state, value, kind, f) {
            if (kind === "m") {
                throw new TypeError("Private method is not writable");
            }
            if (kind === "a" && !f) {
                throw new TypeError("Private accessor was defined without a setter");
            }
            if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) {
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            }
            return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), 
            value;
        }
        function __classPrivateFieldIn(state, receiver) {
            if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") {
                throw new TypeError("Cannot use 'in' operator on non-object");
            }
            return typeof state === "function" ? receiver === state : state.has(receiver);
        }
        const isArrayLike = x => x && typeof x.length === "number" && typeof x !== "function";
        function isPromise(value) {
            return isFunction(value === null || value === void 0 ? void 0 : value.then);
        }
        function isInteropObservable(input) {
            return isFunction(input[observable]);
        }
        function isAsyncIterable(obj) {
            return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
        }
        function createInvalidObservableTypeError(input) {
            return new TypeError(`You provided ${input !== null && typeof input === "object" ? "an invalid object" : `'${input}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`);
        }
        function getSymbolIterator() {
            if (typeof Symbol !== "function" || !Symbol.iterator) {
                return "@@iterator";
            }
            return Symbol.iterator;
        }
        const iterator_iterator = getSymbolIterator();
        function isIterable(input) {
            return isFunction(input === null || input === void 0 ? void 0 : input[iterator_iterator]);
        }
        function readableStreamLikeToAsyncGenerator(readableStream) {
            return __asyncGenerator(this, arguments, function* readableStreamLikeToAsyncGenerator_1() {
                const reader = readableStream.getReader();
                try {
                    while (true) {
                        const {value, done} = yield __await(reader.read());
                        if (done) {
                            return yield __await(void 0);
                        }
                        yield yield __await(value);
                    }
                } finally {
                    reader.releaseLock();
                }
            });
        }
        function isReadableStreamLike(obj) {
            return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
        }
        function innerFrom(input) {
            if (input instanceof Observable_Observable) {
                return input;
            }
            if (input != null) {
                if (isInteropObservable(input)) {
                    return fromInteropObservable(input);
                }
                if (isArrayLike(input)) {
                    return fromArrayLike(input);
                }
                if (isPromise(input)) {
                    return fromPromise(input);
                }
                if (isAsyncIterable(input)) {
                    return fromAsyncIterable(input);
                }
                if (isIterable(input)) {
                    return fromIterable(input);
                }
                if (isReadableStreamLike(input)) {
                    return fromReadableStreamLike(input);
                }
            }
            throw createInvalidObservableTypeError(input);
        }
        function fromInteropObservable(obj) {
            return new Observable_Observable(subscriber => {
                const obs = obj[observable]();
                if (isFunction(obs.subscribe)) {
                    return obs.subscribe(subscriber);
                }
                throw new TypeError("Provided object does not correctly implement Symbol.observable");
            });
        }
        function fromArrayLike(array) {
            return new Observable_Observable(subscriber => {
                for (let i = 0; i < array.length && !subscriber.closed; i++) {
                    subscriber.next(array[i]);
                }
                subscriber.complete();
            });
        }
        function fromPromise(promise2) {
            return new Observable_Observable(subscriber => {
                promise2.then(value => {
                    if (!subscriber.closed) {
                        subscriber.next(value);
                        subscriber.complete();
                    }
                }, err => subscriber.error(err)).then(null, reportUnhandledError);
            });
        }
        function fromIterable(iterable) {
            return new Observable_Observable(subscriber => {
                for (const value of iterable) {
                    subscriber.next(value);
                    if (subscriber.closed) {
                        return;
                    }
                }
                subscriber.complete();
            });
        }
        function fromAsyncIterable(asyncIterable) {
            return new Observable_Observable(subscriber => {
                process(asyncIterable, subscriber).catch(err => subscriber.error(err));
            });
        }
        function fromReadableStreamLike(readableStream) {
            return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
        }
        function process(asyncIterable, subscriber) {
            var asyncIterable_1, asyncIterable_1_1;
            var e_1, _a;
            return __awaiter(this, void 0, void 0, function*() {
                try {
                    for (asyncIterable_1 = __asyncValues(asyncIterable); asyncIterable_1_1 = yield asyncIterable_1.next(), 
                    !asyncIterable_1_1.done; ) {
                        const value = asyncIterable_1_1.value;
                        subscriber.next(value);
                        if (subscriber.closed) {
                            return;
                        }
                    }
                } catch (e_1_1) {
                    e_1 = {
                        error: e_1_1
                    };
                } finally {
                    try {
                        if (asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return)) {
                            yield _a.call(asyncIterable_1);
                        }
                    } finally {
                        if (e_1) {
                            throw e_1.error;
                        }
                    }
                }
                subscriber.complete();
            });
        }
        function executeSchedule(parentSubscription, scheduler, work, delay = 0, repeat = false) {
            const scheduleSubscription = scheduler.schedule(function() {
                work();
                if (repeat) {
                    parentSubscription.add(this.schedule(null, delay));
                } else {
                    this.unsubscribe();
                }
            }, delay);
            parentSubscription.add(scheduleSubscription);
            if (!repeat) {
                return scheduleSubscription;
            }
        }
        function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
            const buffer = [];
            let active = 0;
            let index = 0;
            let isComplete = false;
            const checkComplete = () => {
                if (isComplete && !buffer.length && !active) {
                    subscriber.complete();
                }
            };
            const outerNext = value => active < concurrent ? doInnerSub(value) : buffer.push(value);
            const doInnerSub = value => {
                expand && subscriber.next(value);
                active++;
                let innerComplete = false;
                innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, innerValue => {
                    onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
                    if (expand) {
                        outerNext(innerValue);
                    } else {
                        subscriber.next(innerValue);
                    }
                }, () => {
                    innerComplete = true;
                }, void 0, () => {
                    if (innerComplete) {
                        try {
                            active--;
                            while (buffer.length && active < concurrent) {
                                const bufferedValue = buffer.shift();
                                if (innerSubScheduler) {
                                    executeSchedule(subscriber, innerSubScheduler, () => doInnerSub(bufferedValue));
                                } else {
                                    doInnerSub(bufferedValue);
                                }
                            }
                            checkComplete();
                        } catch (err) {
                            subscriber.error(err);
                        }
                    }
                }));
            };
            source.subscribe(createOperatorSubscriber(subscriber, outerNext, () => {
                isComplete = true;
                checkComplete();
            }));
            return () => {
                additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
            };
        }
        function mergeMap(project, resultSelector, concurrent = Infinity) {
            if (isFunction(resultSelector)) {
                return mergeMap((a, i) => map((b, ii) => resultSelector(a, b, i, ii))(innerFrom(project(a, i))), concurrent);
            } else if (typeof resultSelector === "number") {
                concurrent = resultSelector;
            }
            return operate((source, subscriber) => mergeInternals(source, subscriber, project, concurrent));
        }
        function mergeAll(concurrent = Infinity) {
            return mergeMap(identity, concurrent);
        }
        const EMPTY = new Observable_Observable(subscriber => subscriber.complete());
        function empty(scheduler) {
            return scheduler ? emptyScheduled(scheduler) : EMPTY;
        }
        function emptyScheduled(scheduler) {
            return new Observable(subscriber => scheduler.schedule(() => subscriber.complete()));
        }
        function isScheduler(value) {
            return value && isFunction(value.schedule);
        }
        function last(arr) {
            return arr[arr.length - 1];
        }
        function popResultSelector(args) {
            return isFunction(last(args)) ? args.pop() : void 0;
        }
        function popScheduler(args) {
            return isScheduler(last(args)) ? args.pop() : void 0;
        }
        function popNumber(args, defaultValue) {
            return typeof last(args) === "number" ? args.pop() : defaultValue;
        }
        function observeOn(scheduler, delay = 0) {
            return operate((source, subscriber) => {
                source.subscribe(createOperatorSubscriber(subscriber, value => executeSchedule(subscriber, scheduler, () => subscriber.next(value), delay), () => executeSchedule(subscriber, scheduler, () => subscriber.complete(), delay), err => executeSchedule(subscriber, scheduler, () => subscriber.error(err), delay)));
            });
        }
        function subscribeOn(scheduler, delay = 0) {
            return operate((source, subscriber) => {
                subscriber.add(scheduler.schedule(() => source.subscribe(subscriber), delay));
            });
        }
        function scheduleObservable(input, scheduler) {
            return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
        }
        function schedulePromise(input, scheduler) {
            return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
        }
        function scheduleArray(input, scheduler) {
            return new Observable_Observable(subscriber => {
                let i = 0;
                return scheduler.schedule(function() {
                    if (i === input.length) {
                        subscriber.complete();
                    } else {
                        subscriber.next(input[i++]);
                        if (!subscriber.closed) {
                            this.schedule();
                        }
                    }
                });
            });
        }
        function scheduleIterable(input, scheduler) {
            return new Observable_Observable(subscriber => {
                let iterator;
                executeSchedule(subscriber, scheduler, () => {
                    iterator = input[iterator_iterator]();
                    executeSchedule(subscriber, scheduler, () => {
                        let value;
                        let done;
                        try {
                            ({value, done} = iterator.next());
                        } catch (err) {
                            subscriber.error(err);
                            return;
                        }
                        if (done) {
                            subscriber.complete();
                        } else {
                            subscriber.next(value);
                        }
                    }, 0, true);
                });
                return () => isFunction(iterator === null || iterator === void 0 ? void 0 : iterator.return) && iterator.return();
            });
        }
        function scheduleAsyncIterable(input, scheduler) {
            if (!input) {
                throw new Error("Iterable cannot be null");
            }
            return new Observable_Observable(subscriber => {
                executeSchedule(subscriber, scheduler, () => {
                    const iterator = input[Symbol.asyncIterator]();
                    executeSchedule(subscriber, scheduler, () => {
                        iterator.next().then(result => {
                            if (result.done) {
                                subscriber.complete();
                            } else {
                                subscriber.next(result.value);
                            }
                        });
                    }, 0, true);
                });
            });
        }
        function scheduleReadableStreamLike(input, scheduler) {
            return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
        }
        function scheduled(input, scheduler) {
            if (input != null) {
                if (isInteropObservable(input)) {
                    return scheduleObservable(input, scheduler);
                }
                if (isArrayLike(input)) {
                    return scheduleArray(input, scheduler);
                }
                if (isPromise(input)) {
                    return schedulePromise(input, scheduler);
                }
                if (isAsyncIterable(input)) {
                    return scheduleAsyncIterable(input, scheduler);
                }
                if (isIterable(input)) {
                    return scheduleIterable(input, scheduler);
                }
                if (isReadableStreamLike(input)) {
                    return scheduleReadableStreamLike(input, scheduler);
                }
            }
            throw createInvalidObservableTypeError(input);
        }
        function from(input, scheduler) {
            return scheduler ? scheduled(input, scheduler) : innerFrom(input);
        }
        function merge(...args) {
            const scheduler = popScheduler(args);
            const concurrent = popNumber(args, Infinity);
            const sources = args;
            return !sources.length ? EMPTY : sources.length === 1 ? innerFrom(sources[0]) : mergeAll(concurrent)(from(sources, scheduler));
        }
        function share(options = {}) {
            const {connector = () => new Subject, resetOnError = true, resetOnComplete = true, resetOnRefCountZero = true} = options;
            return wrapperSource => {
                let connection;
                let resetConnection;
                let subject;
                let refCount2 = 0;
                let hasCompleted = false;
                let hasErrored = false;
                const cancelReset = () => {
                    resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
                    resetConnection = void 0;
                };
                const reset = () => {
                    cancelReset();
                    connection = subject = void 0;
                    hasCompleted = hasErrored = false;
                };
                const resetAndUnsubscribe = () => {
                    const conn = connection;
                    reset();
                    conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
                };
                return operate((source, subscriber) => {
                    refCount2++;
                    if (!hasErrored && !hasCompleted) {
                        cancelReset();
                    }
                    const dest = subject = subject !== null && subject !== void 0 ? subject : connector();
                    subscriber.add(() => {
                        refCount2--;
                        if (refCount2 === 0 && !hasErrored && !hasCompleted) {
                            resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
                        }
                    });
                    dest.subscribe(subscriber);
                    if (!connection && refCount2 > 0) {
                        connection = new SafeSubscriber({
                            next: value => dest.next(value),
                            error: err => {
                                hasErrored = true;
                                cancelReset();
                                resetConnection = handleReset(reset, resetOnError, err);
                                dest.error(err);
                            },
                            complete: () => {
                                hasCompleted = true;
                                cancelReset();
                                resetConnection = handleReset(reset, resetOnComplete);
                                dest.complete();
                            }
                        });
                        innerFrom(source).subscribe(connection);
                    }
                })(wrapperSource);
            };
        }
        function handleReset(reset, on, ...args) {
            if (on === true) {
                reset();
                return;
            }
            if (on === false) {
                return;
            }
            const onSubscriber = new SafeSubscriber({
                next: () => {
                    onSubscriber.unsubscribe();
                    reset();
                }
            });
            return on(...args).subscribe(onSubscriber);
        }
        function getClosureSafeProperty(objWithPropertyToExtract) {
            for (let key in objWithPropertyToExtract) {
                if (objWithPropertyToExtract[key] === getClosureSafeProperty) {
                    return key;
                }
            }
            throw Error("Could not find renamed property on target object.");
        }
        function fillProperties(target, source) {
            for (const key in source) {
                if (source.hasOwnProperty(key) && !target.hasOwnProperty(key)) {
                    target[key] = source[key];
                }
            }
        }
        function stringify(token) {
            if (typeof token === "string") {
                return token;
            }
            if (Array.isArray(token)) {
                return "[" + token.map(stringify).join(", ") + "]";
            }
            if (token == null) {
                return "" + token;
            }
            if (token.overriddenName) {
                return `${token.overriddenName}`;
            }
            if (token.name) {
                return `${token.name}`;
            }
            const res = token.toString();
            if (res == null) {
                return "" + res;
            }
            const newLineIndex = res.indexOf("\n");
            return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
        }
        function concatStringsWithSpace(before, after) {
            return before == null || before === "" ? after === null ? "" : after : after == null || after === "" ? before : before + " " + after;
        }
        const __forward_ref__ = getClosureSafeProperty({
            __forward_ref__: getClosureSafeProperty
        });
        function forwardRef(forwardRefFn) {
            forwardRefFn.__forward_ref__ = forwardRef;
            forwardRefFn.toString = function() {
                return stringify(this());
            };
            return forwardRefFn;
        }
        function resolveForwardRef(type) {
            return isForwardRef(type) ? type() : type;
        }
        function isForwardRef(fn) {
            return typeof fn === "function" && fn.hasOwnProperty(__forward_ref__) && fn.__forward_ref__ === forwardRef;
        }
        const ERROR_DETAILS_PAGE_BASE_URL = "https://angular.io/errors";
        class RuntimeError extends Error {
            constructor(code, message) {
                super(formatRuntimeError(code, message));
                this.code = code;
            }
        }
        function formatRuntimeError(code, message) {
            const fullCode = `NG0${Math.abs(code)}`;
            let errorMessage = `${fullCode}${message ? ": " + message.trim() : ""}`;
            if (false) {
                const addPeriodSeparator = !errorMessage.match(/[.,;!?]$/);
                const separator = addPeriodSeparator ? "." : "";
                errorMessage = `${errorMessage}${separator} Find more at ${ERROR_DETAILS_PAGE_BASE_URL}/${fullCode}`;
            }
            return errorMessage;
        }
        function renderStringify(value) {
            if (typeof value === "string") {
                return value;
            }
            if (value == null) {
                return "";
            }
            return String(value);
        }
        function stringifyForError(value) {
            if (typeof value === "function") {
                return value.name || value.toString();
            }
            if (typeof value === "object" && value != null && typeof value.type === "function") {
                return value.type.name || value.type.toString();
            }
            return renderStringify(value);
        }
        function throwCyclicDependencyError(token, path) {
            const depPath = path ? `. Dependency path: ${path.join(" > ")} > ${token}` : "";
            throw new RuntimeError(-200, `Circular dependency in DI detected for ${token}${depPath}`);
        }
        function throwMixedMultiProviderError() {
            throw new Error(`Cannot mix multi providers and regular providers`);
        }
        function throwInvalidProviderError(ngModuleType, providers, provider) {
            if (ngModuleType && providers) {
                const providerDetail = providers.map(v => v == provider ? "?" + provider + "?" : "...");
                throw new Error(`Invalid provider for the NgModule '${stringify(ngModuleType)}' - only instances of Provider and Type are allowed, got: [${providerDetail.join(", ")}]`);
            } else if (provider.providers) {
                throw new RuntimeError(207, `Invalid providers from 'importProvidersFrom' present in a non-environment injector. 'importProvidersFrom' can't be used for component providers.`);
            } else {
                throw new Error("Invalid provider");
            }
        }
        function throwProviderNotFoundError(token, injectorName) {
            const injectorDetails = injectorName ? ` in ${injectorName}` : "";
            throw new RuntimeError(-201, false);
        }
        function assertNumber(actual, msg) {
            if (!(typeof actual === "number")) {
                throwError(msg, typeof actual, "number", "===");
            }
        }
        function assertNumberInRange(actual, minInclusive, maxInclusive) {
            assertNumber(actual, "Expected a number");
            assertLessThanOrEqual(actual, maxInclusive, "Expected number to be less than or equal to");
            assertGreaterThanOrEqual(actual, minInclusive, "Expected number to be greater than or equal to");
        }
        function assertString(actual, msg) {
            if (!(typeof actual === "string")) {
                throwError(msg, actual === null ? "null" : typeof actual, "string", "===");
            }
        }
        function assertFunction(actual, msg) {
            if (!(typeof actual === "function")) {
                throwError(msg, actual === null ? "null" : typeof actual, "function", "===");
            }
        }
        function assertEqual(actual, expected, msg) {
            if (!(actual == expected)) {
                throwError(msg, actual, expected, "==");
            }
        }
        function assertNotEqual(actual, expected, msg) {
            if (!(actual != expected)) {
                throwError(msg, actual, expected, "!=");
            }
        }
        function assertSame(actual, expected, msg) {
            if (!(actual === expected)) {
                throwError(msg, actual, expected, "===");
            }
        }
        function assertNotSame(actual, expected, msg) {
            if (!(actual !== expected)) {
                throwError(msg, actual, expected, "!==");
            }
        }
        function assertLessThan(actual, expected, msg) {
            if (!(actual < expected)) {
                throwError(msg, actual, expected, "<");
            }
        }
        function assertLessThanOrEqual(actual, expected, msg) {
            if (!(actual <= expected)) {
                throwError(msg, actual, expected, "<=");
            }
        }
        function assertGreaterThan(actual, expected, msg) {
            if (!(actual > expected)) {
                throwError(msg, actual, expected, ">");
            }
        }
        function assertGreaterThanOrEqual(actual, expected, msg) {
            if (!(actual >= expected)) {
                throwError(msg, actual, expected, ">=");
            }
        }
        function assertNotDefined(actual, msg) {
            if (actual != null) {
                throwError(msg, actual, null, "==");
            }
        }
        function assertDefined(actual, msg) {
            if (actual == null) {
                throwError(msg, actual, null, "!=");
            }
        }
        function throwError(msg, actual, expected, comparison) {
            throw new Error(`ASSERTION ERROR: ${msg}` + (comparison == null ? "" : ` [Expected=> ${expected} ${comparison} ${actual} <=Actual]`));
        }
        function assertDomNode(node) {
            if (!(typeof Node !== "undefined" && node instanceof Node) && !(typeof node === "object" && node != null && node.constructor.name === "WebWorkerRenderNode")) {
                throwError(`The provided value must be an instance of a DOM Node but got ${stringify(node)}`);
            }
        }
        function assertIndexInRange(arr, index) {
            assertDefined(arr, "Array must be defined.");
            const maxLen = arr.length;
            if (index < 0 || index >= maxLen) {
                throwError(`Index expected to be less than ${maxLen} but got ${index}`);
            }
        }
        function assertOneOf(value, ...validValues) {
            if (validValues.indexOf(value) !== -1) {
                return true;
            }
            throwError(`Expected value to be one of ${JSON.stringify(validValues)} but was ${JSON.stringify(value)}.`);
        }
        function defineInjectable(opts) {
            return {
                token: opts.token,
                providedIn: opts.providedIn || null,
                factory: opts.factory,
                value: void 0
            };
        }
        const defineInjectable = null;
        function defineInjector(options) {
            return {
                providers: options.providers || [],
                imports: options.imports || []
            };
        }
        function getInjectableDef(type) {
            return getOwnDefinition(type, NG_PROV_DEF) || getOwnDefinition(type, NG_INJECTABLE_DEF);
        }
        function isInjectable(type) {
            return getInjectableDef(type) !== null;
        }
        function getOwnDefinition(type, field) {
            return type.hasOwnProperty(field) ? type[field] : null;
        }
        function getInheritedInjectableDef(type) {
            const def = type && (type[NG_PROV_DEF] || type[NG_INJECTABLE_DEF]);
            if (def) {
                const typeName = getTypeName(type);
                console.warn(`DEPRECATED: DI is instantiating a token "${typeName}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${typeName}" class.`);
                return def;
            } else {
                return null;
            }
        }
        function getTypeName(type) {
            if (type.hasOwnProperty("name")) {
                return type.name;
            }
            const match2 = ("" + type).match(/^function\s*([^\s(]+)/);
            return match2 === null ? "" : match2[1];
        }
        function getInjectorDef(type) {
            return type && (type.hasOwnProperty(NG_INJ_DEF) || type.hasOwnProperty(NG_INJECTOR_DEF)) ? type[NG_INJ_DEF] : null;
        }
        const NG_PROV_DEF = getClosureSafeProperty({
            prov: getClosureSafeProperty
        });
        const NG_INJ_DEF = getClosureSafeProperty({
            inj: getClosureSafeProperty
        });
        const NG_INJECTABLE_DEF = getClosureSafeProperty({
            ngInjectableDef: getClosureSafeProperty
        });
        const NG_INJECTOR_DEF = getClosureSafeProperty({
            ngInjectorDef: getClosureSafeProperty
        });
        var InjectFlags = (() => {
            InjectFlags = InjectFlags || {};
            InjectFlags[InjectFlags["Default"] = 0] = "Default";
            InjectFlags[InjectFlags["Host"] = 1] = "Host";
            InjectFlags[InjectFlags["Self"] = 2] = "Self";
            InjectFlags[InjectFlags["SkipSelf"] = 4] = "SkipSelf";
            InjectFlags[InjectFlags["Optional"] = 8] = "Optional";
            return InjectFlags;
        })();
        let _injectImplementation;
        function getInjectImplementation() {
            return _injectImplementation;
        }
        function setInjectImplementation(impl) {
            const previous = _injectImplementation;
            _injectImplementation = impl;
            return previous;
        }
        function injectRootLimpMode(token, notFoundValue, flags) {
            const injectableDef = getInjectableDef(token);
            if (injectableDef && injectableDef.providedIn == "root") {
                return injectableDef.value === void 0 ? injectableDef.value = injectableDef.factory() : injectableDef.value;
            }
            if (flags & InjectFlags.Optional) {
                return null;
            }
            if (notFoundValue !== void 0) {
                return notFoundValue;
            }
            throwProviderNotFoundError(stringify(token), "Injector");
        }
        function assertInjectImplementationNotEqual(fn) {}
        function noSideEffects(fn) {
            return {
                toString: fn
            }.toString();
        }
        var ChangeDetectionStrategy = (() => {
            ChangeDetectionStrategy = ChangeDetectionStrategy || {};
            ChangeDetectionStrategy[ChangeDetectionStrategy["OnPush"] = 0] = "OnPush";
            ChangeDetectionStrategy[ChangeDetectionStrategy["Default"] = 1] = "Default";
            return ChangeDetectionStrategy;
        })();
        var ChangeDetectorStatus = null;
        function isDefaultChangeDetectionStrategy(changeDetectionStrategy) {
            return changeDetectionStrategy == null || changeDetectionStrategy === ChangeDetectionStrategy.Default;
        }
        var ViewEncapsulation$1 = (() => {
            (function(ViewEncapsulation2) {
                ViewEncapsulation2[ViewEncapsulation2["Emulated"] = 0] = "Emulated";
                ViewEncapsulation2[ViewEncapsulation2["None"] = 2] = "None";
                ViewEncapsulation2[ViewEncapsulation2["ShadowDom"] = 3] = "ShadowDom";
            })(ViewEncapsulation$1 || (ViewEncapsulation$1 = {}));
            return ViewEncapsulation$1;
        })();
        const _global = (() => typeof globalThis !== "undefined" && globalThis || typeof global !== "undefined" && global || typeof window !== "undefined" && window || typeof self !== "undefined" && typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope && self)();
        function ngDevModeResetPerfCounters() {
            const locationString = typeof location !== "undefined" ? location.toString() : "";
            const newCounters = {
                namedConstructors: locationString.indexOf("ngDevMode=namedConstructors") != -1,
                firstCreatePass: 0,
                tNode: 0,
                tView: 0,
                rendererCreateTextNode: 0,
                rendererSetText: 0,
                rendererCreateElement: 0,
                rendererAddEventListener: 0,
                rendererSetAttribute: 0,
                rendererRemoveAttribute: 0,
                rendererSetProperty: 0,
                rendererSetClassName: 0,
                rendererAddClass: 0,
                rendererRemoveClass: 0,
                rendererSetStyle: 0,
                rendererRemoveStyle: 0,
                rendererDestroy: 0,
                rendererDestroyNode: 0,
                rendererMoveNode: 0,
                rendererRemoveNode: 0,
                rendererAppendChild: 0,
                rendererInsertBefore: 0,
                rendererCreateComment: 0
            };
            const allowNgDevModeTrue = locationString.indexOf("ngDevMode=false") === -1;
            _global["ngDevMode"] = allowNgDevModeTrue && newCounters;
            return newCounters;
        }
        function initNgDevMode() {
            if (false) {
                if (true) {
                    ngDevModeResetPerfCounters();
                }
                return false;
            }
            return false;
        }
        const EMPTY_OBJ = {};
        const EMPTY_ARRAY = [];
        if (false) {
            Object.freeze(EMPTY_OBJ);
            Object.freeze(EMPTY_ARRAY);
        }
        const NG_COMP_DEF = getClosureSafeProperty({
            cmp: getClosureSafeProperty
        });
        const NG_DIR_DEF = getClosureSafeProperty({
            dir: getClosureSafeProperty
        });
        const NG_PIPE_DEF = getClosureSafeProperty({
            pipe: getClosureSafeProperty
        });
        const NG_MOD_DEF = getClosureSafeProperty({
            mod: getClosureSafeProperty
        });
        const NG_FACTORY_DEF = getClosureSafeProperty({
            fac: getClosureSafeProperty
        });
        const NG_ELEMENT_ID = getClosureSafeProperty({
            __NG_ELEMENT_ID__: getClosureSafeProperty
        });
        let componentDefCount = 0;
        function defineComponent(componentDefinition) {
            return noSideEffects(() => {
                const type = componentDefinition.type;
                const standalone = componentDefinition.standalone === true;
                const declaredInputs = {};
                const def = {
                    type,
                    providersResolver: null,
                    decls: componentDefinition.decls,
                    vars: componentDefinition.vars,
                    factory: null,
                    template: componentDefinition.template || null,
                    consts: componentDefinition.consts || null,
                    ngContentSelectors: componentDefinition.ngContentSelectors,
                    hostBindings: componentDefinition.hostBindings || null,
                    hostVars: componentDefinition.hostVars || 0,
                    hostAttrs: componentDefinition.hostAttrs || null,
                    contentQueries: componentDefinition.contentQueries || null,
                    declaredInputs,
                    inputs: null,
                    outputs: null,
                    exportAs: componentDefinition.exportAs || null,
                    onPush: componentDefinition.changeDetection === ChangeDetectionStrategy.OnPush,
                    directiveDefs: null,
                    pipeDefs: null,
                    standalone,
                    dependencies: standalone && componentDefinition.dependencies || null,
                    getStandaloneInjector: null,
                    selectors: componentDefinition.selectors || EMPTY_ARRAY,
                    viewQuery: componentDefinition.viewQuery || null,
                    features: componentDefinition.features || null,
                    data: componentDefinition.data || {},
                    encapsulation: componentDefinition.encapsulation || ViewEncapsulation$1.Emulated,
                    id: `c${componentDefCount++}`,
                    styles: componentDefinition.styles || EMPTY_ARRAY,
                    _: null,
                    setInput: null,
                    schemas: componentDefinition.schemas || null,
                    tView: null
                };
                const dependencies = componentDefinition.dependencies;
                const feature = componentDefinition.features;
                def.inputs = invertObject(componentDefinition.inputs, declaredInputs), def.outputs = invertObject(componentDefinition.outputs), 
                feature && feature.forEach(fn => fn(def));
                def.directiveDefs = dependencies ? () => (typeof dependencies === "function" ? dependencies() : dependencies).map(extractDirectiveDef).filter(nonNull) : null;
                def.pipeDefs = dependencies ? () => (typeof dependencies === "function" ? dependencies() : dependencies).map(getPipeDef$1).filter(nonNull) : null;
                return def;
            });
        }
        function setComponentScope(type, directives, pipes) {
            const def = type.cmp;
            def.directiveDefs = () => (typeof directives === "function" ? directives() : directives).map(extractDirectiveDef);
            def.pipeDefs = () => (typeof pipes === "function" ? pipes() : pipes).map(getPipeDef$1);
        }
        function extractDirectiveDef(type) {
            return getComponentDef(type) || getDirectiveDef(type);
        }
        function nonNull(value) {
            return value !== null;
        }
        function defineNgModule(def) {
            return noSideEffects(() => {
                const res = {
                    type: def.type,
                    bootstrap: def.bootstrap || EMPTY_ARRAY,
                    declarations: def.declarations || EMPTY_ARRAY,
                    imports: def.imports || EMPTY_ARRAY,
                    exports: def.exports || EMPTY_ARRAY,
                    transitiveCompileScopes: null,
                    schemas: def.schemas || null,
                    id: def.id || null
                };
                return res;
            });
        }
        function setNgModuleScope(type, scope) {
            return noSideEffects(() => {
                const ngModuleDef = getNgModuleDef(type, true);
                ngModuleDef.declarations = scope.declarations || EMPTY_ARRAY;
                ngModuleDef.imports = scope.imports || EMPTY_ARRAY;
                ngModuleDef.exports = scope.exports || EMPTY_ARRAY;
            });
        }
        function invertObject(obj, secondary) {
            if (obj == null) {
                return EMPTY_OBJ;
            }
            const newLookup = {};
            for (const minifiedKey in obj) {
                if (obj.hasOwnProperty(minifiedKey)) {
                    let publicName = obj[minifiedKey];
                    let declaredName = publicName;
                    if (Array.isArray(publicName)) {
                        declaredName = publicName[1];
                        publicName = publicName[0];
                    }
                    newLookup[publicName] = minifiedKey;
                    if (secondary) {
                        secondary[publicName] = declaredName;
                    }
                }
            }
            return newLookup;
        }
        const defineDirective = defineComponent;
        function definePipe(pipeDef) {
            return {
                type: pipeDef.type,
                name: pipeDef.name,
                factory: null,
                pure: pipeDef.pure !== false,
                standalone: pipeDef.standalone === true,
                onDestroy: pipeDef.type.prototype.ngOnDestroy || null
            };
        }
        function getComponentDef(type) {
            return type[NG_COMP_DEF] || null;
        }
        function getDirectiveDef(type) {
            return type[NG_DIR_DEF] || null;
        }
        function getPipeDef$1(type) {
            return type[NG_PIPE_DEF] || null;
        }
        function isStandalone(type) {
            const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef$1(type);
            return def !== null ? def.standalone : false;
        }
        function getNgModuleDef(type, throwNotFound) {
            const ngModuleDef = type[NG_MOD_DEF] || null;
            if (!ngModuleDef && throwNotFound === true) {
                throw new Error(`Type ${stringify(type)} does not have 'mod' property.`);
            }
            return ngModuleDef;
        }
        const HOST = 0;
        const TVIEW = 1;
        const FLAGS = 2;
        const PARENT = 3;
        const NEXT = 4;
        const TRANSPLANTED_VIEWS_TO_REFRESH = 5;
        const T_HOST = 6;
        const CLEANUP = 7;
        const CONTEXT = 8;
        const INJECTOR$1 = 9;
        const RENDERER_FACTORY = 10;
        const RENDERER = 11;
        const SANITIZER = 12;
        const CHILD_HEAD = 13;
        const CHILD_TAIL = 14;
        const DECLARATION_VIEW = 15;
        const DECLARATION_COMPONENT_VIEW = 16;
        const DECLARATION_LCONTAINER = 17;
        const PREORDER_HOOK_FLAGS = 18;
        const QUERIES = 19;
        const ID = 20;
        const EMBEDDED_VIEW_INJECTOR = 21;
        const HEADER_OFFSET = 22;
        const TViewTypeAsString = [ "Root", "Component", "Embedded" ];
        const unusedValueExportToPlacateAjd$8 = 1;
        const TYPE = 1;
        const HAS_TRANSPLANTED_VIEWS = 2;
        const NATIVE = 7;
        const VIEW_REFS = 8;
        const MOVED_VIEWS = 9;
        const CONTAINER_HEADER_OFFSET = 10;
        const unusedValueExportToPlacateAjd$7 = 1;
        function isLView(value) {
            return Array.isArray(value) && typeof value[TYPE] === "object";
        }
        function isLContainer(value) {
            return Array.isArray(value) && value[TYPE] === true;
        }
        function isContentQueryHost(tNode) {
            return (tNode.flags & 8) !== 0;
        }
        function isComponentHost(tNode) {
            return (tNode.flags & 2) === 2;
        }
        function isDirectiveHost(tNode) {
            return (tNode.flags & 1) === 1;
        }
        function isComponentDef(def) {
            return def.template !== null;
        }
        function isRootView(target) {
            return (target[FLAGS] & 256) !== 0;
        }
        function assertTNodeForLView(tNode, lView) {
            assertTNodeForTView(tNode, lView[TVIEW]);
        }
        function assertTNodeForTView(tNode, tView) {
            assertTNode(tNode);
            tNode.hasOwnProperty("tView_") && assertEqual(tNode.tView_, tView, "This TNode does not belong to this TView.");
        }
        function assertTNode(tNode) {
            assertDefined(tNode, "TNode must be defined");
            if (!(tNode && typeof tNode === "object" && tNode.hasOwnProperty("directiveStylingLast"))) {
                throwError("Not of type TNode, got: " + tNode);
            }
        }
        function assertTIcu(tIcu) {
            assertDefined(tIcu, "Expected TIcu to be defined");
            if (!(typeof tIcu.currentCaseLViewIndex === "number")) {
                throwError("Object is not of TIcu type.");
            }
        }
        function assertComponentType(actual, msg = "Type passed in is not ComponentType, it does not have 'cmp' property.") {
            if (!getComponentDef(actual)) {
                throwError(msg);
            }
        }
        function assertNgModuleType(actual, msg = "Type passed in is not NgModuleType, it does not have 'mod' property.") {
            if (!getNgModuleDef(actual)) {
                throwError(msg);
            }
        }
        function assertCurrentTNodeIsParent(isParent) {
            assertEqual(isParent, true, "currentTNode should be a parent");
        }
        function assertHasParent(tNode) {
            assertDefined(tNode, "currentTNode should exist!");
            assertDefined(tNode.parent, "currentTNode should have a parent");
        }
        function assertDataNext(lView, index, arr) {
            if (arr == null) {
                arr = lView;
            }
            assertEqual(arr.length, index, `index ${index} expected to be at the end of arr (length ${arr.length})`);
        }
        function assertLContainer(value) {
            assertDefined(value, "LContainer must be defined");
            assertEqual(isLContainer(value), true, "Expecting LContainer");
        }
        function assertLViewOrUndefined(value) {
            value && assertEqual(isLView(value), true, "Expecting LView or undefined or null");
        }
        function assertLView(value) {
            assertDefined(value, "LView must be defined");
            assertEqual(isLView(value), true, "Expecting LView");
        }
        function assertFirstCreatePass(tView, errMessage) {
            assertEqual(tView.firstCreatePass, true, errMessage || "Should only be called in first create pass.");
        }
        function assertFirstUpdatePass(tView, errMessage) {
            assertEqual(tView.firstUpdatePass, true, errMessage || "Should only be called in first update pass.");
        }
        function assertDirectiveDef(obj) {
            if (obj.type === void 0 || obj.selectors == void 0 || obj.inputs === void 0) {
                throwError(`Expected a DirectiveDef/ComponentDef and this object does not seem to have the expected shape.`);
            }
        }
        function assertIndexInDeclRange(lView, index) {
            const tView = lView[1];
            assertBetween(HEADER_OFFSET, tView.bindingStartIndex, index);
        }
        function assertIndexInVarsRange(lView, index) {
            const tView = lView[1];
            assertBetween(tView.bindingStartIndex, tView.expandoStartIndex, index);
        }
        function assertIndexInExpandoRange(lView, index) {
            const tView = lView[1];
            assertBetween(tView.expandoStartIndex, lView.length, index);
        }
        function assertBetween(lower, upper, index) {
            if (!(lower <= index && index < upper)) {
                throwError(`Index out of range (expecting ${lower} <= ${index} < ${upper})`);
            }
        }
        function assertProjectionSlots(lView, errMessage) {
            assertDefined(lView[DECLARATION_COMPONENT_VIEW], "Component views should exist.");
            assertDefined(lView[DECLARATION_COMPONENT_VIEW][T_HOST].projection, errMessage || "Components with projection nodes (<ng-content>) must have projection slots defined.");
        }
        function assertParentView(lView, errMessage) {
            assertDefined(lView, errMessage || "Component views should always have a parent view (component's host view)");
        }
        function assertNodeInjector(lView, injectorIndex) {
            assertIndexInExpandoRange(lView, injectorIndex);
            assertIndexInExpandoRange(lView, injectorIndex + 8);
            assertNumber(lView[injectorIndex + 0], "injectorIndex should point to a bloom filter");
            assertNumber(lView[injectorIndex + 1], "injectorIndex should point to a bloom filter");
            assertNumber(lView[injectorIndex + 2], "injectorIndex should point to a bloom filter");
            assertNumber(lView[injectorIndex + 3], "injectorIndex should point to a bloom filter");
            assertNumber(lView[injectorIndex + 4], "injectorIndex should point to a bloom filter");
            assertNumber(lView[injectorIndex + 5], "injectorIndex should point to a bloom filter");
            assertNumber(lView[injectorIndex + 6], "injectorIndex should point to a bloom filter");
            assertNumber(lView[injectorIndex + 7], "injectorIndex should point to a bloom filter");
            assertNumber(lView[injectorIndex + 8], "injectorIndex should point to parent injector");
        }
        function getFactoryDef(type, throwNotFound) {
            const hasFactoryDef = type.hasOwnProperty(NG_FACTORY_DEF);
            if (!hasFactoryDef && throwNotFound === true && false) {
                throw new Error(`Type ${stringify(type)} does not have 'fac' property.`);
            }
            return hasFactoryDef ? type[NG_FACTORY_DEF] : null;
        }
        class SimpleChange {
            constructor(previousValue, currentValue, firstChange) {
                this.previousValue = previousValue;
                this.currentValue = currentValue;
                this.firstChange = firstChange;
            }
            isFirstChange() {
                return this.firstChange;
            }
        }
        function NgOnChangesFeature() {
            return NgOnChangesFeatureImpl;
        }
        function NgOnChangesFeatureImpl(definition) {
            if (definition.type.prototype.ngOnChanges) {
                definition.setInput = ngOnChangesSetInput;
            }
            return rememberChangeHistoryAndInvokeOnChangesHook;
        }
        NgOnChangesFeature.ngInherit = true;
        function rememberChangeHistoryAndInvokeOnChangesHook() {
            const simpleChangesStore = getSimpleChangesStore(this);
            const current = simpleChangesStore?.current;
            if (current) {
                const previous = simpleChangesStore.previous;
                if (previous === EMPTY_OBJ) {
                    simpleChangesStore.previous = current;
                } else {
                    for (let key in current) {
                        previous[key] = current[key];
                    }
                }
                simpleChangesStore.current = null;
                this.ngOnChanges(current);
            }
        }
        function ngOnChangesSetInput(instance, value, publicName, privateName) {
            const simpleChangesStore = getSimpleChangesStore(instance) || setSimpleChangesStore(instance, {
                previous: EMPTY_OBJ,
                current: null
            });
            const current = simpleChangesStore.current || (simpleChangesStore.current = {});
            const previous = simpleChangesStore.previous;
            const declaredName = this.declaredInputs[publicName];
            const previousChange = previous[declaredName];
            current[declaredName] = new SimpleChange(previousChange && previousChange.currentValue, value, previous === EMPTY_OBJ);
            instance[privateName] = value;
        }
        const SIMPLE_CHANGES_STORE = "__ngSimpleChanges__";
        function getSimpleChangesStore(instance) {
            return instance[SIMPLE_CHANGES_STORE] || null;
        }
        function setSimpleChangesStore(instance, store2) {
            return instance[SIMPLE_CHANGES_STORE] = store2;
        }
        let profilerCallback = null;
        const setProfiler = profiler2 => {
            profilerCallback = profiler2;
        };
        const profiler = function(event, instance, hookOrListener) {
            if (profilerCallback != null) {
                profilerCallback(event, instance, hookOrListener);
            }
        };
        const SVG_NAMESPACE = "svg";
        const SVG_NAMESPACE_URI = "http://www.w3.org/2000/svg";
        const MATH_ML_NAMESPACE = "math";
        const MATH_ML_NAMESPACE_URI = "http://www.w3.org/1998/MathML/";
        function getNamespaceUri(namespace) {
            const name = namespace.toLowerCase();
            return name === SVG_NAMESPACE ? SVG_NAMESPACE_URI : name === MATH_ML_NAMESPACE ? MATH_ML_NAMESPACE_URI : null;
        }
        function unwrapRNode(value) {
            while (Array.isArray(value)) {
                value = value[HOST];
            }
            return value;
        }
        function unwrapLView(value) {
            while (Array.isArray(value)) {
                if (typeof value[TYPE] === "object") {
                    return value;
                }
                value = value[HOST];
            }
            return null;
        }
        function unwrapLContainer(value) {
            while (Array.isArray(value)) {
                if (value[TYPE] === true) {
                    return value;
                }
                value = value[HOST];
            }
            return null;
        }
        function getNativeByIndex(index, lView) {
            return unwrapRNode(lView[index]);
        }
        function getNativeByTNode(tNode, lView) {
            const node = unwrapRNode(lView[tNode.index]);
            return node;
        }
        function getNativeByTNodeOrNull(tNode, lView) {
            const index = tNode === null ? -1 : tNode.index;
            if (index !== -1) {
                const node = unwrapRNode(lView[index]);
                return node;
            }
            return null;
        }
        function getTNode(tView, index) {
            const tNode = tView.data[index];
            return tNode;
        }
        function load(view, index) {
            return view[index];
        }
        function getComponentLViewByIndex(nodeIndex, hostView) {
            const slotValue = hostView[nodeIndex];
            const lView = isLView(slotValue) ? slotValue : slotValue[HOST];
            return lView;
        }
        function isCreationMode(view) {
            return (view[FLAGS] & 4) === 4;
        }
        function viewAttachedToChangeDetector(view) {
            return (view[FLAGS] & 64) === 64;
        }
        function viewAttachedToContainer(view) {
            return isLContainer(view[PARENT]);
        }
        function getConstant(consts, index) {
            if (index === null || index === void 0) {
                return null;
            }
            return consts[index];
        }
        function resetPreOrderHookFlags(lView) {
            lView[PREORDER_HOOK_FLAGS] = 0;
        }
        function updateTransplantedViewCount(lContainer, amount) {
            lContainer[TRANSPLANTED_VIEWS_TO_REFRESH] += amount;
            let viewOrContainer = lContainer;
            let parent = lContainer[PARENT];
            while (parent !== null && (amount === 1 && viewOrContainer[TRANSPLANTED_VIEWS_TO_REFRESH] === 1 || amount === -1 && viewOrContainer[TRANSPLANTED_VIEWS_TO_REFRESH] === 0)) {
                parent[TRANSPLANTED_VIEWS_TO_REFRESH] += amount;
                viewOrContainer = parent;
                parent = parent[PARENT];
            }
        }
        const instructionState = {
            lFrame: createLFrame(null),
            bindingsEnabled: true
        };
        let _isInCheckNoChangesMode = false;
        function specOnlyIsInstructionStateEmpty() {
            return instructionState.lFrame.parent === null;
        }
        function getElementDepthCount() {
            return instructionState.lFrame.elementDepthCount;
        }
        function increaseElementDepthCount() {
            instructionState.lFrame.elementDepthCount++;
        }
        function decreaseElementDepthCount() {
            instructionState.lFrame.elementDepthCount--;
        }
        function getBindingsEnabled() {
            return instructionState.bindingsEnabled;
        }
        function enableBindings() {
            instructionState.bindingsEnabled = true;
        }
        function disableBindings() {
            instructionState.bindingsEnabled = false;
        }
        function getLView() {
            return instructionState.lFrame.lView;
        }
        function getTView() {
            return instructionState.lFrame.tView;
        }
        function restoreView(viewToRestore) {
            instructionState.lFrame.contextLView = viewToRestore;
            return viewToRestore[CONTEXT];
        }
        function resetView(value) {
            instructionState.lFrame.contextLView = null;
            return value;
        }
        function getCurrentTNode() {
            let currentTNode = getCurrentTNodePlaceholderOk();
            while (currentTNode !== null && currentTNode.type === 64) {
                currentTNode = currentTNode.parent;
            }
            return currentTNode;
        }
        function getCurrentTNodePlaceholderOk() {
            return instructionState.lFrame.currentTNode;
        }
        function getCurrentParentTNode() {
            const lFrame = instructionState.lFrame;
            const currentTNode = lFrame.currentTNode;
            return lFrame.isParent ? currentTNode : currentTNode.parent;
        }
        function setCurrentTNode(tNode, isParent) {
            const lFrame = instructionState.lFrame;
            lFrame.currentTNode = tNode;
            lFrame.isParent = isParent;
        }
        function isCurrentTNodeParent() {
            return instructionState.lFrame.isParent;
        }
        function setCurrentTNodeAsNotParent() {
            instructionState.lFrame.isParent = false;
        }
        function setCurrentTNodeAsParent() {
            instructionState.lFrame.isParent = true;
        }
        function getContextLView() {
            const contextLView = instructionState.lFrame.contextLView;
            return contextLView;
        }
        function isInCheckNoChangesMode() {
            throwError("Must never be called in production mode");
            return _isInCheckNoChangesMode;
        }
        function setIsInCheckNoChangesMode(mode) {
            throwError("Must never be called in production mode");
            _isInCheckNoChangesMode = mode;
        }
        function getBindingRoot() {
            const lFrame = instructionState.lFrame;
            let index = lFrame.bindingRootIndex;
            if (index === -1) {
                index = lFrame.bindingRootIndex = lFrame.tView.bindingStartIndex;
            }
            return index;
        }
        function getBindingIndex() {
            return instructionState.lFrame.bindingIndex;
        }
        function setBindingIndex(value) {
            return instructionState.lFrame.bindingIndex = value;
        }
        function nextBindingIndex() {
            return instructionState.lFrame.bindingIndex++;
        }
        function incrementBindingIndex(count) {
            const lFrame = instructionState.lFrame;
            const index = lFrame.bindingIndex;
            lFrame.bindingIndex = lFrame.bindingIndex + count;
            return index;
        }
        function isInI18nBlock() {
            return instructionState.lFrame.inI18n;
        }
        function setInI18nBlock(isInI18nBlock2) {
            instructionState.lFrame.inI18n = isInI18nBlock2;
        }
        function setBindingRootForHostBindings(bindingRootIndex, currentDirectiveIndex) {
            const lFrame = instructionState.lFrame;
            lFrame.bindingIndex = lFrame.bindingRootIndex = bindingRootIndex;
            setCurrentDirectiveIndex(currentDirectiveIndex);
        }
        function getCurrentDirectiveIndex() {
            return instructionState.lFrame.currentDirectiveIndex;
        }
        function setCurrentDirectiveIndex(currentDirectiveIndex) {
            instructionState.lFrame.currentDirectiveIndex = currentDirectiveIndex;
        }
        function getCurrentDirectiveDef(tData) {
            const currentDirectiveIndex = instructionState.lFrame.currentDirectiveIndex;
            return currentDirectiveIndex === -1 ? null : tData[currentDirectiveIndex];
        }
        function getCurrentQueryIndex() {
            return instructionState.lFrame.currentQueryIndex;
        }
        function setCurrentQueryIndex(value) {
            instructionState.lFrame.currentQueryIndex = value;
        }
        function getDeclarationTNode(lView) {
            const tView = lView[TVIEW];
            if (tView.type === 2) {
                return tView.declTNode;
            }
            if (tView.type === 1) {
                return lView[T_HOST];
            }
            return null;
        }
        function enterDI(lView, tNode, flags) {
            if (flags & InjectFlags.SkipSelf) {
                let parentTNode = tNode;
                let parentLView = lView;
                while (true) {
                    parentTNode = parentTNode.parent;
                    if (parentTNode === null && !(flags & InjectFlags.Host)) {
                        parentTNode = getDeclarationTNode(parentLView);
                        if (parentTNode === null) {
                            break;
                        }
                        parentLView = parentLView[DECLARATION_VIEW];
                        if (parentTNode.type & (2 | 8)) {
                            break;
                        }
                    } else {
                        break;
                    }
                }
                if (parentTNode === null) {
                    return false;
                } else {
                    tNode = parentTNode;
                    lView = parentLView;
                }
            }
            const lFrame = instructionState.lFrame = allocLFrame();
            lFrame.currentTNode = tNode;
            lFrame.lView = lView;
            return true;
        }
        function enterView(newView) {
            const newLFrame = allocLFrame();
            if (false) {
                assertEqual(newLFrame.isParent, true, "Expected clean LFrame");
                assertEqual(newLFrame.lView, null, "Expected clean LFrame");
                assertEqual(newLFrame.tView, null, "Expected clean LFrame");
                assertEqual(newLFrame.selectedIndex, -1, "Expected clean LFrame");
                assertEqual(newLFrame.elementDepthCount, 0, "Expected clean LFrame");
                assertEqual(newLFrame.currentDirectiveIndex, -1, "Expected clean LFrame");
                assertEqual(newLFrame.currentNamespace, null, "Expected clean LFrame");
                assertEqual(newLFrame.bindingRootIndex, -1, "Expected clean LFrame");
                assertEqual(newLFrame.currentQueryIndex, 0, "Expected clean LFrame");
            }
            const tView = newView[TVIEW];
            instructionState.lFrame = newLFrame;
            newLFrame.currentTNode = tView.firstChild;
            newLFrame.lView = newView;
            newLFrame.tView = tView;
            newLFrame.contextLView = newView;
            newLFrame.bindingIndex = tView.bindingStartIndex;
            newLFrame.inI18n = false;
        }
        function allocLFrame() {
            const currentLFrame = instructionState.lFrame;
            const childLFrame = currentLFrame === null ? null : currentLFrame.child;
            const newLFrame = childLFrame === null ? createLFrame(currentLFrame) : childLFrame;
            return newLFrame;
        }
        function createLFrame(parent) {
            const lFrame = {
                currentTNode: null,
                isParent: true,
                lView: null,
                tView: null,
                selectedIndex: -1,
                contextLView: null,
                elementDepthCount: 0,
                currentNamespace: null,
                currentDirectiveIndex: -1,
                bindingRootIndex: -1,
                bindingIndex: -1,
                currentQueryIndex: 0,
                parent,
                child: null,
                inI18n: false
            };
            parent !== null && (parent.child = lFrame);
            return lFrame;
        }
        function leaveViewLight() {
            const oldLFrame = instructionState.lFrame;
            instructionState.lFrame = oldLFrame.parent;
            oldLFrame.currentTNode = null;
            oldLFrame.lView = null;
            return oldLFrame;
        }
        const leaveDI = leaveViewLight;
        function leaveView() {
            const oldLFrame = leaveViewLight();
            oldLFrame.isParent = true;
            oldLFrame.tView = null;
            oldLFrame.selectedIndex = -1;
            oldLFrame.contextLView = null;
            oldLFrame.elementDepthCount = 0;
            oldLFrame.currentDirectiveIndex = -1;
            oldLFrame.currentNamespace = null;
            oldLFrame.bindingRootIndex = -1;
            oldLFrame.bindingIndex = -1;
            oldLFrame.currentQueryIndex = 0;
        }
        function nextContextImpl(level) {
            const contextLView = instructionState.lFrame.contextLView = walkUpViews(level, instructionState.lFrame.contextLView);
            return contextLView[CONTEXT];
        }
        function walkUpViews(nestingLevel, currentView) {
            while (nestingLevel > 0) {
                currentView = currentView[DECLARATION_VIEW];
                nestingLevel--;
            }
            return currentView;
        }
        function getSelectedIndex() {
            return instructionState.lFrame.selectedIndex;
        }
        function setSelectedIndex(index) {
            instructionState.lFrame.selectedIndex = index;
        }
        function getSelectedTNode() {
            const lFrame = instructionState.lFrame;
            return getTNode(lFrame.tView, lFrame.selectedIndex);
        }
        function namespaceSVG() {
            instructionState.lFrame.currentNamespace = SVG_NAMESPACE;
        }
        function namespaceMathML() {
            instructionState.lFrame.currentNamespace = MATH_ML_NAMESPACE;
        }
        function namespaceHTML() {
            namespaceHTMLInternal();
        }
        function namespaceHTMLInternal() {
            instructionState.lFrame.currentNamespace = null;
        }
        function getNamespace$1() {
            return instructionState.lFrame.currentNamespace;
        }
        function registerPreOrderHooks(directiveIndex, directiveDef, tView) {
            const {ngOnChanges, ngOnInit, ngDoCheck} = directiveDef.type.prototype;
            if (ngOnChanges) {
                const wrappedOnChanges = NgOnChangesFeatureImpl(directiveDef);
                (tView.preOrderHooks || (tView.preOrderHooks = [])).push(directiveIndex, wrappedOnChanges);
                (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [])).push(directiveIndex, wrappedOnChanges);
            }
            if (ngOnInit) {
                (tView.preOrderHooks || (tView.preOrderHooks = [])).push(0 - directiveIndex, ngOnInit);
            }
            if (ngDoCheck) {
                (tView.preOrderHooks || (tView.preOrderHooks = [])).push(directiveIndex, ngDoCheck);
                (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [])).push(directiveIndex, ngDoCheck);
            }
        }
        function registerPostOrderHooks(tView, tNode) {
            for (let i = tNode.directiveStart, end = tNode.directiveEnd; i < end; i++) {
                const directiveDef = tView.data[i];
                const lifecycleHooks = directiveDef.type.prototype;
                const {ngAfterContentInit, ngAfterContentChecked, ngAfterViewInit, ngAfterViewChecked, ngOnDestroy} = lifecycleHooks;
                if (ngAfterContentInit) {
                    (tView.contentHooks || (tView.contentHooks = [])).push(-i, ngAfterContentInit);
                }
                if (ngAfterContentChecked) {
                    (tView.contentHooks || (tView.contentHooks = [])).push(i, ngAfterContentChecked);
                    (tView.contentCheckHooks || (tView.contentCheckHooks = [])).push(i, ngAfterContentChecked);
                }
                if (ngAfterViewInit) {
                    (tView.viewHooks || (tView.viewHooks = [])).push(-i, ngAfterViewInit);
                }
                if (ngAfterViewChecked) {
                    (tView.viewHooks || (tView.viewHooks = [])).push(i, ngAfterViewChecked);
                    (tView.viewCheckHooks || (tView.viewCheckHooks = [])).push(i, ngAfterViewChecked);
                }
                if (ngOnDestroy != null) {
                    (tView.destroyHooks || (tView.destroyHooks = [])).push(i, ngOnDestroy);
                }
            }
        }
        function executeCheckHooks(lView, hooks, nodeIndex) {
            callHooks(lView, hooks, 3, nodeIndex);
        }
        function executeInitAndCheckHooks(lView, hooks, initPhase, nodeIndex) {
            if ((lView[FLAGS] & 3) === initPhase) {
                callHooks(lView, hooks, initPhase, nodeIndex);
            }
        }
        function incrementInitPhaseFlags(lView, initPhase) {
            let flags = lView[FLAGS];
            if ((flags & 3) === initPhase) {
                flags &= 2047;
                flags += 1;
                lView[FLAGS] = flags;
            }
        }
        function callHooks(currentView, arr, initPhase, currentNodeIndex) {
            const startIndex = currentNodeIndex !== void 0 ? currentView[PREORDER_HOOK_FLAGS] & 65535 : 0;
            const nodeIndexLimit = currentNodeIndex != null ? currentNodeIndex : -1;
            const max = arr.length - 1;
            let lastNodeIndexFound = 0;
            for (let i = startIndex; i < max; i++) {
                const hook = arr[i + 1];
                if (typeof hook === "number") {
                    lastNodeIndexFound = arr[i];
                    if (currentNodeIndex != null && lastNodeIndexFound >= currentNodeIndex) {
                        break;
                    }
                } else {
                    const isInitHook = arr[i] < 0;
                    if (isInitHook) {
                        currentView[PREORDER_HOOK_FLAGS] += 65536;
                    }
                    if (lastNodeIndexFound < nodeIndexLimit || nodeIndexLimit == -1) {
                        callHook(currentView, initPhase, arr, i);
                        currentView[PREORDER_HOOK_FLAGS] = (currentView[PREORDER_HOOK_FLAGS] & 4294901760) + i + 2;
                    }
                    i++;
                }
            }
        }
        function callHook(currentView, initPhase, arr, i) {
            const isInitHook = arr[i] < 0;
            const hook = arr[i + 1];
            const directiveIndex = isInitHook ? -arr[i] : arr[i];
            const directive = currentView[directiveIndex];
            if (isInitHook) {
                const indexWithintInitPhase = currentView[FLAGS] >> 11;
                if (indexWithintInitPhase < currentView[PREORDER_HOOK_FLAGS] >> 16 && (currentView[FLAGS] & 3) === initPhase) {
                    currentView[FLAGS] += 2048;
                    profiler(4, directive, hook);
                    try {
                        hook.call(directive);
                    } finally {
                        profiler(5, directive, hook);
                    }
                }
            } else {
                profiler(4, directive, hook);
                try {
                    hook.call(directive);
                } finally {
                    profiler(5, directive, hook);
                }
            }
        }
        const NO_PARENT_INJECTOR = -1;
        class NodeInjectorFactory {
            constructor(factory, isViewProvider, injectImplementation) {
                this.factory = factory;
                this.resolving = false;
                this.canSeeViewProviders = isViewProvider;
                this.injectImpl = injectImplementation;
            }
        }
        function isFactory(obj) {
            return obj instanceof NodeInjectorFactory;
        }
        const unusedValueExportToPlacateAjd$6 = 1;
        function toTNodeTypeAsString(tNodeType) {
            let text = "";
            tNodeType & 1 && (text += "|Text");
            tNodeType & 2 && (text += "|Element");
            tNodeType & 4 && (text += "|Container");
            tNodeType & 8 && (text += "|ElementContainer");
            tNodeType & 16 && (text += "|Projection");
            tNodeType & 32 && (text += "|IcuContainer");
            tNodeType & 64 && (text += "|Placeholder");
            return text.length > 0 ? text.substring(1) : text;
        }
        const unusedValueExportToPlacateAjd$5 = 1;
        function hasClassInput(tNode) {
            return (tNode.flags & 16) !== 0;
        }
        function hasStyleInput(tNode) {
            return (tNode.flags & 32) !== 0;
        }
        function assertTNodeType(tNode, expectedTypes, message) {
            assertDefined(tNode, "should be called with a TNode");
            if ((tNode.type & expectedTypes) === 0) {
                throwError(message || `Expected [${toTNodeTypeAsString(expectedTypes)}] but got ${toTNodeTypeAsString(tNode.type)}.`);
            }
        }
        function assertPureTNodeType(type) {
            if (!(type === 2 || type === 1 || type === 4 || type === 8 || type === 32 || type === 16 || type === 64)) {
                throwError(`Expected TNodeType to have only a single type selected, but got ${toTNodeTypeAsString(type)}.`);
            }
        }
        function setUpAttributes(renderer, native, attrs) {
            let i = 0;
            while (i < attrs.length) {
                const value = attrs[i];
                if (typeof value === "number") {
                    if (value !== 0) {
                        break;
                    }
                    i++;
                    const namespaceURI = attrs[i++];
                    const attrName = attrs[i++];
                    const attrVal = attrs[i++];
                    renderer.setAttribute(native, attrName, attrVal, namespaceURI);
                } else {
                    const attrName = value;
                    const attrVal = attrs[++i];
                    if (isAnimationProp(attrName)) {
                        renderer.setProperty(native, attrName, attrVal);
                    } else {
                        renderer.setAttribute(native, attrName, attrVal);
                    }
                    i++;
                }
            }
            return i;
        }
        function isNameOnlyAttributeMarker(marker) {
            return marker === 3 || marker === 4 || marker === 6;
        }
        function isAnimationProp(name) {
            return name.charCodeAt(0) === 64;
        }
        function mergeHostAttrs(dst, src) {
            if (src === null || src.length === 0) {} else if (dst === null || dst.length === 0) {
                dst = src.slice();
            } else {
                let srcMarker = -1;
                for (let i = 0; i < src.length; i++) {
                    const item = src[i];
                    if (typeof item === "number") {
                        srcMarker = item;
                    } else {
                        if (srcMarker === 0) {} else if (srcMarker === -1 || srcMarker === 2) {
                            mergeHostAttribute(dst, srcMarker, item, null, src[++i]);
                        } else {
                            mergeHostAttribute(dst, srcMarker, item, null, null);
                        }
                    }
                }
            }
            return dst;
        }
        function mergeHostAttribute(dst, marker, key1, key2, value) {
            let i = 0;
            let markerInsertPosition = dst.length;
            if (marker === -1) {
                markerInsertPosition = -1;
            } else {
                while (i < dst.length) {
                    const dstValue = dst[i++];
                    if (typeof dstValue === "number") {
                        if (dstValue === marker) {
                            markerInsertPosition = -1;
                            break;
                        } else if (dstValue > marker) {
                            markerInsertPosition = i - 1;
                            break;
                        }
                    }
                }
            }
            while (i < dst.length) {
                const item = dst[i];
                if (typeof item === "number") {
                    break;
                } else if (item === key1) {
                    if (key2 === null) {
                        if (value !== null) {
                            dst[i + 1] = value;
                        }
                        return;
                    } else if (key2 === dst[i + 1]) {
                        dst[i + 2] = value;
                        return;
                    }
                }
                i++;
                if (key2 !== null) {
                    i++;
                }
                if (value !== null) {
                    i++;
                }
            }
            if (markerInsertPosition !== -1) {
                dst.splice(markerInsertPosition, 0, marker);
                i = markerInsertPosition + 1;
            }
            dst.splice(i++, 0, key1);
            if (key2 !== null) {
                dst.splice(i++, 0, key2);
            }
            if (value !== null) {
                dst.splice(i++, 0, value);
            }
        }
        function hasParentInjector(parentLocation) {
            return parentLocation !== NO_PARENT_INJECTOR;
        }
        function getParentInjectorIndex(parentLocation) {
            const parentInjectorIndex = parentLocation & 32767;
            return parentLocation & 32767;
        }
        function getParentInjectorViewOffset(parentLocation) {
            return parentLocation >> 16;
        }
        function getParentInjectorView(location2, startView) {
            let viewOffset = getParentInjectorViewOffset(location2);
            let parentView = startView;
            while (viewOffset > 0) {
                parentView = parentView[DECLARATION_VIEW];
                viewOffset--;
            }
            return parentView;
        }
        let includeViewProviders = true;
        function setIncludeViewProviders(v) {
            const oldValue = includeViewProviders;
            includeViewProviders = v;
            return oldValue;
        }
        const BLOOM_SIZE = 256;
        const BLOOM_MASK = BLOOM_SIZE - 1;
        const BLOOM_BUCKET_BITS = 5;
        let nextNgElementId = 0;
        const NOT_FOUND = {};
        function bloomAdd(injectorIndex, tView, type) {
            let id;
            if (typeof type === "string") {
                id = type.charCodeAt(0) || 0;
            } else if (type.hasOwnProperty(NG_ELEMENT_ID)) {
                id = type[NG_ELEMENT_ID];
            }
            if (id == null) {
                id = type[NG_ELEMENT_ID] = nextNgElementId++;
            }
            const bloomHash = id & BLOOM_MASK;
            const mask = 1 << bloomHash;
            tView.data[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)] |= mask;
        }
        function getOrCreateNodeInjectorForNode(tNode, lView) {
            const existingInjectorIndex = getInjectorIndex(tNode, lView);
            if (existingInjectorIndex !== -1) {
                return existingInjectorIndex;
            }
            const tView = lView[TVIEW];
            if (tView.firstCreatePass) {
                tNode.injectorIndex = lView.length;
                insertBloom(tView.data, tNode);
                insertBloom(lView, null);
                insertBloom(tView.blueprint, null);
            }
            const parentLoc = getParentInjectorLocation(tNode, lView);
            const injectorIndex = tNode.injectorIndex;
            if (hasParentInjector(parentLoc)) {
                const parentIndex = getParentInjectorIndex(parentLoc);
                const parentLView = getParentInjectorView(parentLoc, lView);
                const parentData = parentLView[TVIEW].data;
                for (let i = 0; i < 8; i++) {
                    lView[injectorIndex + i] = parentLView[parentIndex + i] | parentData[parentIndex + i];
                }
            }
            lView[injectorIndex + 8] = parentLoc;
            return injectorIndex;
        }
        function insertBloom(arr, footer) {
            arr.push(0, 0, 0, 0, 0, 0, 0, 0, footer);
        }
        function getInjectorIndex(tNode, lView) {
            if (tNode.injectorIndex === -1 || tNode.parent && tNode.parent.injectorIndex === tNode.injectorIndex || lView[tNode.injectorIndex + 8] === null) {
                return -1;
            } else {
                return tNode.injectorIndex;
            }
        }
        function getParentInjectorLocation(tNode, lView) {
            if (tNode.parent && tNode.parent.injectorIndex !== -1) {
                return tNode.parent.injectorIndex;
            }
            let declarationViewOffset = 0;
            let parentTNode = null;
            let lViewCursor = lView;
            while (lViewCursor !== null) {
                parentTNode = getTNodeFromLView(lViewCursor);
                if (parentTNode === null) {
                    return NO_PARENT_INJECTOR;
                }
                declarationViewOffset++;
                lViewCursor = lViewCursor[DECLARATION_VIEW];
                if (parentTNode.injectorIndex !== -1) {
                    return parentTNode.injectorIndex | declarationViewOffset << 16;
                }
            }
            return NO_PARENT_INJECTOR;
        }
        function diPublicInInjector(injectorIndex, tView, token) {
            bloomAdd(injectorIndex, tView, token);
        }
        function injectAttributeImpl(tNode, attrNameToInject) {
            if (attrNameToInject === "class") {
                return tNode.classes;
            }
            if (attrNameToInject === "style") {
                return tNode.styles;
            }
            const attrs = tNode.attrs;
            if (attrs) {
                const attrsLength = attrs.length;
                let i = 0;
                while (i < attrsLength) {
                    const value = attrs[i];
                    if (isNameOnlyAttributeMarker(value)) {
                        break;
                    }
                    if (value === 0) {
                        i = i + 2;
                    } else if (typeof value === "number") {
                        i++;
                        while (i < attrsLength && typeof attrs[i] === "string") {
                            i++;
                        }
                    } else if (value === attrNameToInject) {
                        return attrs[i + 1];
                    } else {
                        i = i + 2;
                    }
                }
            }
            return null;
        }
        function notFoundValueOrThrow(notFoundValue, token, flags) {
            if (flags & InjectFlags.Optional || notFoundValue !== void 0) {
                return notFoundValue;
            } else {
                throwProviderNotFoundError(token, "NodeInjector");
            }
        }
        function lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue) {
            if (flags & InjectFlags.Optional && notFoundValue === void 0) {
                notFoundValue = null;
            }
            if ((flags & (InjectFlags.Self | InjectFlags.Host)) === 0) {
                const moduleInjector = lView[INJECTOR$1];
                const previousInjectImplementation = setInjectImplementation(void 0);
                try {
                    if (moduleInjector) {
                        return moduleInjector.get(token, notFoundValue, flags & InjectFlags.Optional);
                    } else {
                        return injectRootLimpMode(token, notFoundValue, flags & InjectFlags.Optional);
                    }
                } finally {
                    setInjectImplementation(previousInjectImplementation);
                }
            }
            return notFoundValueOrThrow(notFoundValue, token, flags);
        }
        function getOrCreateInjectable(tNode, lView, token, flags = InjectFlags.Default, notFoundValue) {
            if (tNode !== null) {
                if (lView[FLAGS] & 1024) {
                    const embeddedInjectorValue = lookupTokenUsingEmbeddedInjector(tNode, lView, token, flags, NOT_FOUND);
                    if (embeddedInjectorValue !== NOT_FOUND) {
                        return embeddedInjectorValue;
                    }
                }
                const value = lookupTokenUsingNodeInjector(tNode, lView, token, flags, NOT_FOUND);
                if (value !== NOT_FOUND) {
                    return value;
                }
            }
            return lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);
        }
        function lookupTokenUsingNodeInjector(tNode, lView, token, flags, notFoundValue) {
            const bloomHash = bloomHashBitOrFactory(token);
            if (typeof bloomHash === "function") {
                if (!enterDI(lView, tNode, flags)) {
                    return flags & InjectFlags.Host ? notFoundValueOrThrow(notFoundValue, token, flags) : lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);
                }
                try {
                    const value = bloomHash(flags);
                    if (value == null && !(flags & InjectFlags.Optional)) {
                        throwProviderNotFoundError(token);
                    } else {
                        return value;
                    }
                } finally {
                    leaveDI();
                }
            } else if (typeof bloomHash === "number") {
                let previousTView = null;
                let injectorIndex = getInjectorIndex(tNode, lView);
                let parentLocation = NO_PARENT_INJECTOR;
                let hostTElementNode = flags & InjectFlags.Host ? lView[DECLARATION_COMPONENT_VIEW][T_HOST] : null;
                if (injectorIndex === -1 || flags & InjectFlags.SkipSelf) {
                    parentLocation = injectorIndex === -1 ? getParentInjectorLocation(tNode, lView) : lView[injectorIndex + 8];
                    if (parentLocation === NO_PARENT_INJECTOR || !shouldSearchParent(flags, false)) {
                        injectorIndex = -1;
                    } else {
                        previousTView = lView[TVIEW];
                        injectorIndex = getParentInjectorIndex(parentLocation);
                        lView = getParentInjectorView(parentLocation, lView);
                    }
                }
                while (injectorIndex !== -1) {
                    const tView = lView[TVIEW];
                    if (bloomHasToken(bloomHash, injectorIndex, tView.data)) {
                        const instance = searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode);
                        if (instance !== NOT_FOUND) {
                            return instance;
                        }
                    }
                    parentLocation = lView[injectorIndex + 8];
                    if (parentLocation !== NO_PARENT_INJECTOR && shouldSearchParent(flags, lView[TVIEW].data[injectorIndex + 8] === hostTElementNode) && bloomHasToken(bloomHash, injectorIndex, lView)) {
                        previousTView = tView;
                        injectorIndex = getParentInjectorIndex(parentLocation);
                        lView = getParentInjectorView(parentLocation, lView);
                    } else {
                        injectorIndex = -1;
                    }
                }
            }
            return notFoundValue;
        }
        function searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode) {
            const currentTView = lView[TVIEW];
            const tNode = currentTView.data[injectorIndex + 8];
            const canAccessViewProviders = previousTView == null ? isComponentHost(tNode) && includeViewProviders : previousTView != currentTView && (tNode.type & 3) !== 0;
            const isHostSpecialCase = flags & InjectFlags.Host && hostTElementNode === tNode;
            const injectableIdx = locateDirectiveOrProvider(tNode, currentTView, token, canAccessViewProviders, isHostSpecialCase);
            if (injectableIdx !== null) {
                return getNodeInjectable(lView, currentTView, injectableIdx, tNode);
            } else {
                return NOT_FOUND;
            }
        }
        function locateDirectiveOrProvider(tNode, tView, token, canAccessViewProviders, isHostSpecialCase) {
            const nodeProviderIndexes = tNode.providerIndexes;
            const tInjectables = tView.data;
            const injectablesStart = nodeProviderIndexes & 1048575;
            const directivesStart = tNode.directiveStart;
            const directiveEnd = tNode.directiveEnd;
            const cptViewProvidersCount = nodeProviderIndexes >> 20;
            const startingIndex = canAccessViewProviders ? injectablesStart : injectablesStart + cptViewProvidersCount;
            const endIndex = isHostSpecialCase ? injectablesStart + cptViewProvidersCount : directiveEnd;
            for (let i = startingIndex; i < endIndex; i++) {
                const providerTokenOrDef = tInjectables[i];
                if (i < directivesStart && token === providerTokenOrDef || i >= directivesStart && providerTokenOrDef.type === token) {
                    return i;
                }
            }
            if (isHostSpecialCase) {
                const dirDef = tInjectables[directivesStart];
                if (dirDef && isComponentDef(dirDef) && dirDef.type === token) {
                    return directivesStart;
                }
            }
            return null;
        }
        function getNodeInjectable(lView, tView, index, tNode) {
            let value = lView[index];
            const tData = tView.data;
            if (isFactory(value)) {
                const factory = value;
                if (factory.resolving) {
                    throwCyclicDependencyError(stringifyForError(tData[index]));
                }
                const previousIncludeViewProviders = setIncludeViewProviders(factory.canSeeViewProviders);
                factory.resolving = true;
                const previousInjectImplementation = factory.injectImpl ? setInjectImplementation(factory.injectImpl) : null;
                const success = enterDI(lView, tNode, InjectFlags.Default);
                try {
                    value = lView[index] = factory.factory(void 0, tData, lView, tNode);
                    if (tView.firstCreatePass && index >= tNode.directiveStart) {
                        registerPreOrderHooks(index, tData[index], tView);
                    }
                } finally {
                    previousInjectImplementation !== null && setInjectImplementation(previousInjectImplementation);
                    setIncludeViewProviders(previousIncludeViewProviders);
                    factory.resolving = false;
                    leaveDI();
                }
            }
            return value;
        }
        function bloomHashBitOrFactory(token) {
            if (typeof token === "string") {
                return token.charCodeAt(0) || 0;
            }
            const tokenId = token.hasOwnProperty(NG_ELEMENT_ID) ? token[NG_ELEMENT_ID] : void 0;
            if (typeof tokenId === "number") {
                if (tokenId >= 0) {
                    return tokenId & BLOOM_MASK;
                } else {
                    return createNodeInjector;
                }
            } else {
                return tokenId;
            }
        }
        function bloomHasToken(bloomHash, injectorIndex, injectorView) {
            const mask = 1 << bloomHash;
            const value = injectorView[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)];
            return !!(value & mask);
        }
        function shouldSearchParent(flags, isFirstHostTNode) {
            return !(flags & InjectFlags.Self) && !(flags & InjectFlags.Host && isFirstHostTNode);
        }
        class NodeInjector {
            constructor(_tNode, _lView) {
                this._tNode = _tNode;
                this._lView = _lView;
            }
            get(token, notFoundValue, flags) {
                return getOrCreateInjectable(this._tNode, this._lView, token, flags, notFoundValue);
            }
        }
        function createNodeInjector() {
            return new NodeInjector(getCurrentTNode(), getLView());
        }
        function getInheritedFactory(type) {
            return noSideEffects(() => {
                const ownConstructor = type.prototype.constructor;
                const ownFactory = ownConstructor[NG_FACTORY_DEF] || getFactoryOf(ownConstructor);
                const objectPrototype = Object.prototype;
                let parent = Object.getPrototypeOf(type.prototype).constructor;
                while (parent && parent !== objectPrototype) {
                    const factory = parent[NG_FACTORY_DEF] || getFactoryOf(parent);
                    if (factory && factory !== ownFactory) {
                        return factory;
                    }
                    parent = Object.getPrototypeOf(parent);
                }
                return t => new t;
            });
        }
        function getFactoryOf(type) {
            if (isForwardRef(type)) {
                return () => {
                    const factory = getFactoryOf(resolveForwardRef(type));
                    return factory && factory();
                };
            }
            return getFactoryDef(type);
        }
        function lookupTokenUsingEmbeddedInjector(tNode, lView, token, flags, notFoundValue) {
            let currentTNode = tNode;
            let currentLView = lView;
            while (currentTNode !== null && currentLView !== null && currentLView[FLAGS] & 1024 && !(currentLView[FLAGS] & 256)) {
                const nodeInjectorValue = lookupTokenUsingNodeInjector(currentTNode, currentLView, token, flags | InjectFlags.Self, NOT_FOUND);
                if (nodeInjectorValue !== NOT_FOUND) {
                    return nodeInjectorValue;
                }
                let parentTNode = currentTNode.parent;
                if (!parentTNode) {
                    const embeddedViewInjector = currentLView[EMBEDDED_VIEW_INJECTOR];
                    if (embeddedViewInjector) {
                        const embeddedViewInjectorValue = embeddedViewInjector.get(token, NOT_FOUND, flags);
                        if (embeddedViewInjectorValue !== NOT_FOUND) {
                            return embeddedViewInjectorValue;
                        }
                    }
                    parentTNode = getTNodeFromLView(currentLView);
                    currentLView = currentLView[DECLARATION_VIEW];
                }
                currentTNode = parentTNode;
            }
            return notFoundValue;
        }
        function getTNodeFromLView(lView) {
            const tView = lView[TVIEW];
            const tViewType = tView.type;
            if (tViewType === 2) {
                return tView.declTNode;
            } else if (tViewType === 1) {
                return lView[T_HOST];
            }
            return null;
        }
        function injectAttribute(attrNameToInject) {
            return injectAttributeImpl(getCurrentTNode(), attrNameToInject);
        }
        const ANNOTATIONS = "__annotations__";
        const PARAMETERS = "__parameters__";
        const PROP_METADATA = "__prop__metadata__";
        function makeDecorator(name, props, parentClass, additionalProcessing, typeFn) {
            return noSideEffects(() => {
                const metaCtor = makeMetadataCtor(props);
                function DecoratorFactory(...args) {
                    if (this instanceof DecoratorFactory) {
                        metaCtor.call(this, ...args);
                        return this;
                    }
                    const annotationInstance = new DecoratorFactory(...args);
                    return function TypeDecorator(cls) {
                        if (typeFn) {
                            typeFn(cls, ...args);
                        }
                        const annotations = cls.hasOwnProperty(ANNOTATIONS) ? cls[ANNOTATIONS] : Object.defineProperty(cls, ANNOTATIONS, {
                            value: []
                        })[ANNOTATIONS];
                        annotations.push(annotationInstance);
                        if (additionalProcessing) {
                            additionalProcessing(cls);
                        }
                        return cls;
                    };
                }
                if (parentClass) {
                    DecoratorFactory.prototype = Object.create(parentClass.prototype);
                }
                DecoratorFactory.prototype.ngMetadataName = name;
                DecoratorFactory.annotationCls = DecoratorFactory;
                return DecoratorFactory;
            });
        }
        function makeMetadataCtor(props) {
            return function ctor(...args) {
                if (props) {
                    const values = props(...args);
                    for (const propName in values) {
                        this[propName] = values[propName];
                    }
                }
            };
        }
        function makeParamDecorator(name, props, parentClass) {
            return noSideEffects(() => {
                const metaCtor = makeMetadataCtor(props);
                function ParamDecoratorFactory(...args) {
                    if (this instanceof ParamDecoratorFactory) {
                        metaCtor.apply(this, args);
                        return this;
                    }
                    const annotationInstance = new ParamDecoratorFactory(...args);
                    ParamDecorator.annotation = annotationInstance;
                    return ParamDecorator;
                    function ParamDecorator(cls, unusedKey, index) {
                        const parameters = cls.hasOwnProperty(PARAMETERS) ? cls[PARAMETERS] : Object.defineProperty(cls, PARAMETERS, {
                            value: []
                        })[PARAMETERS];
                        while (parameters.length <= index) {
                            parameters.push(null);
                        }
                        (parameters[index] = parameters[index] || []).push(annotationInstance);
                        return cls;
                    }
                }
                if (parentClass) {
                    ParamDecoratorFactory.prototype = Object.create(parentClass.prototype);
                }
                ParamDecoratorFactory.prototype.ngMetadataName = name;
                ParamDecoratorFactory.annotationCls = ParamDecoratorFactory;
                return ParamDecoratorFactory;
            });
        }
        function makePropDecorator(name, props, parentClass, additionalProcessing) {
            return noSideEffects(() => {
                const metaCtor = makeMetadataCtor(props);
                function PropDecoratorFactory(...args) {
                    if (this instanceof PropDecoratorFactory) {
                        metaCtor.apply(this, args);
                        return this;
                    }
                    const decoratorInstance = new PropDecoratorFactory(...args);
                    function PropDecorator(target, name2) {
                        const constructor = target.constructor;
                        const meta = constructor.hasOwnProperty(PROP_METADATA) ? constructor[PROP_METADATA] : Object.defineProperty(constructor, PROP_METADATA, {
                            value: {}
                        })[PROP_METADATA];
                        meta[name2] = meta.hasOwnProperty(name2) && meta[name2] || [];
                        meta[name2].unshift(decoratorInstance);
                        if (additionalProcessing) {
                            additionalProcessing(target, name2, ...args);
                        }
                    }
                    return PropDecorator;
                }
                if (parentClass) {
                    PropDecoratorFactory.prototype = Object.create(parentClass.prototype);
                }
                PropDecoratorFactory.prototype.ngMetadataName = name;
                PropDecoratorFactory.annotationCls = PropDecoratorFactory;
                return PropDecoratorFactory;
            });
        }
        const Attribute = makeParamDecorator("Attribute", attributeName => ({
            attributeName,
            __NG_ELEMENT_ID__: () => injectAttribute(attributeName)
        }));
        class InjectionToken {
            constructor(_desc, options) {
                this._desc = _desc;
                this.ngMetadataName = "InjectionToken";
                this.prov = void 0;
                if (typeof options == "number") {
                    this.__NG_ELEMENT_ID__ = options;
                } else if (options !== void 0) {
                    this.prov = defineInjectable({
                        token: this,
                        providedIn: options.providedIn || "root",
                        factory: options.factory
                    });
                }
            }
            get multi() {
                return this;
            }
            toString() {
                return `InjectionToken ${this._desc}`;
            }
        }
        const ANALYZE_FOR_ENTRY_COMPONENTS = new InjectionToken("AnalyzeForEntryComponents");
        const emitDistinctChangesOnlyDefaultValue = true;
        class Query {}
        const ContentChildren = null;
        const ContentChild = null;
        const ViewChildren = null;
        const ViewChild = null;
        var FactoryTarget = null;
        var R3TemplateDependencyKind = null;
        var ViewEncapsulation = null;
        function getCompilerFacade(request) {
            const globalNg = _global["ng"];
            if (globalNg && globalNg.compilerFacade) {
                return globalNg.compilerFacade;
            }
            if (false) {
                console.error(`JIT compilation failed for ${request.kind}`, request.type);
                let message = `The ${request.kind} '${request.type.name}' needs to be compiled using the JIT compiler, but '@angular/compiler' is not available.\n\n`;
                if (request.usage === 1) {
                    message += `The ${request.kind} is part of a library that has been partially compiled.\n`;
                    message += `However, the Angular Linker has not processed the library such that JIT compilation is used as fallback.\n`;
                    message += "\n";
                    message += `Ideally, the library is processed using the Angular Linker to become fully AOT compiled.\n`;
                } else {
                    message += `JIT compilation is discouraged for production use-cases! Consider using AOT mode instead.\n`;
                }
                message += `Alternatively, the JIT compiler should be loaded by bootstrapping using '@angular/platform-browser-dynamic' or '@angular/platform-server',\n`;
                message += `or manually provide the compiler with 'import "@angular/compiler";' before bootstrapping.`;
                throw new Error(message);
            } else {
                throw new Error("JIT compiler unavailable");
            }
        }
        const Type = Function;
        function isType(v) {
            return typeof v === "function";
        }
        function addAllToArray(items, arr) {
            for (let i = 0; i < items.length; i++) {
                arr.push(items[i]);
            }
        }
        function arrayEquals(a, b, identityAccessor) {
            if (a.length !== b.length) {
                return false;
            }
            for (let i = 0; i < a.length; i++) {
                let valueA = a[i];
                let valueB = b[i];
                if (identityAccessor) {
                    valueA = identityAccessor(valueA);
                    valueB = identityAccessor(valueB);
                }
                if (valueB !== valueA) {
                    return false;
                }
            }
            return true;
        }
        function flatten(list, dst) {
            if (dst === void 0) {
                dst = list;
            }
            for (let i = 0; i < list.length; i++) {
                let item = list[i];
                if (Array.isArray(item)) {
                    if (dst === list) {
                        dst = list.slice(0, i);
                    }
                    flatten(item, dst);
                } else if (dst !== list) {
                    dst.push(item);
                }
            }
            return dst;
        }
        function deepForEach(input, fn) {
            input.forEach(value => Array.isArray(value) ? deepForEach(value, fn) : fn(value));
        }
        function addToArray(arr, index, value) {
            if (index >= arr.length) {
                arr.push(value);
            } else {
                arr.splice(index, 0, value);
            }
        }
        function removeFromArray(arr, index) {
            if (index >= arr.length - 1) {
                return arr.pop();
            } else {
                return arr.splice(index, 1)[0];
            }
        }
        function newArray(size, value) {
            const list = [];
            for (let i = 0; i < size; i++) {
                list.push(value);
            }
            return list;
        }
        function arraySplice(array, index, count) {
            const length = array.length - count;
            while (index < length) {
                array[index] = array[index + count];
                index++;
            }
            while (count--) {
                array.pop();
            }
        }
        function arrayInsert(array, index, value) {
            let end = array.length;
            while (end > index) {
                const previousEnd = end - 1;
                array[end] = array[previousEnd];
                end = previousEnd;
            }
            array[index] = value;
        }
        function arrayInsert2(array, index, value1, value2) {
            let end = array.length;
            if (end == index) {
                array.push(value1, value2);
            } else if (end === 1) {
                array.push(value2, array[0]);
                array[0] = value1;
            } else {
                end--;
                array.push(array[end - 1], array[end]);
                while (end > index) {
                    const previousEnd = end - 2;
                    array[end] = array[previousEnd];
                    end--;
                }
                array[index] = value1;
                array[index + 1] = value2;
            }
        }
        function arrayInsertSorted(array, value) {
            let index = arrayIndexOfSorted(array, value);
            if (index < 0) {
                index = ~index;
                arrayInsert(array, index, value);
            }
            return index;
        }
        function arrayRemoveSorted(array, value) {
            const index = arrayIndexOfSorted(array, value);
            if (index >= 0) {
                arraySplice(array, index, 1);
            }
            return index;
        }
        function arrayIndexOfSorted(array, value) {
            return _arrayIndexOfSorted(array, value, 0);
        }
        function keyValueArraySet(keyValueArray, key, value) {
            let index = keyValueArrayIndexOf(keyValueArray, key);
            if (index >= 0) {
                keyValueArray[index | 1] = value;
            } else {
                index = ~index;
                arrayInsert2(keyValueArray, index, key, value);
            }
            return index;
        }
        function keyValueArrayGet(keyValueArray, key) {
            const index = keyValueArrayIndexOf(keyValueArray, key);
            if (index >= 0) {
                return keyValueArray[index | 1];
            }
            return void 0;
        }
        function keyValueArrayIndexOf(keyValueArray, key) {
            return _arrayIndexOfSorted(keyValueArray, key, 1);
        }
        function keyValueArrayDelete(keyValueArray, key) {
            const index = keyValueArrayIndexOf(keyValueArray, key);
            if (index >= 0) {
                arraySplice(keyValueArray, index, 2);
            }
            return index;
        }
        function _arrayIndexOfSorted(array, value, shift) {
            let start = 0;
            let end = array.length >> shift;
            while (end !== start) {
                const middle = start + (end - start >> 1);
                const current = array[middle << shift];
                if (value === current) {
                    return middle << shift;
                } else if (current > value) {
                    end = middle;
                } else {
                    start = middle + 1;
                }
            }
            return ~(end << shift);
        }
        const ES5_DELEGATE_CTOR = /^function\s+\S+\(\)\s*{[\s\S]+\.apply\(this,\s*(arguments|(?:[^()]+\(\[\],)?[^()]+\(arguments\).*)\)/;
        const ES2015_INHERITED_CLASS = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{/;
        const ES2015_INHERITED_CLASS_WITH_CTOR = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(/;
        const ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(\)\s*{[^}]*super\(\.\.\.arguments\)/;
        function isDelegateCtor(typeStr) {
            return ES5_DELEGATE_CTOR.test(typeStr) || ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR.test(typeStr) || ES2015_INHERITED_CLASS.test(typeStr) && !ES2015_INHERITED_CLASS_WITH_CTOR.test(typeStr);
        }
        class ReflectionCapabilities {
            constructor(reflect) {
                this._reflect = reflect || _global["Reflect"];
            }
            factory(t) {
                return (...args) => new t(...args);
            }
            _zipTypesAndAnnotations(paramTypes, paramAnnotations) {
                let result;
                if (typeof paramTypes === "undefined") {
                    result = newArray(paramAnnotations.length);
                } else {
                    result = newArray(paramTypes.length);
                }
                for (let i = 0; i < result.length; i++) {
                    if (typeof paramTypes === "undefined") {
                        result[i] = [];
                    } else if (paramTypes[i] && paramTypes[i] != Object) {
                        result[i] = [ paramTypes[i] ];
                    } else {
                        result[i] = [];
                    }
                    if (paramAnnotations && paramAnnotations[i] != null) {
                        result[i] = result[i].concat(paramAnnotations[i]);
                    }
                }
                return result;
            }
            _ownParameters(type, parentCtor) {
                const typeStr = type.toString();
                if (isDelegateCtor(typeStr)) {
                    return null;
                }
                if (type.parameters && type.parameters !== parentCtor.parameters) {
                    return type.parameters;
                }
                const tsickleCtorParams = type.ctorParameters;
                if (tsickleCtorParams && tsickleCtorParams !== parentCtor.ctorParameters) {
                    const ctorParameters = typeof tsickleCtorParams === "function" ? tsickleCtorParams() : tsickleCtorParams;
                    const paramTypes2 = ctorParameters.map(ctorParam => ctorParam && ctorParam.type);
                    const paramAnnotations2 = ctorParameters.map(ctorParam => ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators));
                    return this._zipTypesAndAnnotations(paramTypes2, paramAnnotations2);
                }
                const paramAnnotations = type.hasOwnProperty(PARAMETERS) && type[PARAMETERS];
                const paramTypes = this._reflect && this._reflect.getOwnMetadata && this._reflect.getOwnMetadata("design:paramtypes", type);
                if (paramTypes || paramAnnotations) {
                    return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
                }
                return newArray(type.length);
            }
            parameters(type) {
                if (!isType(type)) {
                    return [];
                }
                const parentCtor = getParentCtor(type);
                let parameters = this._ownParameters(type, parentCtor);
                if (!parameters && parentCtor !== Object) {
                    parameters = this.parameters(parentCtor);
                }
                return parameters || [];
            }
            _ownAnnotations(typeOrFunc, parentCtor) {
                if (typeOrFunc.annotations && typeOrFunc.annotations !== parentCtor.annotations) {
                    let annotations = typeOrFunc.annotations;
                    if (typeof annotations === "function" && annotations.annotations) {
                        annotations = annotations.annotations;
                    }
                    return annotations;
                }
                if (typeOrFunc.decorators && typeOrFunc.decorators !== parentCtor.decorators) {
                    return convertTsickleDecoratorIntoMetadata(typeOrFunc.decorators);
                }
                if (typeOrFunc.hasOwnProperty(ANNOTATIONS)) {
                    return typeOrFunc[ANNOTATIONS];
                }
                return null;
            }
            annotations(typeOrFunc) {
                if (!isType(typeOrFunc)) {
                    return [];
                }
                const parentCtor = getParentCtor(typeOrFunc);
                const ownAnnotations = this._ownAnnotations(typeOrFunc, parentCtor) || [];
                const parentAnnotations = parentCtor !== Object ? this.annotations(parentCtor) : [];
                return parentAnnotations.concat(ownAnnotations);
            }
            _ownPropMetadata(typeOrFunc, parentCtor) {
                if (typeOrFunc.propMetadata && typeOrFunc.propMetadata !== parentCtor.propMetadata) {
                    let propMetadata = typeOrFunc.propMetadata;
                    if (typeof propMetadata === "function" && propMetadata.propMetadata) {
                        propMetadata = propMetadata.propMetadata;
                    }
                    return propMetadata;
                }
                if (typeOrFunc.propDecorators && typeOrFunc.propDecorators !== parentCtor.propDecorators) {
                    const propDecorators = typeOrFunc.propDecorators;
                    const propMetadata = {};
                    Object.keys(propDecorators).forEach(prop => {
                        propMetadata[prop] = convertTsickleDecoratorIntoMetadata(propDecorators[prop]);
                    });
                    return propMetadata;
                }
                if (typeOrFunc.hasOwnProperty(PROP_METADATA)) {
                    return typeOrFunc[PROP_METADATA];
                }
                return null;
            }
            propMetadata(typeOrFunc) {
                if (!isType(typeOrFunc)) {
                    return {};
                }
                const parentCtor = getParentCtor(typeOrFunc);
                const propMetadata = {};
                if (parentCtor !== Object) {
                    const parentPropMetadata = this.propMetadata(parentCtor);
                    Object.keys(parentPropMetadata).forEach(propName => {
                        propMetadata[propName] = parentPropMetadata[propName];
                    });
                }
                const ownPropMetadata = this._ownPropMetadata(typeOrFunc, parentCtor);
                if (ownPropMetadata) {
                    Object.keys(ownPropMetadata).forEach(propName => {
                        const decorators = [];
                        if (propMetadata.hasOwnProperty(propName)) {
                            decorators.push(...propMetadata[propName]);
                        }
                        decorators.push(...ownPropMetadata[propName]);
                        propMetadata[propName] = decorators;
                    });
                }
                return propMetadata;
            }
            ownPropMetadata(typeOrFunc) {
                if (!isType(typeOrFunc)) {
                    return {};
                }
                return this._ownPropMetadata(typeOrFunc, getParentCtor(typeOrFunc)) || {};
            }
            hasLifecycleHook(type, lcProperty) {
                return type instanceof Type && lcProperty in type.prototype;
            }
        }
        function convertTsickleDecoratorIntoMetadata(decoratorInvocations) {
            if (!decoratorInvocations) {
                return [];
            }
            return decoratorInvocations.map(decoratorInvocation => {
                const decoratorType = decoratorInvocation.type;
                const annotationCls = decoratorType.annotationCls;
                const annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];
                return new annotationCls(...annotationArgs);
            });
        }
        function getParentCtor(ctor) {
            const parentProto = ctor.prototype ? Object.getPrototypeOf(ctor.prototype) : null;
            const parentCtor = parentProto ? parentProto.constructor : null;
            return parentCtor || Object;
        }
        const _THROW_IF_NOT_FOUND = {};
        const THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
        const DI_DECORATOR_FLAG = "__NG_DI_FLAG__";
        const NG_TEMP_TOKEN_PATH = "ngTempTokenPath";
        const NG_TOKEN_PATH = "ngTokenPath";
        const NEW_LINE = /\n/gm;
        const NO_NEW_LINE = "";
        const SOURCE = "__source";
        let _currentInjector = void 0;
        function setCurrentInjector(injector) {
            const former = _currentInjector;
            _currentInjector = injector;
            return former;
        }
        function injectInjectorOnly(token, flags = InjectFlags.Default) {
            if (_currentInjector === void 0) {
                throw new RuntimeError(-203, false);
            } else if (_currentInjector === null) {
                return injectRootLimpMode(token, void 0, flags);
            } else {
                return _currentInjector.get(token, flags & InjectFlags.Optional ? null : void 0, flags);
            }
        }
        function core_inject(token, flags = InjectFlags.Default) {
            return (getInjectImplementation() || injectInjectorOnly)(resolveForwardRef(token), flags);
        }
        function invalidFactoryDep(index) {
            throw new RuntimeError(202, false);
        }
        function fesm2020_core_inject(token, flags = InjectFlags.Default) {
            if (typeof flags !== "number") {
                flags = 0 | (flags.optional && 8) | (flags.host && 1) | (flags.self && 2) | (flags.skipSelf && 4);
            }
            return core_inject(token, flags);
        }
        function injectArgs(types) {
            const args = [];
            for (let i = 0; i < types.length; i++) {
                const arg = resolveForwardRef(types[i]);
                if (Array.isArray(arg)) {
                    if (arg.length === 0) {
                        throw new RuntimeError(900, false);
                    }
                    let type = void 0;
                    let flags = InjectFlags.Default;
                    for (let j = 0; j < arg.length; j++) {
                        const meta = arg[j];
                        const flag = getInjectFlag(meta);
                        if (typeof flag === "number") {
                            if (flag === -1) {
                                type = meta.token;
                            } else {
                                flags |= flag;
                            }
                        } else {
                            type = meta;
                        }
                    }
                    args.push(core_inject(type, flags));
                } else {
                    args.push(core_inject(arg));
                }
            }
            return args;
        }
        function attachInjectFlag(decorator, flag) {
            decorator[DI_DECORATOR_FLAG] = flag;
            decorator.prototype[DI_DECORATOR_FLAG] = flag;
            return decorator;
        }
        function getInjectFlag(token) {
            return token[DI_DECORATOR_FLAG];
        }
        function catchInjectorError(e, token, injectorErrorName, source) {
            const tokenPath = e[NG_TEMP_TOKEN_PATH];
            if (token[SOURCE]) {
                tokenPath.unshift(token[SOURCE]);
            }
            e.message = formatError("\n" + e.message, tokenPath, injectorErrorName, source);
            e[NG_TOKEN_PATH] = tokenPath;
            e[NG_TEMP_TOKEN_PATH] = null;
            throw e;
        }
        function formatError(text, obj, injectorErrorName, source = null) {
            text = text && text.charAt(0) === "\n" && text.charAt(1) == NO_NEW_LINE ? text.slice(2) : text;
            let context2 = stringify(obj);
            if (Array.isArray(obj)) {
                context2 = obj.map(stringify).join(" -> ");
            } else if (typeof obj === "object") {
                let parts = [];
                for (let key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        let value = obj[key];
                        parts.push(key + ":" + (typeof value === "string" ? JSON.stringify(value) : stringify(value)));
                    }
                }
                context2 = `{${parts.join(", ")}}`;
            }
            return `${injectorErrorName}${source ? "(" + source + ")" : ""}[${context2}]: ${text.replace(NEW_LINE, "\n  ")}`;
        }
        const Inject = attachInjectFlag(makeParamDecorator("Inject", token => ({
            token
        })), -1);
        const core_Optional = attachInjectFlag(makeParamDecorator("Optional"), 8);
        const Self = attachInjectFlag(makeParamDecorator("Self"), 2);
        const SkipSelf = attachInjectFlag(makeParamDecorator("SkipSelf"), 4);
        const Host = attachInjectFlag(makeParamDecorator("Host"), 1);
        let _reflect = null;
        function getReflect() {
            return _reflect = _reflect || new ReflectionCapabilities;
        }
        function reflectDependencies(type) {
            return convertDependencies(getReflect().parameters(type));
        }
        function convertDependencies(deps) {
            return deps.map(dep => reflectDependency(dep));
        }
        function reflectDependency(dep) {
            const meta = {
                token: null,
                attribute: null,
                host: false,
                optional: false,
                self: false,
                skipSelf: false
            };
            if (Array.isArray(dep) && dep.length > 0) {
                for (let j = 0; j < dep.length; j++) {
                    const param = dep[j];
                    if (param === void 0) {
                        continue;
                    }
                    const proto = Object.getPrototypeOf(param);
                    if (param instanceof core_Optional || proto.ngMetadataName === "Optional") {
                        meta.optional = true;
                    } else if (param instanceof SkipSelf || proto.ngMetadataName === "SkipSelf") {
                        meta.skipSelf = true;
                    } else if (param instanceof Self || proto.ngMetadataName === "Self") {
                        meta.self = true;
                    } else if (param instanceof Host || proto.ngMetadataName === "Host") {
                        meta.host = true;
                    } else if (param instanceof Inject) {
                        meta.token = param.token;
                    } else if (param instanceof Attribute) {
                        if (param.attributeName === void 0) {
                            throw new RuntimeError(204, false);
                        }
                        meta.attribute = param.attributeName;
                    } else {
                        meta.token = param;
                    }
                }
            } else if (dep === void 0 || Array.isArray(dep) && dep.length === 0) {
                meta.token = null;
            } else {
                meta.token = dep;
            }
            return meta;
        }
        function resolveComponentResources(resourceResolver) {
            const componentResolved = [];
            const urlMap = new Map;
            function cachedResourceResolve(url) {
                let promise2 = urlMap.get(url);
                if (!promise2) {
                    const resp = resourceResolver(url);
                    urlMap.set(url, promise2 = resp.then(unwrapResponse));
                }
                return promise2;
            }
            componentResourceResolutionQueue.forEach((component, type) => {
                const promises = [];
                if (component.templateUrl) {
                    promises.push(cachedResourceResolve(component.templateUrl).then(template => {
                        component.template = template;
                    }));
                }
                const styleUrls = component.styleUrls;
                const styles = component.styles || (component.styles = []);
                const styleOffset = component.styles.length;
                styleUrls && styleUrls.forEach((styleUrl, index) => {
                    styles.push("");
                    promises.push(cachedResourceResolve(styleUrl).then(style => {
                        styles[styleOffset + index] = style;
                        styleUrls.splice(styleUrls.indexOf(styleUrl), 1);
                        if (styleUrls.length == 0) {
                            component.styleUrls = void 0;
                        }
                    }));
                });
                const fullyResolved = Promise.all(promises).then(() => componentDefResolved(type));
                componentResolved.push(fullyResolved);
            });
            clearResolutionOfComponentResourcesQueue();
            return Promise.all(componentResolved).then(() => void 0);
        }
        let componentResourceResolutionQueue = new Map;
        const componentDefPendingResolution = new Set;
        function maybeQueueResolutionOfComponentResources(type, metadata) {
            if (componentNeedsResolution(metadata)) {
                componentResourceResolutionQueue.set(type, metadata);
                componentDefPendingResolution.add(type);
            }
        }
        function isComponentDefPendingResolution(type) {
            return componentDefPendingResolution.has(type);
        }
        function componentNeedsResolution(component) {
            return !!(component.templateUrl && !component.hasOwnProperty("template") || component.styleUrls && component.styleUrls.length);
        }
        function clearResolutionOfComponentResourcesQueue() {
            const old = componentResourceResolutionQueue;
            componentResourceResolutionQueue = new Map;
            return old;
        }
        function restoreComponentResolutionQueue(queue) {
            componentDefPendingResolution.clear();
            queue.forEach((_, type) => componentDefPendingResolution.add(type));
            componentResourceResolutionQueue = queue;
        }
        function isComponentResourceResolutionQueueEmpty() {
            return componentResourceResolutionQueue.size === 0;
        }
        function unwrapResponse(response) {
            return typeof response == "string" ? response : response.text();
        }
        function componentDefResolved(type) {
            componentDefPendingResolution.delete(type);
        }
        const modules = new Map;
        let checkForDuplicateNgModules = true;
        function assertSameOrNotExisting(id, type, incoming) {
            if (type && type !== incoming && checkForDuplicateNgModules) {
                throw new Error(`Duplicate module registered for ${id} - ${stringify(type)} vs ${stringify(type.name)}`);
            }
        }
        function registerNgModuleType(ngModuleType, id) {
            const existing = modules.get(id) || null;
            assertSameOrNotExisting(id, existing, ngModuleType);
            modules.set(id, ngModuleType);
        }
        function clearModulesForTest() {
            modules.clear();
        }
        function getRegisteredNgModuleType(id) {
            return modules.get(id);
        }
        function setAllowDuplicateNgModuleIdsForTest(allowDuplicates) {
            checkForDuplicateNgModules = !allowDuplicates;
        }
        const CUSTOM_ELEMENTS_SCHEMA = {
            name: "custom-elements"
        };
        const NO_ERRORS_SCHEMA = {
            name: "no-errors-schema"
        };
        let shouldThrowErrorOnUnknownElement = false;
        function setUnknownElementStrictMode(shouldThrow) {
            shouldThrowErrorOnUnknownElement = shouldThrow;
        }
        function getUnknownElementStrictMode() {
            return shouldThrowErrorOnUnknownElement;
        }
        let shouldThrowErrorOnUnknownProperty = false;
        function setUnknownPropertyStrictMode(shouldThrow) {
            shouldThrowErrorOnUnknownProperty = shouldThrow;
        }
        function getUnknownPropertyStrictMode() {
            return shouldThrowErrorOnUnknownProperty;
        }
        function validateElementIsKnown(element, lView, tagName, schemas, hasDirectives) {
            if (schemas === null) {
                return;
            }
            if (!hasDirectives && tagName !== null) {
                const isUnknown = typeof HTMLUnknownElement !== "undefined" && HTMLUnknownElement && element instanceof HTMLUnknownElement || typeof customElements !== "undefined" && tagName.indexOf("-") > -1 && !customElements.get(tagName);
                if (isUnknown && !matchingSchemas(schemas, tagName)) {
                    const isHostStandalone = isHostComponentStandalone(lView);
                    const templateLocation = getTemplateLocationDetails(lView);
                    const schemas2 = `'${isHostStandalone ? "@Component" : "@NgModule"}.schemas'`;
                    let message = `'${tagName}' is not a known element${templateLocation}:\n`;
                    message += `1. If '${tagName}' is an Angular component, then verify that it is ${isHostStandalone ? "included in the '@Component.imports' of this component" : "a part of an @NgModule where this component is declared"}.\n`;
                    if (tagName && tagName.indexOf("-") > -1) {
                        message += `2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the ${schemas2} of this component to suppress this message.`;
                    } else {
                        message += `2. To allow any element add 'NO_ERRORS_SCHEMA' to the ${schemas2} of this component.`;
                    }
                    if (shouldThrowErrorOnUnknownElement) {
                        throw new RuntimeError(304, message);
                    } else {
                        console.error(formatRuntimeError(304, message));
                    }
                }
            }
        }
        function isPropertyValid(element, propName, tagName, schemas) {
            if (schemas === null) {
                return true;
            }
            if (matchingSchemas(schemas, tagName) || propName in element || isAnimationProp(propName)) {
                return true;
            }
            return typeof Node === "undefined" || Node === null || !(element instanceof Node);
        }
        function handleUnknownPropertyError(propName, tagName, nodeType, lView) {
            if (!tagName && nodeType === 4) {
                tagName = "ng-template";
            }
            const isHostStandalone = isHostComponentStandalone(lView);
            const templateLocation = getTemplateLocationDetails(lView);
            let message = `Can't bind to '${propName}' since it isn't a known property of '${tagName}'${templateLocation}.`;
            const schemas = `'${isHostStandalone ? "@Component" : "@NgModule"}.schemas'`;
            const importLocation = isHostStandalone ? "included in the '@Component.imports' of this component" : "a part of an @NgModule where this component is declared";
            if (KNOWN_CONTROL_FLOW_DIRECTIVES.has(propName)) {
                const correspondingImport = KNOWN_CONTROL_FLOW_DIRECTIVES.get(propName);
                message += `\nIf the '${propName}' is an Angular control flow directive, please make sure that either the '${correspondingImport}' directive or the 'CommonModule' is ${importLocation}.`;
            } else {
                message += `\n1. If '${tagName}' is an Angular component and it has the '${propName}' input, then verify that it is ${importLocation}.`;
                if (tagName && tagName.indexOf("-") > -1) {
                    message += `\n2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the ${schemas} of this component to suppress this message.`;
                    message += `\n3. To allow any property add 'NO_ERRORS_SCHEMA' to the ${schemas} of this component.`;
                } else {
                    message += `\n2. To allow any property add 'NO_ERRORS_SCHEMA' to the ${schemas} of this component.`;
                }
            }
            reportUnknownPropertyError(message);
        }
        function reportUnknownPropertyError(message) {
            if (shouldThrowErrorOnUnknownProperty) {
                throw new RuntimeError(303, message);
            } else {
                console.error(formatRuntimeError(303, message));
            }
        }
        function getDeclarationComponentDef(lView) {
            throwError("Must never be called in production mode");
            const declarationLView = lView[DECLARATION_COMPONENT_VIEW];
            const context2 = declarationLView[CONTEXT];
            if (!context2) {
                return null;
            }
            return context2.constructor ? getComponentDef(context2.constructor) : null;
        }
        function isHostComponentStandalone(lView) {
            throwError("Must never be called in production mode");
            const componentDef = getDeclarationComponentDef(lView);
            return !!componentDef?.standalone;
        }
        function getTemplateLocationDetails(lView) {
            throwError("Must never be called in production mode");
            const hostComponentDef = getDeclarationComponentDef(lView);
            const componentClassName = hostComponentDef?.type?.name;
            return componentClassName ? ` (used in the '${componentClassName}' component template)` : "";
        }
        const KNOWN_CONTROL_FLOW_DIRECTIVES = new Map([ [ "ngIf", "NgIf" ], [ "ngFor", "NgFor" ], [ "ngSwitchCase", "NgSwitchCase" ], [ "ngSwitchDefault", "NgSwitchDefault" ] ]);
        function matchingSchemas(schemas, tagName) {
            if (schemas !== null) {
                for (let i = 0; i < schemas.length; i++) {
                    const schema = schemas[i];
                    if (schema === NO_ERRORS_SCHEMA || schema === CUSTOM_ELEMENTS_SCHEMA && tagName && tagName.indexOf("-") > -1) {
                        return true;
                    }
                }
            }
            return false;
        }
        var RendererStyleFlags2 = (() => {
            RendererStyleFlags2 = RendererStyleFlags2 || {};
            RendererStyleFlags2[RendererStyleFlags2["Important"] = 1] = "Important";
            RendererStyleFlags2[RendererStyleFlags2["DashCase"] = 2] = "DashCase";
            return RendererStyleFlags2;
        })();
        const COMMENT_DISALLOWED = /^>|^->|<!--|-->|--!>|<!-$/g;
        const COMMENT_DELIMITER = /(<|>)/;
        const COMMENT_DELIMITER_ESCAPED = "$1";
        function escapeCommentText(value) {
            return value.replace(COMMENT_DISALLOWED, text => text.replace(COMMENT_DELIMITER, COMMENT_DELIMITER_ESCAPED));
        }
        const TRACKED_LVIEWS = new Map;
        let uniqueIdCounter = 0;
        function getUniqueLViewId() {
            return uniqueIdCounter++;
        }
        function registerLView(lView) {
            TRACKED_LVIEWS.set(lView[ID], lView);
        }
        function getLViewById(id) {
            return TRACKED_LVIEWS.get(id) || null;
        }
        function unregisterLView(lView) {
            TRACKED_LVIEWS.delete(lView[ID]);
        }
        class LContext {
            constructor(lViewId, nodeIndex, native) {
                this.lViewId = lViewId;
                this.nodeIndex = nodeIndex;
                this.native = native;
            }
            get lView() {
                return getLViewById(this.lViewId);
            }
        }
        function getLContext(target) {
            let mpValue = readPatchedData(target);
            if (mpValue) {
                if (isLView(mpValue)) {
                    const lView = mpValue;
                    let nodeIndex;
                    let component = void 0;
                    let directives = void 0;
                    if (isComponentInstance(target)) {
                        nodeIndex = findViaComponent(lView, target);
                        if (nodeIndex == -1) {
                            throw new Error("The provided component was not found in the application");
                        }
                        component = target;
                    } else if (isDirectiveInstance(target)) {
                        nodeIndex = findViaDirective(lView, target);
                        if (nodeIndex == -1) {
                            throw new Error("The provided directive was not found in the application");
                        }
                        directives = getDirectivesAtNodeIndex(nodeIndex, lView, false);
                    } else {
                        nodeIndex = findViaNativeElement(lView, target);
                        if (nodeIndex == -1) {
                            return null;
                        }
                    }
                    const native = unwrapRNode(lView[nodeIndex]);
                    const existingCtx = readPatchedData(native);
                    const context2 = existingCtx && !Array.isArray(existingCtx) ? existingCtx : createLContext(lView, nodeIndex, native);
                    if (component && context2.component === void 0) {
                        context2.component = component;
                        attachPatchData(context2.component, context2);
                    }
                    if (directives && context2.directives === void 0) {
                        context2.directives = directives;
                        for (let i = 0; i < directives.length; i++) {
                            attachPatchData(directives[i], context2);
                        }
                    }
                    attachPatchData(context2.native, context2);
                    mpValue = context2;
                }
            } else {
                const rElement = target;
                let parent = rElement;
                while (parent = parent.parentNode) {
                    const parentContext = readPatchedData(parent);
                    if (parentContext) {
                        const lView = Array.isArray(parentContext) ? parentContext : parentContext.lView;
                        if (!lView) {
                            return null;
                        }
                        const index = findViaNativeElement(lView, rElement);
                        if (index >= 0) {
                            const native = unwrapRNode(lView[index]);
                            const context2 = createLContext(lView, index, native);
                            attachPatchData(native, context2);
                            mpValue = context2;
                            break;
                        }
                    }
                }
            }
            return mpValue || null;
        }
        function createLContext(lView, nodeIndex, native) {
            return new LContext(lView[ID], nodeIndex, native);
        }
        function getComponentViewByInstance(componentInstance) {
            let patchedData = readPatchedData(componentInstance);
            let lView;
            if (isLView(patchedData)) {
                const contextLView = patchedData;
                const nodeIndex = findViaComponent(contextLView, componentInstance);
                lView = getComponentLViewByIndex(nodeIndex, contextLView);
                const context2 = createLContext(contextLView, nodeIndex, lView[HOST]);
                context2.component = componentInstance;
                attachPatchData(componentInstance, context2);
                attachPatchData(context2.native, context2);
            } else {
                const context2 = patchedData;
                const contextLView = context2.lView;
                lView = getComponentLViewByIndex(context2.nodeIndex, contextLView);
            }
            return lView;
        }
        const MONKEY_PATCH_KEY_NAME = "__ngContext__";
        function attachPatchData(target, data) {
            if (isLView(data)) {
                target[MONKEY_PATCH_KEY_NAME] = data[ID];
                registerLView(data);
            } else {
                target[MONKEY_PATCH_KEY_NAME] = data;
            }
        }
        function readPatchedData(target) {
            const data = target[MONKEY_PATCH_KEY_NAME];
            return typeof data === "number" ? getLViewById(data) : data || null;
        }
        function readPatchedLView(target) {
            const value = readPatchedData(target);
            if (value) {
                return isLView(value) ? value : value.lView;
            }
            return null;
        }
        function isComponentInstance(instance) {
            return instance && instance.constructor && instance.constructor.cmp;
        }
        function isDirectiveInstance(instance) {
            return instance && instance.constructor && instance.constructor.dir;
        }
        function findViaNativeElement(lView, target) {
            const tView = lView[TVIEW];
            for (let i = HEADER_OFFSET; i < tView.bindingStartIndex; i++) {
                if (unwrapRNode(lView[i]) === target) {
                    return i;
                }
            }
            return -1;
        }
        function traverseNextElement(tNode) {
            if (tNode.child) {
                return tNode.child;
            } else if (tNode.next) {
                return tNode.next;
            } else {
                while (tNode.parent && !tNode.parent.next) {
                    tNode = tNode.parent;
                }
                return tNode.parent && tNode.parent.next;
            }
        }
        function findViaComponent(lView, componentInstance) {
            const componentIndices = lView[TVIEW].components;
            if (componentIndices) {
                for (let i = 0; i < componentIndices.length; i++) {
                    const elementComponentIndex = componentIndices[i];
                    const componentView = getComponentLViewByIndex(elementComponentIndex, lView);
                    if (componentView[CONTEXT] === componentInstance) {
                        return elementComponentIndex;
                    }
                }
            } else {
                const rootComponentView = getComponentLViewByIndex(HEADER_OFFSET, lView);
                const rootComponent = rootComponentView[CONTEXT];
                if (rootComponent === componentInstance) {
                    return HEADER_OFFSET;
                }
            }
            return -1;
        }
        function findViaDirective(lView, directiveInstance) {
            let tNode = lView[TVIEW].firstChild;
            while (tNode) {
                const directiveIndexStart = tNode.directiveStart;
                const directiveIndexEnd = tNode.directiveEnd;
                for (let i = directiveIndexStart; i < directiveIndexEnd; i++) {
                    if (lView[i] === directiveInstance) {
                        return tNode.index;
                    }
                }
                tNode = traverseNextElement(tNode);
            }
            return -1;
        }
        function getDirectivesAtNodeIndex(nodeIndex, lView, includeComponents) {
            const tNode = lView[TVIEW].data[nodeIndex];
            let directiveStartIndex = tNode.directiveStart;
            if (directiveStartIndex == 0) {
                return EMPTY_ARRAY;
            }
            const directiveEndIndex = tNode.directiveEnd;
            if (!includeComponents && tNode.flags & 2) {
                directiveStartIndex++;
            }
            return lView.slice(directiveStartIndex, directiveEndIndex);
        }
        function getComponentAtNodeIndex(nodeIndex, lView) {
            const tNode = lView[TVIEW].data[nodeIndex];
            let directiveStartIndex = tNode.directiveStart;
            return tNode.flags & 2 ? lView[directiveStartIndex] : null;
        }
        function discoverLocalRefs(lView, nodeIndex) {
            const tNode = lView[TVIEW].data[nodeIndex];
            if (tNode && tNode.localNames) {
                const result = {};
                let localIndex = tNode.index + 1;
                for (let i = 0; i < tNode.localNames.length; i += 2) {
                    result[tNode.localNames[i]] = lView[localIndex];
                    localIndex++;
                }
                return result;
            }
            return null;
        }
        let _icuContainerIterate;
        function icuContainerIterate(tIcuContainerNode, lView) {
            return _icuContainerIterate(tIcuContainerNode, lView);
        }
        function ensureIcuContainerVisitorLoaded(loader) {
            if (_icuContainerIterate === void 0) {
                _icuContainerIterate = loader();
            }
        }
        const unusedValueExportToPlacateAjd$4 = 1;
        const unusedValueExportToPlacateAjd$3 = 1;
        function getLViewParent(lView) {
            const parent = lView[PARENT];
            return isLContainer(parent) ? parent[PARENT] : parent;
        }
        function getRootView(componentOrLView) {
            let lView = isLView(componentOrLView) ? componentOrLView : readPatchedLView(componentOrLView);
            while (lView && !(lView[FLAGS] & 256)) {
                lView = getLViewParent(lView);
            }
            return lView;
        }
        function getRootContext(viewOrComponent) {
            const rootView = getRootView(viewOrComponent);
            return rootView[CONTEXT];
        }
        function getFirstLContainer(lView) {
            return getNearestLContainer(lView[CHILD_HEAD]);
        }
        function getNextLContainer(container) {
            return getNearestLContainer(container[NEXT]);
        }
        function getNearestLContainer(viewOrContainer) {
            while (viewOrContainer !== null && !isLContainer(viewOrContainer)) {
                viewOrContainer = viewOrContainer[NEXT];
            }
            return viewOrContainer;
        }
        const unusedValueToPlacateAjd$2 = unusedValueExportToPlacateAjd$7 + unusedValueExportToPlacateAjd$5 + unusedValueExportToPlacateAjd$4 + unusedValueExportToPlacateAjd$3 + unusedValueExportToPlacateAjd$8;
        function applyToElementOrContainer(action, renderer, parent, lNodeToHandle, beforeNode) {
            if (lNodeToHandle != null) {
                let lContainer;
                let isComponent = false;
                if (isLContainer(lNodeToHandle)) {
                    lContainer = lNodeToHandle;
                } else if (isLView(lNodeToHandle)) {
                    isComponent = true;
                    lNodeToHandle = lNodeToHandle[HOST];
                }
                const rNode = unwrapRNode(lNodeToHandle);
                if (action === 0 && parent !== null) {
                    if (beforeNode == null) {
                        nativeAppendChild(renderer, parent, rNode);
                    } else {
                        nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);
                    }
                } else if (action === 1 && parent !== null) {
                    nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);
                } else if (action === 2) {
                    nativeRemoveNode(renderer, rNode, isComponent);
                } else if (action === 3) {
                    renderer.destroyNode(rNode);
                }
                if (lContainer != null) {
                    applyContainer(renderer, action, lContainer, parent, beforeNode);
                }
            }
        }
        function createTextNode(renderer, value) {
            return renderer.createText(value);
        }
        function updateTextNode(renderer, rNode, value) {
            renderer.setValue(rNode, value);
        }
        function createCommentNode(renderer, value) {
            return renderer.createComment(escapeCommentText(value));
        }
        function createElementNode(renderer, name, namespace) {
            return renderer.createElement(name, namespace);
        }
        function removeViewFromContainer(tView, lView) {
            const renderer = lView[RENDERER];
            applyView(tView, lView, renderer, 2, null, null);
            lView[HOST] = null;
            lView[T_HOST] = null;
        }
        function addViewToContainer(tView, parentTNode, renderer, lView, parentNativeNode, beforeNode) {
            lView[HOST] = parentNativeNode;
            lView[T_HOST] = parentTNode;
            applyView(tView, lView, renderer, 1, parentNativeNode, beforeNode);
        }
        function renderDetachView(tView, lView) {
            applyView(tView, lView, lView[RENDERER], 2, null, null);
        }
        function destroyViewTree(rootView) {
            let lViewOrLContainer = rootView[CHILD_HEAD];
            if (!lViewOrLContainer) {
                return cleanUpView(rootView[TVIEW], rootView);
            }
            while (lViewOrLContainer) {
                let next = null;
                if (isLView(lViewOrLContainer)) {
                    next = lViewOrLContainer[CHILD_HEAD];
                } else {
                    const firstView = lViewOrLContainer[CONTAINER_HEADER_OFFSET];
                    if (firstView) {
                        next = firstView;
                    }
                }
                if (!next) {
                    while (lViewOrLContainer && !lViewOrLContainer[NEXT] && lViewOrLContainer !== rootView) {
                        if (isLView(lViewOrLContainer)) {
                            cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);
                        }
                        lViewOrLContainer = lViewOrLContainer[PARENT];
                    }
                    if (lViewOrLContainer === null) {
                        lViewOrLContainer = rootView;
                    }
                    if (isLView(lViewOrLContainer)) {
                        cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);
                    }
                    next = lViewOrLContainer && lViewOrLContainer[NEXT];
                }
                lViewOrLContainer = next;
            }
        }
        function insertView(tView, lView, lContainer, index) {
            const indexInContainer = CONTAINER_HEADER_OFFSET + index;
            const containerLength = lContainer.length;
            if (index > 0) {
                lContainer[indexInContainer - 1][NEXT] = lView;
            }
            if (index < containerLength - CONTAINER_HEADER_OFFSET) {
                lView[NEXT] = lContainer[indexInContainer];
                addToArray(lContainer, CONTAINER_HEADER_OFFSET + index, lView);
            } else {
                lContainer.push(lView);
                lView[NEXT] = null;
            }
            lView[PARENT] = lContainer;
            const declarationLContainer = lView[DECLARATION_LCONTAINER];
            if (declarationLContainer !== null && lContainer !== declarationLContainer) {
                trackMovedView(declarationLContainer, lView);
            }
            const lQueries = lView[QUERIES];
            if (lQueries !== null) {
                lQueries.insertView(tView);
            }
            lView[FLAGS] |= 64;
        }
        function trackMovedView(declarationContainer, lView) {
            const movedViews = declarationContainer[MOVED_VIEWS];
            const insertedLContainer = lView[PARENT];
            const insertedComponentLView = insertedLContainer[PARENT][DECLARATION_COMPONENT_VIEW];
            const declaredComponentLView = lView[DECLARATION_COMPONENT_VIEW];
            if (declaredComponentLView !== insertedComponentLView) {
                declarationContainer[HAS_TRANSPLANTED_VIEWS] = true;
            }
            if (movedViews === null) {
                declarationContainer[MOVED_VIEWS] = [ lView ];
            } else {
                movedViews.push(lView);
            }
        }
        function detachMovedView(declarationContainer, lView) {
            const movedViews = declarationContainer[MOVED_VIEWS];
            const declarationViewIndex = movedViews.indexOf(lView);
            const insertionLContainer = lView[PARENT];
            if (lView[FLAGS] & 512) {
                lView[FLAGS] &= ~512;
                updateTransplantedViewCount(insertionLContainer, -1);
            }
            movedViews.splice(declarationViewIndex, 1);
        }
        function detachView(lContainer, removeIndex) {
            if (lContainer.length <= CONTAINER_HEADER_OFFSET) {
                return;
            }
            const indexInContainer = CONTAINER_HEADER_OFFSET + removeIndex;
            const viewToDetach = lContainer[indexInContainer];
            if (viewToDetach) {
                const declarationLContainer = viewToDetach[DECLARATION_LCONTAINER];
                if (declarationLContainer !== null && declarationLContainer !== lContainer) {
                    detachMovedView(declarationLContainer, viewToDetach);
                }
                if (removeIndex > 0) {
                    lContainer[indexInContainer - 1][NEXT] = viewToDetach[NEXT];
                }
                const removedLView = removeFromArray(lContainer, CONTAINER_HEADER_OFFSET + removeIndex);
                removeViewFromContainer(viewToDetach[TVIEW], viewToDetach);
                const lQueries = removedLView[QUERIES];
                if (lQueries !== null) {
                    lQueries.detachView(removedLView[TVIEW]);
                }
                viewToDetach[PARENT] = null;
                viewToDetach[NEXT] = null;
                viewToDetach[FLAGS] &= ~64;
            }
            return viewToDetach;
        }
        function destroyLView(tView, lView) {
            if (!(lView[FLAGS] & 128)) {
                const renderer = lView[RENDERER];
                if (renderer.destroyNode) {
                    applyView(tView, lView, renderer, 3, null, null);
                }
                destroyViewTree(lView);
            }
        }
        function cleanUpView(tView, lView) {
            if (!(lView[FLAGS] & 128)) {
                lView[FLAGS] &= ~64;
                lView[FLAGS] |= 128;
                executeOnDestroys(tView, lView);
                processCleanups(tView, lView);
                if (lView[TVIEW].type === 1) {
                    lView[RENDERER].destroy();
                }
                const declarationContainer = lView[DECLARATION_LCONTAINER];
                if (declarationContainer !== null && isLContainer(lView[PARENT])) {
                    if (declarationContainer !== lView[PARENT]) {
                        detachMovedView(declarationContainer, lView);
                    }
                    const lQueries = lView[QUERIES];
                    if (lQueries !== null) {
                        lQueries.detachView(tView);
                    }
                }
                unregisterLView(lView);
            }
        }
        function processCleanups(tView, lView) {
            const tCleanup = tView.cleanup;
            const lCleanup = lView[CLEANUP];
            let lastLCleanupIndex = -1;
            if (tCleanup !== null) {
                for (let i = 0; i < tCleanup.length - 1; i += 2) {
                    if (typeof tCleanup[i] === "string") {
                        const idxOrTargetGetter = tCleanup[i + 1];
                        const target = typeof idxOrTargetGetter === "function" ? idxOrTargetGetter(lView) : unwrapRNode(lView[idxOrTargetGetter]);
                        const listener = lCleanup[lastLCleanupIndex = tCleanup[i + 2]];
                        const useCaptureOrSubIdx = tCleanup[i + 3];
                        if (typeof useCaptureOrSubIdx === "boolean") {
                            target.removeEventListener(tCleanup[i], listener, useCaptureOrSubIdx);
                        } else {
                            if (useCaptureOrSubIdx >= 0) {
                                lCleanup[lastLCleanupIndex = useCaptureOrSubIdx]();
                            } else {
                                lCleanup[lastLCleanupIndex = -useCaptureOrSubIdx].unsubscribe();
                            }
                        }
                        i += 2;
                    } else {
                        const context2 = lCleanup[lastLCleanupIndex = tCleanup[i + 1]];
                        tCleanup[i].call(context2);
                    }
                }
            }
            if (lCleanup !== null) {
                for (let i = lastLCleanupIndex + 1; i < lCleanup.length; i++) {
                    const instanceCleanupFn = lCleanup[i];
                    instanceCleanupFn();
                }
                lView[CLEANUP] = null;
            }
        }
        function executeOnDestroys(tView, lView) {
            let destroyHooks;
            if (tView != null && (destroyHooks = tView.destroyHooks) != null) {
                for (let i = 0; i < destroyHooks.length; i += 2) {
                    const context2 = lView[destroyHooks[i]];
                    if (!(context2 instanceof NodeInjectorFactory)) {
                        const toCall = destroyHooks[i + 1];
                        if (Array.isArray(toCall)) {
                            for (let j = 0; j < toCall.length; j += 2) {
                                const callContext = context2[toCall[j]];
                                const hook = toCall[j + 1];
                                profiler(4, callContext, hook);
                                try {
                                    hook.call(callContext);
                                } finally {
                                    profiler(5, callContext, hook);
                                }
                            }
                        } else {
                            profiler(4, context2, toCall);
                            try {
                                toCall.call(context2);
                            } finally {
                                profiler(5, context2, toCall);
                            }
                        }
                    }
                }
            }
        }
        function getParentRElement(tView, tNode, lView) {
            return getClosestRElement(tView, tNode.parent, lView);
        }
        function getClosestRElement(tView, tNode, lView) {
            let parentTNode = tNode;
            while (parentTNode !== null && parentTNode.type & (8 | 32)) {
                tNode = parentTNode;
                parentTNode = tNode.parent;
            }
            if (parentTNode === null) {
                return lView[HOST];
            } else {
                if (parentTNode.flags & 2) {
                    const encapsulation = tView.data[parentTNode.directiveStart].encapsulation;
                    if (encapsulation === ViewEncapsulation$1.None || encapsulation === ViewEncapsulation$1.Emulated) {
                        return null;
                    }
                }
                return getNativeByTNode(parentTNode, lView);
            }
        }
        function nativeInsertBefore(renderer, parent, child, beforeNode, isMove) {
            renderer.insertBefore(parent, child, beforeNode, isMove);
        }
        function nativeAppendChild(renderer, parent, child) {
            renderer.appendChild(parent, child);
        }
        function nativeAppendOrInsertBefore(renderer, parent, child, beforeNode, isMove) {
            if (beforeNode !== null) {
                nativeInsertBefore(renderer, parent, child, beforeNode, isMove);
            } else {
                nativeAppendChild(renderer, parent, child);
            }
        }
        function nativeRemoveChild(renderer, parent, child, isHostElement) {
            renderer.removeChild(parent, child, isHostElement);
        }
        function isTemplateNode(node) {
            return node.tagName === "TEMPLATE" && node.content !== void 0;
        }
        function nativeParentNode(renderer, node) {
            return renderer.parentNode(node);
        }
        function nativeNextSibling(renderer, node) {
            return renderer.nextSibling(node);
        }
        function getInsertInFrontOfRNode(parentTNode, currentTNode, lView) {
            return _getInsertInFrontOfRNodeWithI18n(parentTNode, currentTNode, lView);
        }
        function getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView) {
            if (parentTNode.type & (8 | 32)) {
                return getNativeByTNode(parentTNode, lView);
            }
            return null;
        }
        let _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithNoI18n;
        let _processI18nInsertBefore;
        function setI18nHandling(getInsertInFrontOfRNodeWithI18n2, processI18nInsertBefore2) {
            _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithI18n2;
            _processI18nInsertBefore = processI18nInsertBefore2;
        }
        function appendChild(tView, lView, childRNode, childTNode) {
            const parentRNode = getParentRElement(tView, childTNode, lView);
            const renderer = lView[RENDERER];
            const parentTNode = childTNode.parent || lView[T_HOST];
            const anchorNode = getInsertInFrontOfRNode(parentTNode, childTNode, lView);
            if (parentRNode != null) {
                if (Array.isArray(childRNode)) {
                    for (let i = 0; i < childRNode.length; i++) {
                        nativeAppendOrInsertBefore(renderer, parentRNode, childRNode[i], anchorNode, false);
                    }
                } else {
                    nativeAppendOrInsertBefore(renderer, parentRNode, childRNode, anchorNode, false);
                }
            }
            _processI18nInsertBefore !== void 0 && _processI18nInsertBefore(renderer, childTNode, lView, childRNode, parentRNode);
        }
        function getFirstNativeNode(lView, tNode) {
            if (tNode !== null) {
                const tNodeType = tNode.type;
                if (tNodeType & 3) {
                    return getNativeByTNode(tNode, lView);
                } else if (tNodeType & 4) {
                    return getBeforeNodeForView(-1, lView[tNode.index]);
                } else if (tNodeType & 8) {
                    const elIcuContainerChild = tNode.child;
                    if (elIcuContainerChild !== null) {
                        return getFirstNativeNode(lView, elIcuContainerChild);
                    } else {
                        const rNodeOrLContainer = lView[tNode.index];
                        if (isLContainer(rNodeOrLContainer)) {
                            return getBeforeNodeForView(-1, rNodeOrLContainer);
                        } else {
                            return unwrapRNode(rNodeOrLContainer);
                        }
                    }
                } else if (tNodeType & 32) {
                    let nextRNode = icuContainerIterate(tNode, lView);
                    let rNode = nextRNode();
                    return rNode || unwrapRNode(lView[tNode.index]);
                } else {
                    const projectionNodes = getProjectionNodes(lView, tNode);
                    if (projectionNodes !== null) {
                        if (Array.isArray(projectionNodes)) {
                            return projectionNodes[0];
                        }
                        const parentView = getLViewParent(lView[DECLARATION_COMPONENT_VIEW]);
                        return getFirstNativeNode(parentView, projectionNodes);
                    } else {
                        return getFirstNativeNode(lView, tNode.next);
                    }
                }
            }
            return null;
        }
        function getProjectionNodes(lView, tNode) {
            if (tNode !== null) {
                const componentView = lView[DECLARATION_COMPONENT_VIEW];
                const componentHost = componentView[T_HOST];
                const slotIdx = tNode.projection;
                return componentHost.projection[slotIdx];
            }
            return null;
        }
        function getBeforeNodeForView(viewIndexInContainer, lContainer) {
            const nextViewIndex = CONTAINER_HEADER_OFFSET + viewIndexInContainer + 1;
            if (nextViewIndex < lContainer.length) {
                const lView = lContainer[nextViewIndex];
                const firstTNodeOfView = lView[TVIEW].firstChild;
                if (firstTNodeOfView !== null) {
                    return getFirstNativeNode(lView, firstTNodeOfView);
                }
            }
            return lContainer[NATIVE];
        }
        function nativeRemoveNode(renderer, rNode, isHostElement) {
            const nativeParent = nativeParentNode(renderer, rNode);
            if (nativeParent) {
                nativeRemoveChild(renderer, nativeParent, rNode, isHostElement);
            }
        }
        function applyNodes(renderer, action, tNode, lView, parentRElement, beforeNode, isProjection) {
            while (tNode != null) {
                const rawSlotValue = lView[tNode.index];
                const tNodeType = tNode.type;
                if (isProjection) {
                    if (action === 0) {
                        rawSlotValue && attachPatchData(unwrapRNode(rawSlotValue), lView);
                        tNode.flags |= 4;
                    }
                }
                if ((tNode.flags & 64) !== 64) {
                    if (tNodeType & 8) {
                        applyNodes(renderer, action, tNode.child, lView, parentRElement, beforeNode, false);
                        applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);
                    } else if (tNodeType & 32) {
                        const nextRNode = icuContainerIterate(tNode, lView);
                        let rNode;
                        while (rNode = nextRNode()) {
                            applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);
                        }
                        applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);
                    } else if (tNodeType & 16) {
                        applyProjectionRecursive(renderer, action, lView, tNode, parentRElement, beforeNode);
                    } else {
                        applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);
                    }
                }
                tNode = isProjection ? tNode.projectionNext : tNode.next;
            }
        }
        function applyView(tView, lView, renderer, action, parentRElement, beforeNode) {
            applyNodes(renderer, action, tView.firstChild, lView, parentRElement, beforeNode, false);
        }
        function applyProjection(tView, lView, tProjectionNode) {
            const renderer = lView[RENDERER];
            const parentRNode = getParentRElement(tView, tProjectionNode, lView);
            const parentTNode = tProjectionNode.parent || lView[T_HOST];
            let beforeNode = getInsertInFrontOfRNode(parentTNode, tProjectionNode, lView);
            applyProjectionRecursive(renderer, 0, lView, tProjectionNode, parentRNode, beforeNode);
        }
        function applyProjectionRecursive(renderer, action, lView, tProjectionNode, parentRElement, beforeNode) {
            const componentLView = lView[DECLARATION_COMPONENT_VIEW];
            const componentNode = componentLView[T_HOST];
            const nodeToProjectOrRNodes = componentNode.projection[tProjectionNode.projection];
            if (Array.isArray(nodeToProjectOrRNodes)) {
                for (let i = 0; i < nodeToProjectOrRNodes.length; i++) {
                    const rNode = nodeToProjectOrRNodes[i];
                    applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);
                }
            } else {
                let nodeToProject = nodeToProjectOrRNodes;
                const projectedComponentLView = componentLView[PARENT];
                applyNodes(renderer, action, nodeToProject, projectedComponentLView, parentRElement, beforeNode, true);
            }
        }
        function applyContainer(renderer, action, lContainer, parentRElement, beforeNode) {
            const anchor = lContainer[NATIVE];
            const native = unwrapRNode(lContainer);
            if (anchor !== native) {
                applyToElementOrContainer(action, renderer, parentRElement, anchor, beforeNode);
            }
            for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
                const lView = lContainer[i];
                applyView(lView[TVIEW], lView, renderer, action, parentRElement, anchor);
            }
        }
        function applyStyling(renderer, isClassBased, rNode, prop, value) {
            if (isClassBased) {
                if (!value) {
                    renderer.removeClass(rNode, prop);
                } else {
                    renderer.addClass(rNode, prop);
                }
            } else {
                let flags = prop.indexOf("-") === -1 ? void 0 : RendererStyleFlags2.DashCase;
                if (value == null) {
                    renderer.removeStyle(rNode, prop, flags);
                } else {
                    const isImportant = typeof value === "string" ? value.endsWith("!important") : false;
                    if (isImportant) {
                        value = value.slice(0, -10);
                        flags |= RendererStyleFlags2.Important;
                    }
                    renderer.setStyle(rNode, prop, value, flags);
                }
            }
        }
        function writeDirectStyle(renderer, element, newValue) {
            renderer.setAttribute(element, "style", newValue);
        }
        function writeDirectClass(renderer, element, newValue) {
            if (newValue === "") {
                renderer.removeAttribute(element, "class");
            } else {
                renderer.setAttribute(element, "class", newValue);
            }
        }
        let policy$1;
        function getPolicy$1() {
            if (policy$1 === void 0) {
                policy$1 = null;
                if (_global.trustedTypes) {
                    try {
                        policy$1 = _global.trustedTypes.createPolicy("angular", {
                            createHTML: s => s,
                            createScript: s => s,
                            createScriptURL: s => s
                        });
                    } catch {}
                }
            }
            return policy$1;
        }
        function trustedHTMLFromString(html) {
            return getPolicy$1()?.createHTML(html) || html;
        }
        function trustedScriptFromString(script) {
            return getPolicy$1()?.createScript(script) || script;
        }
        function trustedScriptURLFromString(url) {
            return getPolicy$1()?.createScriptURL(url) || url;
        }
        function newTrustedFunctionForDev(...args) {
            if (false) {
                throw new Error("newTrustedFunctionForDev should never be called in production");
            }
            if (!_global.trustedTypes) {
                return new Function(...args);
            }
            const fnArgs = args.slice(0, -1).join(",");
            const fnBody = args[args.length - 1];
            const body = `(function anonymous(${fnArgs}\n) { ${fnBody}\n})`;
            const fn = _global["eval"](trustedScriptFromString(body));
            if (fn.bind === void 0) {
                return new Function(...args);
            }
            fn.toString = () => body;
            return fn.bind(_global);
        }
        function validateIframeAttribute(attrValue, tagName, attrName) {
            const lView = getLView();
            const tNode = getSelectedTNode();
            const element = getNativeByTNode(tNode, lView);
            if (tNode.type === 2 && tagName.toLowerCase() === "iframe") {
                const iframe = element;
                iframe.src = "";
                iframe.srcdoc = trustedHTMLFromString("");
                nativeRemoveNode(lView[RENDERER], iframe);
                const errorMessage = false;
                throw new RuntimeError(-910, errorMessage);
            }
            return attrValue;
        }
        let core_DOCUMENT = void 0;
        function setDocument(document2) {
            core_DOCUMENT = document2;
        }
        function getDocument() {
            if (core_DOCUMENT !== void 0) {
                return core_DOCUMENT;
            } else if (typeof document !== "undefined") {
                return document;
            }
            return void 0;
        }
        let policy;
        function getPolicy() {
            if (policy === void 0) {
                policy = null;
                if (_global.trustedTypes) {
                    try {
                        policy = _global.trustedTypes.createPolicy("angular#unsafe-bypass", {
                            createHTML: s => s,
                            createScript: s => s,
                            createScriptURL: s => s
                        });
                    } catch {}
                }
            }
            return policy;
        }
        function trustedHTMLFromStringBypass(html) {
            return getPolicy()?.createHTML(html) || html;
        }
        function trustedScriptFromStringBypass(script) {
            return getPolicy()?.createScript(script) || script;
        }
        function trustedScriptURLFromStringBypass(url) {
            return getPolicy()?.createScriptURL(url) || url;
        }
        class SafeValueImpl {
            constructor(changingThisBreaksApplicationSecurity) {
                this.changingThisBreaksApplicationSecurity = changingThisBreaksApplicationSecurity;
            }
            toString() {
                return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)`;
            }
        }
        class SafeHtmlImpl extends(null){
            getTypeName() {
                return "HTML";
            }
        }
        class SafeStyleImpl extends(null){
            getTypeName() {
                return "Style";
            }
        }
        class SafeScriptImpl extends(null){
            getTypeName() {
                return "Script";
            }
        }
        class SafeUrlImpl extends(null){
            getTypeName() {
                return "URL";
            }
        }
        class SafeResourceUrlImpl extends(null){
            getTypeName() {
                return "ResourceURL";
            }
        }
        function unwrapSafeValue(value) {
            return value instanceof SafeValueImpl ? value.changingThisBreaksApplicationSecurity : value;
        }
        function allowSanitizationBypassAndThrow(value, type) {
            const actualType = getSanitizationBypassType(value);
            if (actualType != null && actualType !== type) {
                if (actualType === "ResourceURL" && type === "URL") {
                    return true;
                }
                throw new Error(`Required a safe ${type}, got a ${actualType} (see https://g.co/ng/security#xss)`);
            }
            return actualType === type;
        }
        function getSanitizationBypassType(value) {
            return value instanceof SafeValueImpl && value.getTypeName() || null;
        }
        function bypassSanitizationTrustHtml(trustedHtml) {
            return new SafeHtmlImpl(trustedHtml);
        }
        function bypassSanitizationTrustStyle(trustedStyle) {
            return new SafeStyleImpl(trustedStyle);
        }
        function bypassSanitizationTrustScript(trustedScript) {
            return new SafeScriptImpl(trustedScript);
        }
        function bypassSanitizationTrustUrl(trustedUrl) {
            return new SafeUrlImpl(trustedUrl);
        }
        function bypassSanitizationTrustResourceUrl(trustedResourceUrl) {
            return new SafeResourceUrlImpl(trustedResourceUrl);
        }
        function getInertBodyHelper(defaultDoc) {
            const inertDocumentHelper = new InertDocumentHelper(defaultDoc);
            return isDOMParserAvailable() ? new DOMParserHelper(inertDocumentHelper) : inertDocumentHelper;
        }
        class DOMParserHelper {
            constructor(inertDocumentHelper) {
                this.inertDocumentHelper = inertDocumentHelper;
            }
            getInertBodyElement(html) {
                html = "<body><remove></remove>" + html;
                try {
                    const body = (new window.DOMParser).parseFromString(trustedHTMLFromString(html), "text/html").body;
                    if (body === null) {
                        return this.inertDocumentHelper.getInertBodyElement(html);
                    }
                    body.removeChild(body.firstChild);
                    return body;
                } catch {
                    return null;
                }
            }
        }
        class InertDocumentHelper {
            constructor(defaultDoc) {
                this.defaultDoc = defaultDoc;
                this.inertDocument = this.defaultDoc.implementation.createHTMLDocument("sanitization-inert");
                if (this.inertDocument.body == null) {
                    const inertHtml = this.inertDocument.createElement("html");
                    this.inertDocument.appendChild(inertHtml);
                    const inertBodyElement = this.inertDocument.createElement("body");
                    inertHtml.appendChild(inertBodyElement);
                }
            }
            getInertBodyElement(html) {
                const templateEl = this.inertDocument.createElement("template");
                if ("content" in templateEl) {
                    templateEl.innerHTML = trustedHTMLFromString(html);
                    return templateEl;
                }
                const inertBody = this.inertDocument.createElement("body");
                inertBody.innerHTML = trustedHTMLFromString(html);
                if (this.defaultDoc.documentMode) {
                    this.stripCustomNsAttrs(inertBody);
                }
                return inertBody;
            }
            stripCustomNsAttrs(el) {
                const elAttrs = el.attributes;
                for (let i = elAttrs.length - 1; 0 < i; i--) {
                    const attrib = elAttrs.item(i);
                    const attrName = attrib.name;
                    if (attrName === "xmlns:ns1" || attrName.indexOf("ns1:") === 0) {
                        el.removeAttribute(attrName);
                    }
                }
                let childNode = el.firstChild;
                while (childNode) {
                    if (childNode.nodeType === Node.ELEMENT_NODE) {
                        this.stripCustomNsAttrs(childNode);
                    }
                    childNode = childNode.nextSibling;
                }
            }
        }
        function isDOMParserAvailable() {
            try {
                return !!(new window.DOMParser).parseFromString(trustedHTMLFromString(""), "text/html");
            } catch {
                return false;
            }
        }
        const SAFE_URL_PATTERN = /^(?:(?:https?|mailto|data|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi;
        function _sanitizeUrl(url) {
            url = String(url);
            if (url.match(SAFE_URL_PATTERN)) {
                return url;
            }
            if (false) {
                console.warn(`WARNING: sanitizing unsafe URL value ${url} (see https://g.co/ng/security#xss)`);
            }
            return "unsafe:" + url;
        }
        function tagSet(tags) {
            const res = {};
            for (const t of tags.split(",")) {
                res[t] = true;
            }
            return res;
        }
        function core_merge(...sets) {
            const res = {};
            for (const s of sets) {
                for (const v in s) {
                    if (s.hasOwnProperty(v)) {
                        res[v] = true;
                    }
                }
            }
            return res;
        }
        const VOID_ELEMENTS = tagSet("area,br,col,hr,img,wbr");
        const OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr");
        const OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet("rp,rt");
        const OPTIONAL_END_TAG_ELEMENTS = core_merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS);
        const BLOCK_ELEMENTS = core_merge(OPTIONAL_END_TAG_BLOCK_ELEMENTS, tagSet("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul"));
        const INLINE_ELEMENTS = core_merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, tagSet("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video"));
        const VALID_ELEMENTS = core_merge(VOID_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS);
        const URI_ATTRS = tagSet("background,cite,href,itemtype,longdesc,poster,src,xlink:href");
        const HTML_ATTRS = tagSet("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,srcset,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width");
        const ARIA_ATTRS = tagSet("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext");
        const VALID_ATTRS = core_merge(URI_ATTRS, HTML_ATTRS, ARIA_ATTRS);
        const SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS = tagSet("script,style,template");
        class SanitizingHtmlSerializer {
            constructor() {
                this.sanitizedSomething = false;
                this.buf = [];
            }
            sanitizeChildren(el) {
                let current = el.firstChild;
                let traverseContent = true;
                while (current) {
                    if (current.nodeType === Node.ELEMENT_NODE) {
                        traverseContent = this.startElement(current);
                    } else if (current.nodeType === Node.TEXT_NODE) {
                        this.chars(current.nodeValue);
                    } else {
                        this.sanitizedSomething = true;
                    }
                    if (traverseContent && current.firstChild) {
                        current = current.firstChild;
                        continue;
                    }
                    while (current) {
                        if (current.nodeType === Node.ELEMENT_NODE) {
                            this.endElement(current);
                        }
                        let next = this.checkClobberedElement(current, current.nextSibling);
                        if (next) {
                            current = next;
                            break;
                        }
                        current = this.checkClobberedElement(current, current.parentNode);
                    }
                }
                return this.buf.join("");
            }
            startElement(element) {
                const tagName = element.nodeName.toLowerCase();
                if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {
                    this.sanitizedSomething = true;
                    return !SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS.hasOwnProperty(tagName);
                }
                this.buf.push("<");
                this.buf.push(tagName);
                const elAttrs = element.attributes;
                for (let i = 0; i < elAttrs.length; i++) {
                    const elAttr = elAttrs.item(i);
                    const attrName = elAttr.name;
                    const lower = attrName.toLowerCase();
                    if (!VALID_ATTRS.hasOwnProperty(lower)) {
                        this.sanitizedSomething = true;
                        continue;
                    }
                    let value = elAttr.value;
                    if (URI_ATTRS[lower]) {
                        value = _sanitizeUrl(value);
                    }
                    this.buf.push(" ", attrName, '="', encodeEntities(value), '"');
                }
                this.buf.push(">");
                return true;
            }
            endElement(current) {
                const tagName = current.nodeName.toLowerCase();
                if (VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName)) {
                    this.buf.push("</");
                    this.buf.push(tagName);
                    this.buf.push(">");
                }
            }
            chars(chars) {
                this.buf.push(encodeEntities(chars));
            }
            checkClobberedElement(node, nextNode) {
                if (nextNode && (node.compareDocumentPosition(nextNode) & Node.DOCUMENT_POSITION_CONTAINED_BY) === Node.DOCUMENT_POSITION_CONTAINED_BY) {
                    throw new Error(`Failed to sanitize html because the element is clobbered: ${node.outerHTML}`);
                }
                return nextNode;
            }
        }
        const SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
        const NON_ALPHANUMERIC_REGEXP = /([^\#-~ |!])/g;
        function encodeEntities(value) {
            return value.replace(/&/g, "&amp;").replace(SURROGATE_PAIR_REGEXP, function(match2) {
                const hi = match2.charCodeAt(0);
                const low = match2.charCodeAt(1);
                return "&#" + ((hi - 55296) * 1024 + (low - 56320) + 65536) + ";";
            }).replace(NON_ALPHANUMERIC_REGEXP, function(match2) {
                return "&#" + match2.charCodeAt(0) + ";";
            }).replace(/</g, "&lt;").replace(/>/g, "&gt;");
        }
        let inertBodyHelper;
        function _sanitizeHtml(defaultDoc, unsafeHtmlInput) {
            let inertBodyElement = null;
            try {
                inertBodyHelper = inertBodyHelper || getInertBodyHelper(defaultDoc);
                let unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : "";
                inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);
                let mXSSAttempts = 5;
                let parsedHtml = unsafeHtml;
                do {
                    if (mXSSAttempts === 0) {
                        throw new Error("Failed to sanitize html because the input is unstable");
                    }
                    mXSSAttempts--;
                    unsafeHtml = parsedHtml;
                    parsedHtml = inertBodyElement.innerHTML;
                    inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);
                } while (unsafeHtml !== parsedHtml);
                const sanitizer = new SanitizingHtmlSerializer;
                const safeHtml = sanitizer.sanitizeChildren(getTemplateContent(inertBodyElement) || inertBodyElement);
                if (false) {
                    console.warn("WARNING: sanitizing HTML stripped some content, see https://g.co/ng/security#xss");
                }
                return trustedHTMLFromString(safeHtml);
            } finally {
                if (inertBodyElement) {
                    const parent = getTemplateContent(inertBodyElement) || inertBodyElement;
                    while (parent.firstChild) {
                        parent.removeChild(parent.firstChild);
                    }
                }
            }
        }
        function getTemplateContent(el) {
            return "content" in el && isTemplateElement(el) ? el.content : null;
        }
        function isTemplateElement(el) {
            return el.nodeType === Node.ELEMENT_NODE && el.nodeName === "TEMPLATE";
        }
        var core_SecurityContext = (() => {
            core_SecurityContext = core_SecurityContext || {};
            core_SecurityContext[core_SecurityContext["NONE"] = 0] = "NONE";
            core_SecurityContext[core_SecurityContext["HTML"] = 1] = "HTML";
            core_SecurityContext[core_SecurityContext["STYLE"] = 2] = "STYLE";
            core_SecurityContext[core_SecurityContext["SCRIPT"] = 3] = "SCRIPT";
            core_SecurityContext[core_SecurityContext["URL"] = 4] = "URL";
            core_SecurityContext[core_SecurityContext["RESOURCE_URL"] = 5] = "RESOURCE_URL";
            return core_SecurityContext;
        })();
        function sanitizeHtml(unsafeHtml) {
            const sanitizer = getSanitizer();
            if (sanitizer) {
                return trustedHTMLFromStringBypass(sanitizer.sanitize(core_SecurityContext.HTML, unsafeHtml) || "");
            }
            if (allowSanitizationBypassAndThrow(unsafeHtml, "HTML")) {
                return trustedHTMLFromStringBypass(unwrapSafeValue(unsafeHtml));
            }
            return _sanitizeHtml(getDocument(), renderStringify(unsafeHtml));
        }
        function sanitizeStyle(unsafeStyle) {
            const sanitizer = getSanitizer();
            if (sanitizer) {
                return sanitizer.sanitize(core_SecurityContext.STYLE, unsafeStyle) || "";
            }
            if (allowSanitizationBypassAndThrow(unsafeStyle, "Style")) {
                return unwrapSafeValue(unsafeStyle);
            }
            return renderStringify(unsafeStyle);
        }
        function sanitizeUrl(unsafeUrl) {
            const sanitizer = getSanitizer();
            if (sanitizer) {
                return sanitizer.sanitize(core_SecurityContext.URL, unsafeUrl) || "";
            }
            if (allowSanitizationBypassAndThrow(unsafeUrl, "URL")) {
                return unwrapSafeValue(unsafeUrl);
            }
            return _sanitizeUrl(renderStringify(unsafeUrl));
        }
        function sanitizeResourceUrl(unsafeResourceUrl) {
            const sanitizer = getSanitizer();
            if (sanitizer) {
                return trustedScriptURLFromStringBypass(sanitizer.sanitize(core_SecurityContext.RESOURCE_URL, unsafeResourceUrl) || "");
            }
            if (allowSanitizationBypassAndThrow(unsafeResourceUrl, "ResourceURL")) {
                return trustedScriptURLFromStringBypass(unwrapSafeValue(unsafeResourceUrl));
            }
            throw new RuntimeError(904, false);
        }
        function sanitizeScript(unsafeScript) {
            const sanitizer = getSanitizer();
            if (sanitizer) {
                return trustedScriptFromStringBypass(sanitizer.sanitize(core_SecurityContext.SCRIPT, unsafeScript) || "");
            }
            if (allowSanitizationBypassAndThrow(unsafeScript, "Script")) {
                return trustedScriptFromStringBypass(unwrapSafeValue(unsafeScript));
            }
            throw new RuntimeError(905, false);
        }
        function trustConstantHtml(html) {
            if (false) {
                throw new Error(`Unexpected interpolation in trusted HTML constant: ${html.join("?")}`);
            }
            return trustedHTMLFromString(html[0]);
        }
        function trustConstantResourceUrl(url) {
            if (false) {
                throw new Error(`Unexpected interpolation in trusted URL constant: ${url.join("?")}`);
            }
            return trustedScriptURLFromString(url[0]);
        }
        function getUrlSanitizer(tag, prop) {
            if (prop === "src" && (tag === "embed" || tag === "frame" || tag === "iframe" || tag === "media" || tag === "script") || prop === "href" && (tag === "base" || tag === "link")) {
                return sanitizeResourceUrl;
            }
            return sanitizeUrl;
        }
        function sanitizeUrlOrResourceUrl(unsafeUrl, tag, prop) {
            return getUrlSanitizer(tag, prop)(unsafeUrl);
        }
        function validateAgainstEventProperties(name) {
            if (name.toLowerCase().startsWith("on")) {
                const errorMessage = `Binding to event property '${name}' is disallowed for security reasons, please use (${name.slice(2)})=...\nIf '${name}' is a directive input, make sure the directive is imported by the current module.`;
                throw new RuntimeError(306, errorMessage);
            }
        }
        function validateAgainstEventAttributes(name) {
            if (name.toLowerCase().startsWith("on")) {
                const errorMessage = `Binding to event attribute '${name}' is disallowed for security reasons, please use (${name.slice(2)})=...`;
                throw new RuntimeError(306, errorMessage);
            }
        }
        function getSanitizer() {
            const lView = getLView();
            return lView && lView[SANITIZER];
        }
        const ENVIRONMENT_INITIALIZER = new InjectionToken("ENVIRONMENT_INITIALIZER");
        const INJECTOR = new InjectionToken("INJECTOR", -1);
        const INJECTOR_DEF_TYPES = new InjectionToken("INJECTOR_DEF_TYPES");
        class NullInjector {
            get(token, notFoundValue = THROW_IF_NOT_FOUND) {
                if (notFoundValue === THROW_IF_NOT_FOUND) {
                    const error = new Error(`NullInjectorError: No provider for ${stringify(token)}!`);
                    error.name = "NullInjectorError";
                    throw error;
                }
                return notFoundValue;
            }
        }
        function importProvidersFrom(...sources) {
            return {
                providers: internalImportProvidersFrom(true, sources)
            };
        }
        function internalImportProvidersFrom(checkForStandaloneCmp, ...sources) {
            const providersOut = [];
            const dedup = new Set;
            let injectorTypesWithProviders;
            deepForEach(sources, source => {
                if (false) {
                    const cmpDef = getComponentDef(source);
                    if (cmpDef?.standalone) {
                        throw new RuntimeError(800, `Importing providers supports NgModule or ModuleWithProviders but got a standalone component "${stringifyForError(source)}"`);
                    }
                }
                const internalSource = source;
                if (walkProviderTree(internalSource, providersOut, [], dedup)) {
                    injectorTypesWithProviders || (injectorTypesWithProviders = []);
                    injectorTypesWithProviders.push(internalSource);
                }
            });
            if (injectorTypesWithProviders !== void 0) {
                processInjectorTypesWithProviders(injectorTypesWithProviders, providersOut);
            }
            return providersOut;
        }
        function processInjectorTypesWithProviders(typesWithProviders, providersOut) {
            for (let i = 0; i < typesWithProviders.length; i++) {
                const {ngModule, providers} = typesWithProviders[i];
                deepForEach(providers, provider => {
                    providersOut.push(provider);
                });
            }
        }
        function walkProviderTree(container, providersOut, parents, dedup) {
            container = resolveForwardRef(container);
            if (!container) {
                return false;
            }
            let defType = null;
            let injDef = getInjectorDef(container);
            const cmpDef = !injDef && getComponentDef(container);
            if (!injDef && !cmpDef) {
                const ngModule = container.ngModule;
                injDef = getInjectorDef(ngModule);
                if (injDef) {
                    defType = ngModule;
                } else {
                    return false;
                }
            } else if (cmpDef && !cmpDef.standalone) {
                return false;
            } else {
                defType = container;
            }
            if (false) {
                const defName = stringify(defType);
                const path = parents.map(stringify);
                throwCyclicDependencyError(defName, path);
            }
            const isDuplicate = dedup.has(defType);
            if (cmpDef) {
                if (isDuplicate) {
                    return false;
                }
                dedup.add(defType);
                if (cmpDef.dependencies) {
                    const deps = typeof cmpDef.dependencies === "function" ? cmpDef.dependencies() : cmpDef.dependencies;
                    for (const dep of deps) {
                        walkProviderTree(dep, providersOut, parents, dedup);
                    }
                }
            } else if (injDef) {
                if (injDef.imports != null && !isDuplicate) {
                    dedup.add(defType);
                    let importTypesWithProviders;
                    try {
                        deepForEach(injDef.imports, imported => {
                            if (walkProviderTree(imported, providersOut, parents, dedup)) {
                                importTypesWithProviders || (importTypesWithProviders = []);
                                importTypesWithProviders.push(imported);
                            }
                        });
                    } finally {}
                    if (importTypesWithProviders !== void 0) {
                        processInjectorTypesWithProviders(importTypesWithProviders, providersOut);
                    }
                }
                if (!isDuplicate) {
                    const factory = getFactoryDef(defType) || (() => new defType);
                    providersOut.push({
                        provide: defType,
                        useFactory: factory,
                        deps: EMPTY_ARRAY
                    }, {
                        provide: INJECTOR_DEF_TYPES,
                        useValue: defType,
                        multi: true
                    }, {
                        provide: ENVIRONMENT_INITIALIZER,
                        useValue: () => core_inject(defType),
                        multi: true
                    });
                }
                const defProviders = injDef.providers;
                if (defProviders != null && !isDuplicate) {
                    const injectorType = container;
                    deepForEach(defProviders, provider => {
                        providersOut.push(provider);
                    });
                }
            } else {
                return false;
            }
            return defType !== container && container.providers !== void 0;
        }
        function validateProvider(provider, providers, containerType) {
            if (isTypeProvider(provider) || isValueProvider(provider) || isFactoryProvider(provider) || isExistingProvider(provider)) {
                return;
            }
            const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));
            if (!classRef) {
                throwInvalidProviderError(containerType, providers, provider);
            }
        }
        const USE_VALUE$1 = getClosureSafeProperty({
            provide: String,
            useValue: getClosureSafeProperty
        });
        function isValueProvider(value) {
            return value !== null && typeof value == "object" && USE_VALUE$1 in value;
        }
        function isExistingProvider(value) {
            return !!(value && value.useExisting);
        }
        function isFactoryProvider(value) {
            return !!(value && value.useFactory);
        }
        function isTypeProvider(value) {
            return typeof value === "function";
        }
        function isClassProvider(value) {
            return !!value.useClass;
        }
        const INJECTOR_SCOPE = new InjectionToken("Set Injector scope.");
        const NOT_YET = {};
        const CIRCULAR = {};
        let NULL_INJECTOR$1 = void 0;
        function getNullInjector() {
            if (NULL_INJECTOR$1 === void 0) {
                NULL_INJECTOR$1 = new NullInjector;
            }
            return NULL_INJECTOR$1;
        }
        class EnvironmentInjector {}
        class R3Injector extends EnvironmentInjector {
            constructor(providers, parent, source, scopes) {
                super();
                this.parent = parent;
                this.source = source;
                this.scopes = scopes;
                this.records = new Map;
                this._ngOnDestroyHooks = new Set;
                this._onDestroyHooks = [];
                this._destroyed = false;
                forEachSingleProvider(providers, provider => this.processProvider(provider));
                this.records.set(INJECTOR, makeRecord(void 0, this));
                if (scopes.has("environment")) {
                    this.records.set(EnvironmentInjector, makeRecord(void 0, this));
                }
                const record = this.records.get(INJECTOR_SCOPE);
                if (record != null && typeof record.value === "string") {
                    this.scopes.add(record.value);
                }
                this.injectorDefTypes = new Set(this.get(INJECTOR_DEF_TYPES.multi, EMPTY_ARRAY, InjectFlags.Self));
            }
            get destroyed() {
                return this._destroyed;
            }
            destroy() {
                this.assertNotDestroyed();
                this._destroyed = true;
                try {
                    for (const service of this._ngOnDestroyHooks) {
                        service.ngOnDestroy();
                    }
                    for (const hook of this._onDestroyHooks) {
                        hook();
                    }
                } finally {
                    this.records.clear();
                    this._ngOnDestroyHooks.clear();
                    this.injectorDefTypes.clear();
                    this._onDestroyHooks.length = 0;
                }
            }
            onDestroy(callback) {
                this._onDestroyHooks.push(callback);
            }
            runInContext(fn) {
                this.assertNotDestroyed();
                const previousInjector = setCurrentInjector(this);
                const previousInjectImplementation = setInjectImplementation(void 0);
                try {
                    return fn();
                } finally {
                    setCurrentInjector(previousInjector);
                    setInjectImplementation(previousInjectImplementation);
                }
            }
            get(token, notFoundValue = THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {
                this.assertNotDestroyed();
                const previousInjector = setCurrentInjector(this);
                const previousInjectImplementation = setInjectImplementation(void 0);
                try {
                    if (!(flags & InjectFlags.SkipSelf)) {
                        let record = this.records.get(token);
                        if (record === void 0) {
                            const def = couldBeInjectableType(token) && getInjectableDef(token);
                            if (def && this.injectableDefInScope(def)) {
                                record = makeRecord(injectableDefOrInjectorDefFactory(token), NOT_YET);
                            } else {
                                record = null;
                            }
                            this.records.set(token, record);
                        }
                        if (record != null) {
                            return this.hydrate(token, record);
                        }
                    }
                    const nextInjector = !(flags & InjectFlags.Self) ? this.parent : getNullInjector();
                    notFoundValue = flags & InjectFlags.Optional && notFoundValue === THROW_IF_NOT_FOUND ? null : notFoundValue;
                    return nextInjector.get(token, notFoundValue);
                } catch (e) {
                    if (e.name === "NullInjectorError") {
                        const path = e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || [];
                        path.unshift(stringify(token));
                        if (previousInjector) {
                            throw e;
                        } else {
                            return catchInjectorError(e, token, "R3InjectorError", this.source);
                        }
                    } else {
                        throw e;
                    }
                } finally {
                    setInjectImplementation(previousInjectImplementation);
                    setCurrentInjector(previousInjector);
                }
            }
            resolveInjectorInitializers() {
                const previousInjector = setCurrentInjector(this);
                const previousInjectImplementation = setInjectImplementation(void 0);
                try {
                    const initializers = this.get(ENVIRONMENT_INITIALIZER.multi, EMPTY_ARRAY, InjectFlags.Self);
                    if (false) {
                        throw new RuntimeError(209, `Unexpected type of the \`ENVIRONMENT_INITIALIZER\` token value (expected an array, but got ${typeof initializers}). Please check that the \`ENVIRONMENT_INITIALIZER\` token is configured as a \`multi: true\` provider.`);
                    }
                    for (const initializer of initializers) {
                        initializer();
                    }
                } finally {
                    setCurrentInjector(previousInjector);
                    setInjectImplementation(previousInjectImplementation);
                }
            }
            toString() {
                const tokens = [];
                const records = this.records;
                for (const token of records.keys()) {
                    tokens.push(stringify(token));
                }
                return `R3Injector[${tokens.join(", ")}]`;
            }
            assertNotDestroyed() {
                if (this._destroyed) {
                    throw new RuntimeError(205, false);
                }
            }
            processProvider(provider) {
                provider = resolveForwardRef(provider);
                let token = isTypeProvider(provider) ? provider : resolveForwardRef(provider && provider.provide);
                const record = providerToRecord(provider);
                if (!isTypeProvider(provider) && provider.multi === true) {
                    let multiRecord = this.records.get(token);
                    if (multiRecord) {
                        if (false) {
                            throwMixedMultiProviderError();
                        }
                    } else {
                        multiRecord = makeRecord(void 0, NOT_YET, true);
                        multiRecord.factory = () => injectArgs(multiRecord.multi);
                        this.records.set(token, multiRecord);
                    }
                    token = provider;
                    multiRecord.multi.push(provider);
                } else {
                    const existing = this.records.get(token);
                    if (false) {
                        throwMixedMultiProviderError();
                    }
                }
                this.records.set(token, record);
            }
            hydrate(token, record) {
                if (false) {
                    throwCyclicDependencyError(stringify(token));
                } else if (record.value === NOT_YET) {
                    record.value = CIRCULAR;
                    record.value = record.factory();
                }
                if (typeof record.value === "object" && record.value && hasOnDestroy(record.value)) {
                    this._ngOnDestroyHooks.add(record.value);
                }
                return record.value;
            }
            injectableDefInScope(def) {
                if (!def.providedIn) {
                    return false;
                }
                const providedIn = resolveForwardRef(def.providedIn);
                if (typeof providedIn === "string") {
                    return providedIn === "any" || this.scopes.has(providedIn);
                } else {
                    return this.injectorDefTypes.has(providedIn);
                }
            }
        }
        function injectableDefOrInjectorDefFactory(token) {
            const injectableDef = getInjectableDef(token);
            const factory = injectableDef !== null ? injectableDef.factory : getFactoryDef(token);
            if (factory !== null) {
                return factory;
            }
            if (token instanceof InjectionToken) {
                throw new RuntimeError(204, false);
            }
            if (token instanceof Function) {
                return getUndecoratedInjectableFactory(token);
            }
            throw new RuntimeError(204, false);
        }
        function getUndecoratedInjectableFactory(token) {
            const paramLength = token.length;
            if (paramLength > 0) {
                const args = newArray(paramLength, "?");
                throw new RuntimeError(204, false);
            }
            const inheritedInjectableDef = getInheritedInjectableDef(token);
            if (inheritedInjectableDef !== null) {
                return () => inheritedInjectableDef.factory(token);
            } else {
                return () => new token;
            }
        }
        function providerToRecord(provider) {
            if (isValueProvider(provider)) {
                return makeRecord(void 0, provider.useValue);
            } else {
                const factory = providerToFactory(provider);
                return makeRecord(factory, NOT_YET);
            }
        }
        function providerToFactory(provider, ngModuleType, providers) {
            let factory = void 0;
            if (false) {
                throwInvalidProviderError(void 0, providers, provider);
            }
            if (isTypeProvider(provider)) {
                const unwrappedProvider = resolveForwardRef(provider);
                return getFactoryDef(unwrappedProvider) || injectableDefOrInjectorDefFactory(unwrappedProvider);
            } else {
                if (isValueProvider(provider)) {
                    factory = () => resolveForwardRef(provider.useValue);
                } else if (isFactoryProvider(provider)) {
                    factory = () => provider.useFactory(...injectArgs(provider.deps || []));
                } else if (isExistingProvider(provider)) {
                    factory = () => core_inject(resolveForwardRef(provider.useExisting));
                } else {
                    const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));
                    if (false) {
                        throwInvalidProviderError(ngModuleType, providers, provider);
                    }
                    if (hasDeps(provider)) {
                        factory = () => new classRef(...injectArgs(provider.deps));
                    } else {
                        return getFactoryDef(classRef) || injectableDefOrInjectorDefFactory(classRef);
                    }
                }
            }
            return factory;
        }
        function makeRecord(factory, value, multi = false) {
            return {
                factory,
                value,
                multi: multi ? [] : void 0
            };
        }
        function hasDeps(value) {
            return !!value.deps;
        }
        function hasOnDestroy(value) {
            return value !== null && typeof value === "object" && typeof value.ngOnDestroy === "function";
        }
        function couldBeInjectableType(value) {
            return typeof value === "function" || typeof value === "object" && value instanceof InjectionToken;
        }
        function isImportedNgModuleProviders(provider) {
            return !!provider.providers;
        }
        function forEachSingleProvider(providers, fn) {
            for (const provider of providers) {
                if (Array.isArray(provider)) {
                    forEachSingleProvider(provider, fn);
                } else if (isImportedNgModuleProviders(provider)) {
                    forEachSingleProvider(provider.providers, fn);
                } else {
                    fn(provider);
                }
            }
        }
        class ComponentRef$1 {}
        class ComponentFactory$1 {}
        function noComponentFactoryError(component) {
            const error = Error(`No component factory found for ${stringify(component)}. Did you add it to @NgModule.entryComponents?`);
            error[ERROR_COMPONENT] = component;
            return error;
        }
        const ERROR_COMPONENT = "ngComponent";
        function getComponent$1(error) {
            return error[ERROR_COMPONENT];
        }
        class _NullComponentFactoryResolver {
            resolveComponentFactory(component) {
                throw noComponentFactoryError(component);
            }
        }
        let ComponentFactoryResolver$1 = (() => {
            class ComponentFactoryResolver$12 {}
            ComponentFactoryResolver$12.NULL = new _NullComponentFactoryResolver;
            return ComponentFactoryResolver$12;
        })();
        function injectElementRef() {
            return createElementRef(getCurrentTNode(), getLView());
        }
        function createElementRef(tNode, lView) {
            return new core_ElementRef(getNativeByTNode(tNode, lView));
        }
        let core_ElementRef = (() => {
            class ElementRef2 {
                constructor(nativeElement) {
                    this.nativeElement = nativeElement;
                }
            }
            ElementRef2.__NG_ELEMENT_ID__ = injectElementRef;
            return ElementRef2;
        })();
        function unwrapElementRef(value) {
            return value instanceof core_ElementRef ? value.nativeElement : value;
        }
        const Renderer2Interceptor = new InjectionToken("Renderer2Interceptor");
        class RendererFactory2 {}
        let core_Renderer2 = (() => {
            class Renderer22 {}
            Renderer22.__NG_ELEMENT_ID__ = () => injectRenderer2();
            return Renderer22;
        })();
        function injectRenderer2() {
            const lView = getLView();
            const tNode = getCurrentTNode();
            const nodeAtIndex = getComponentLViewByIndex(tNode.index, lView);
            return (isLView(nodeAtIndex) ? nodeAtIndex : lView)[RENDERER];
        }
        let Sanitizer = (() => {
            class Sanitizer2 {}
            Sanitizer2.prov = defineInjectable({
                token: Sanitizer2,
                providedIn: "root",
                factory: () => null
            });
            return Sanitizer2;
        })();
        class Version {
            constructor(full) {
                this.full = full;
                this.major = full.split(".")[0];
                this.minor = full.split(".")[1];
                this.patch = full.split(".").slice(2).join(".");
            }
        }
        const VERSION = new Version("14.3.0");
        const NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR = {};
        const ERROR_ORIGINAL_ERROR = "ngOriginalError";
        function wrappedError(message, originalError) {
            const msg = `${message} caused by: ${originalError instanceof Error ? originalError.message : originalError}`;
            const error = Error(msg);
            error[ERROR_ORIGINAL_ERROR] = originalError;
            return error;
        }
        function getOriginalError(error) {
            return error[ERROR_ORIGINAL_ERROR];
        }
        class ErrorHandler {
            constructor() {
                this._console = console;
            }
            handleError(error) {
                const originalError = this._findOriginalError(error);
                this._console.error("ERROR", error);
                if (originalError) {
                    this._console.error("ORIGINAL ERROR", originalError);
                }
            }
            _findOriginalError(error) {
                let e = error && getOriginalError(error);
                while (e && getOriginalError(e)) {
                    e = getOriginalError(e);
                }
                return e || null;
            }
        }
        function normalizeDebugBindingName(name) {
            name = camelCaseToDashCase(name.replace(/[$@]/g, "_"));
            return `ng-reflect-${name}`;
        }
        const CAMEL_CASE_REGEXP = /([A-Z])/g;
        function camelCaseToDashCase(input) {
            return input.replace(CAMEL_CASE_REGEXP, (...m) => "-" + m[1].toLowerCase());
        }
        function normalizeDebugBindingValue(value) {
            try {
                return value != null ? value.toString().slice(0, 30) : value;
            } catch (e) {
                return "[ERROR] Exception while trying to serialize the value";
            }
        }
        function resolveWindow(element) {
            return element.ownerDocument.defaultView;
        }
        function resolveDocument(element) {
            return element.ownerDocument;
        }
        function resolveBody(element) {
            return element.ownerDocument.body;
        }
        const INTERPOLATION_DELIMITER = ``;
        function maybeUnwrapFn(value) {
            if (value instanceof Function) {
                return value();
            } else {
                return value;
            }
        }
        function assertStandaloneComponentType(type) {
            assertComponentDef(type);
            const componentDef = getComponentDef(type);
            if (!componentDef.standalone) {
                throw new RuntimeError(907, `The ${stringifyForError(type)} component is not marked as standalone, but Angular expects to have a standalone component here. Please make sure the ${stringifyForError(type)} component has the \`standalone: true\` flag in the decorator.`);
            }
        }
        function assertComponentDef(type) {
            if (!getComponentDef(type)) {
                throw new RuntimeError(906, `The ${stringifyForError(type)} is not an Angular component, make sure it has the \`@Component\` decorator.`);
            }
        }
        function throwMultipleComponentError(tNode, first2, second) {
            throw new RuntimeError(-300, `Multiple components match node with tagname ${tNode.value}: ${stringifyForError(first2)} and ${stringifyForError(second)}`);
        }
        function throwErrorIfNoChangesMode(creationMode, oldValue, currValue, propName) {
            const field = propName ? ` for '${propName}'` : "";
            let msg = `ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value${field}: '${oldValue}'. Current value: '${currValue}'.`;
            if (creationMode) {
                msg += ` It seems like the view has been created after its parent and its children have been dirty checked. Has it been created in a change detection hook?`;
            }
            throw new RuntimeError(-100, msg);
        }
        function constructDetailsForInterpolation(lView, rootIndex, expressionIndex, meta, changedValue) {
            const [propName, prefix, ...chunks] = meta.split(INTERPOLATION_DELIMITER);
            let oldValue = prefix, newValue = prefix;
            for (let i = 0; i < chunks.length; i++) {
                const slotIdx = rootIndex + i;
                oldValue += `${lView[slotIdx]}${chunks[i]}`;
                newValue += `${slotIdx === expressionIndex ? changedValue : lView[slotIdx]}${chunks[i]}`;
            }
            return {
                propName,
                oldValue,
                newValue
            };
        }
        function getExpressionChangedErrorDetails(lView, bindingIndex, oldValue, newValue) {
            const tData = lView[TVIEW].data;
            const metadata = tData[bindingIndex];
            if (typeof metadata === "string") {
                if (metadata.indexOf(INTERPOLATION_DELIMITER) > -1) {
                    return constructDetailsForInterpolation(lView, bindingIndex, bindingIndex, metadata, newValue);
                }
                return {
                    propName: metadata,
                    oldValue,
                    newValue
                };
            }
            if (metadata === null) {
                let idx = bindingIndex - 1;
                while (typeof tData[idx] !== "string" && tData[idx + 1] === null) {
                    idx--;
                }
                const meta = tData[idx];
                if (typeof meta === "string") {
                    const matches = meta.match(new RegExp(INTERPOLATION_DELIMITER, "g"));
                    if (matches && matches.length - 1 > bindingIndex - idx) {
                        return constructDetailsForInterpolation(lView, idx, bindingIndex, meta, newValue);
                    }
                }
            }
            return {
                propName: void 0,
                oldValue,
                newValue
            };
        }
        function classIndexOf(className, classToSearch, startingIndex) {
            let end = className.length;
            while (true) {
                const foundIndex = className.indexOf(classToSearch, startingIndex);
                if (foundIndex === -1) {
                    return foundIndex;
                }
                if (foundIndex === 0 || className.charCodeAt(foundIndex - 1) <= 32) {
                    const length = classToSearch.length;
                    if (foundIndex + length === end || className.charCodeAt(foundIndex + length) <= 32) {
                        return foundIndex;
                    }
                }
                startingIndex = foundIndex + 1;
            }
        }
        const unusedValueToPlacateAjd$1 = unusedValueExportToPlacateAjd$5 + unusedValueExportToPlacateAjd$4;
        const NG_TEMPLATE_SELECTOR = "ng-template";
        function isCssClassMatching(attrs, cssClassToMatch, isProjectionMode) {
            let i = 0;
            while (i < attrs.length) {
                let item = attrs[i++];
                if (isProjectionMode && item === "class") {
                    item = attrs[i];
                    if (classIndexOf(item.toLowerCase(), cssClassToMatch, 0) !== -1) {
                        return true;
                    }
                } else if (item === 1) {
                    while (i < attrs.length && typeof (item = attrs[i++]) == "string") {
                        if (item.toLowerCase() === cssClassToMatch) {
                            return true;
                        }
                    }
                    return false;
                }
            }
            return false;
        }
        function isInlineTemplate(tNode) {
            return tNode.type === 4 && tNode.value !== NG_TEMPLATE_SELECTOR;
        }
        function hasTagAndTypeMatch(tNode, currentSelector, isProjectionMode) {
            const tagNameToCompare = tNode.type === 4 && !isProjectionMode ? NG_TEMPLATE_SELECTOR : tNode.value;
            return currentSelector === tagNameToCompare;
        }
        function isNodeMatchingSelector(tNode, selector, isProjectionMode) {
            let mode = 4;
            const nodeAttrs = tNode.attrs || [];
            const nameOnlyMarkerIdx = getNameOnlyMarkerIndex(nodeAttrs);
            let skipToNextSelector = false;
            for (let i = 0; i < selector.length; i++) {
                const current = selector[i];
                if (typeof current === "number") {
                    if (!skipToNextSelector && !isPositive(mode) && !isPositive(current)) {
                        return false;
                    }
                    if (skipToNextSelector && isPositive(current)) {
                        continue;
                    }
                    skipToNextSelector = false;
                    mode = current | mode & 1;
                    continue;
                }
                if (skipToNextSelector) {
                    continue;
                }
                if (mode & 4) {
                    mode = 2 | mode & 1;
                    if (current !== "" && !hasTagAndTypeMatch(tNode, current, isProjectionMode) || current === "" && selector.length === 1) {
                        if (isPositive(mode)) {
                            return false;
                        }
                        skipToNextSelector = true;
                    }
                } else {
                    const selectorAttrValue = mode & 8 ? current : selector[++i];
                    if (mode & 8 && tNode.attrs !== null) {
                        if (!isCssClassMatching(tNode.attrs, selectorAttrValue, isProjectionMode)) {
                            if (isPositive(mode)) {
                                return false;
                            }
                            skipToNextSelector = true;
                        }
                        continue;
                    }
                    const attrName = mode & 8 ? "class" : current;
                    const attrIndexInNode = findAttrIndexInNode(attrName, nodeAttrs, isInlineTemplate(tNode), isProjectionMode);
                    if (attrIndexInNode === -1) {
                        if (isPositive(mode)) {
                            return false;
                        }
                        skipToNextSelector = true;
                        continue;
                    }
                    if (selectorAttrValue !== "") {
                        let nodeAttrValue;
                        if (attrIndexInNode > nameOnlyMarkerIdx) {
                            nodeAttrValue = "";
                        } else {
                            nodeAttrValue = nodeAttrs[attrIndexInNode + 1].toLowerCase();
                        }
                        const compareAgainstClassName = mode & 8 ? nodeAttrValue : null;
                        if (compareAgainstClassName && classIndexOf(compareAgainstClassName, selectorAttrValue, 0) !== -1 || mode & 2 && selectorAttrValue !== nodeAttrValue) {
                            if (isPositive(mode)) {
                                return false;
                            }
                            skipToNextSelector = true;
                        }
                    }
                }
            }
            return isPositive(mode) || skipToNextSelector;
        }
        function isPositive(mode) {
            return (mode & 1) === 0;
        }
        function findAttrIndexInNode(name, attrs, isInlineTemplate2, isProjectionMode) {
            if (attrs === null) {
                return -1;
            }
            let i = 0;
            if (isProjectionMode || !isInlineTemplate2) {
                let bindingsMode = false;
                while (i < attrs.length) {
                    const maybeAttrName = attrs[i];
                    if (maybeAttrName === name) {
                        return i;
                    } else if (maybeAttrName === 3 || maybeAttrName === 6) {
                        bindingsMode = true;
                    } else if (maybeAttrName === 1 || maybeAttrName === 2) {
                        let value = attrs[++i];
                        while (typeof value === "string") {
                            value = attrs[++i];
                        }
                        continue;
                    } else if (maybeAttrName === 4) {
                        break;
                    } else if (maybeAttrName === 0) {
                        i += 4;
                        continue;
                    }
                    i += bindingsMode ? 1 : 2;
                }
                return -1;
            } else {
                return matchTemplateAttribute(attrs, name);
            }
        }
        function isNodeMatchingSelectorList(tNode, selector, isProjectionMode = false) {
            for (let i = 0; i < selector.length; i++) {
                if (isNodeMatchingSelector(tNode, selector[i], isProjectionMode)) {
                    return true;
                }
            }
            return false;
        }
        function getProjectAsAttrValue(tNode) {
            const nodeAttrs = tNode.attrs;
            if (nodeAttrs != null) {
                const ngProjectAsAttrIdx = nodeAttrs.indexOf(5);
                if ((ngProjectAsAttrIdx & 1) === 0) {
                    return nodeAttrs[ngProjectAsAttrIdx + 1];
                }
            }
            return null;
        }
        function getNameOnlyMarkerIndex(nodeAttrs) {
            for (let i = 0; i < nodeAttrs.length; i++) {
                const nodeAttr = nodeAttrs[i];
                if (isNameOnlyAttributeMarker(nodeAttr)) {
                    return i;
                }
            }
            return nodeAttrs.length;
        }
        function matchTemplateAttribute(attrs, name) {
            let i = attrs.indexOf(4);
            if (i > -1) {
                i++;
                while (i < attrs.length) {
                    const attr = attrs[i];
                    if (typeof attr === "number") {
                        return -1;
                    }
                    if (attr === name) {
                        return i;
                    }
                    i++;
                }
            }
            return -1;
        }
        function isSelectorInSelectorList(selector, list) {
            selectorListLoop: for (let i = 0; i < list.length; i++) {
                const currentSelectorInList = list[i];
                if (selector.length !== currentSelectorInList.length) {
                    continue;
                }
                for (let j = 0; j < selector.length; j++) {
                    if (selector[j] !== currentSelectorInList[j]) {
                        continue selectorListLoop;
                    }
                }
                return true;
            }
            return false;
        }
        function maybeWrapInNotSelector(isNegativeMode, chunk) {
            return isNegativeMode ? ":not(" + chunk.trim() + ")" : chunk;
        }
        function stringifyCSSSelector(selector) {
            let result = selector[0];
            let i = 1;
            let mode = 2;
            let currentChunk = "";
            let isNegativeMode = false;
            while (i < selector.length) {
                let valueOrMarker = selector[i];
                if (typeof valueOrMarker === "string") {
                    if (mode & 2) {
                        const attrValue = selector[++i];
                        currentChunk += "[" + valueOrMarker + (attrValue.length > 0 ? '="' + attrValue + '"' : "") + "]";
                    } else if (mode & 8) {
                        currentChunk += "." + valueOrMarker;
                    } else if (mode & 4) {
                        currentChunk += " " + valueOrMarker;
                    }
                } else {
                    if (currentChunk !== "" && !isPositive(valueOrMarker)) {
                        result += maybeWrapInNotSelector(isNegativeMode, currentChunk);
                        currentChunk = "";
                    }
                    mode = valueOrMarker;
                    isNegativeMode = isNegativeMode || !isPositive(mode);
                }
                i++;
            }
            if (currentChunk !== "") {
                result += maybeWrapInNotSelector(isNegativeMode, currentChunk);
            }
            return result;
        }
        function stringifyCSSSelectorList(selectorList) {
            return selectorList.map(stringifyCSSSelector).join(",");
        }
        function extractAttrsAndClassesFromSelector(selector) {
            const attrs = [];
            const classes = [];
            let i = 1;
            let mode = 2;
            while (i < selector.length) {
                let valueOrMarker = selector[i];
                if (typeof valueOrMarker === "string") {
                    if (mode === 2) {
                        if (valueOrMarker !== "") {
                            attrs.push(valueOrMarker, selector[++i]);
                        }
                    } else if (mode === 8) {
                        classes.push(valueOrMarker);
                    }
                } else {
                    if (!isPositive(mode)) {
                        break;
                    }
                    mode = valueOrMarker;
                }
                i++;
            }
            return {
                attrs,
                classes
            };
        }
        const NO_CHANGE = false ? {
            __brand__: "NO_CHANGE"
        } : {};
        function advance(delta) {
            selectIndexInternal(getTView(), getLView(), getSelectedIndex() + delta, false);
        }
        function selectIndexInternal(tView, lView, index, checkNoChangesMode) {
            if (!checkNoChangesMode) {
                const hooksInitPhaseCompleted = (lView[FLAGS] & 3) === 3;
                if (hooksInitPhaseCompleted) {
                    const preOrderCheckHooks = tView.preOrderCheckHooks;
                    if (preOrderCheckHooks !== null) {
                        executeCheckHooks(lView, preOrderCheckHooks, index);
                    }
                } else {
                    const preOrderHooks = tView.preOrderHooks;
                    if (preOrderHooks !== null) {
                        executeInitAndCheckHooks(lView, preOrderHooks, 0, index);
                    }
                }
            }
            setSelectedIndex(index);
        }
        const angularCoreDiEnv = {
            defineInjectable,
            defineInjector,
            inject: core_inject,
            invalidFactoryDep,
            resolveForwardRef
        };
        function compileInjectable(type, meta) {
            let ngInjectableDef = null;
            let ngFactoryDef = null;
            if (!type.hasOwnProperty(NG_PROV_DEF)) {
                Object.defineProperty(type, NG_PROV_DEF, {
                    get: () => {
                        if (ngInjectableDef === null) {
                            const compiler = getCompilerFacade({
                                usage: 0,
                                kind: "injectable",
                                type
                            });
                            ngInjectableDef = compiler.compileInjectable(angularCoreDiEnv, `ng:///${type.name}/prov.js`, getInjectableMetadata(type, meta));
                        }
                        return ngInjectableDef;
                    }
                });
            }
            if (!type.hasOwnProperty(NG_FACTORY_DEF)) {
                Object.defineProperty(type, NG_FACTORY_DEF, {
                    get: () => {
                        if (ngFactoryDef === null) {
                            const compiler = getCompilerFacade({
                                usage: 0,
                                kind: "injectable",
                                type
                            });
                            ngFactoryDef = compiler.compileFactory(angularCoreDiEnv, `ng:///${type.name}/fac.js`, {
                                name: type.name,
                                type,
                                typeArgumentCount: 0,
                                deps: reflectDependencies(type),
                                target: compiler.FactoryTarget.Injectable
                            });
                        }
                        return ngFactoryDef;
                    },
                    configurable: true
                });
            }
        }
        const USE_VALUE = getClosureSafeProperty({
            provide: String,
            useValue: getClosureSafeProperty
        });
        function isUseClassProvider(meta) {
            return meta.useClass !== void 0;
        }
        function isUseValueProvider(meta) {
            return USE_VALUE in meta;
        }
        function isUseFactoryProvider(meta) {
            return meta.useFactory !== void 0;
        }
        function isUseExistingProvider(meta) {
            return meta.useExisting !== void 0;
        }
        function getInjectableMetadata(type, srcMeta) {
            const meta = srcMeta || {
                providedIn: null
            };
            const compilerMeta = {
                name: type.name,
                type,
                typeArgumentCount: 0,
                providedIn: meta.providedIn
            };
            if ((isUseClassProvider(meta) || isUseFactoryProvider(meta)) && meta.deps !== void 0) {
                compilerMeta.deps = convertDependencies(meta.deps);
            }
            if (isUseClassProvider(meta)) {
                compilerMeta.useClass = meta.useClass;
            } else if (isUseValueProvider(meta)) {
                compilerMeta.useValue = meta.useValue;
            } else if (isUseFactoryProvider(meta)) {
                compilerMeta.useFactory = meta.useFactory;
            } else if (isUseExistingProvider(meta)) {
                compilerMeta.useExisting = meta.useExisting;
            }
            return compilerMeta;
        }
        const Injectable = makeDecorator("Injectable", void 0, void 0, void 0, (type, meta) => compileInjectable(type, meta));
        function createInjector(defType, parent = null, additionalProviders = null, name) {
            const injector = createInjectorWithoutInjectorInstances(defType, parent, additionalProviders, name);
            injector.resolveInjectorInitializers();
            return injector;
        }
        function createInjectorWithoutInjectorInstances(defType, parent = null, additionalProviders = null, name, scopes = new Set) {
            const providers = [ additionalProviders || EMPTY_ARRAY, importProvidersFrom(defType) ];
            name = name || (typeof defType === "object" ? void 0 : stringify(defType));
            return new R3Injector(providers, parent || getNullInjector(), name || null, scopes);
        }
        let core_Injector = (() => {
            class Injector2 {
                static create(options, parent) {
                    if (Array.isArray(options)) {
                        return createInjector({
                            name: ""
                        }, parent, options, "");
                    } else {
                        const name = options.name ?? "";
                        return createInjector({
                            name
                        }, options.parent, options.providers, name);
                    }
                }
            }
            Injector2.THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND;
            Injector2.NULL = new NullInjector;
            Injector2.prov = defineInjectable({
                token: Injector2,
                providedIn: "any",
                factory: () => core_inject(INJECTOR)
            });
            Injector2.__NG_ELEMENT_ID__ = -1;
            return Injector2;
        })();
        function findFirstClosedCycle(keys) {
            const res = [];
            for (let i = 0; i < keys.length; ++i) {
                if (res.indexOf(keys[i]) > -1) {
                    res.push(keys[i]);
                    return res;
                }
                res.push(keys[i]);
            }
            return res;
        }
        function constructResolvingPath(keys) {
            if (keys.length > 1) {
                const reversed = findFirstClosedCycle(keys.slice().reverse());
                const tokenStrs = reversed.map(k => stringify(k.token));
                return " (" + tokenStrs.join(" -> ") + ")";
            }
            return "";
        }
        function injectionError(injector, key, constructResolvingMessage, originalError) {
            const keys = [ key ];
            const errMsg = constructResolvingMessage(keys);
            const error = originalError ? wrappedError(errMsg, originalError) : Error(errMsg);
            error.addKey = addKey;
            error.keys = keys;
            error.injectors = [ injector ];
            error.constructResolvingMessage = constructResolvingMessage;
            error[ERROR_ORIGINAL_ERROR] = originalError;
            return error;
        }
        function addKey(injector, key) {
            this.injectors.push(injector);
            this.keys.push(key);
            this.message = this.constructResolvingMessage(this.keys);
        }
        function noProviderError(injector, key) {
            return injectionError(injector, key, function(keys) {
                const first2 = stringify(keys[0].token);
                return `No provider for ${first2}!${constructResolvingPath(keys)}`;
            });
        }
        function cyclicDependencyError(injector, key) {
            return injectionError(injector, key, function(keys) {
                return `Cannot instantiate cyclic dependency!${constructResolvingPath(keys)}`;
            });
        }
        function instantiationError(injector, originalException, originalStack, key) {
            return injectionError(injector, key, function(keys) {
                const first2 = stringify(keys[0].token);
                return `${originalException.message}: Error during instantiation of ${first2}!${constructResolvingPath(keys)}.`;
            }, originalException);
        }
        function invalidProviderError(provider) {
            return Error(`Invalid provider - only instances of Provider and Type are allowed, got: ${provider}`);
        }
        function noAnnotationError(typeOrFunc, params) {
            const signature = [];
            for (let i = 0, ii = params.length; i < ii; i++) {
                const parameter = params[i];
                if (!parameter || parameter.length == 0) {
                    signature.push("?");
                } else {
                    signature.push(parameter.map(stringify).join(" "));
                }
            }
            return Error("Cannot resolve all parameters for '" + stringify(typeOrFunc) + "'(" + signature.join(", ") + "). Make sure that all the parameters are decorated with Inject or have valid type annotations and that '" + stringify(typeOrFunc) + "' is decorated with Injectable.");
        }
        function outOfBoundsError(index) {
            return Error(`Index ${index} is out-of-bounds.`);
        }
        function mixingMultiProvidersWithRegularProvidersError(provider1, provider2) {
            return Error(`Cannot mix multi providers and regular providers, got: ${provider1} ${provider2}`);
        }
        class ReflectiveKey {
            constructor(token, id) {
                this.token = token;
                this.id = id;
                if (!token) {
                    throw new RuntimeError(208, false);
                }
                this.displayName = stringify(this.token);
            }
            static get(token) {
                return _globalKeyRegistry.get(resolveForwardRef(token));
            }
            static get numberOfKeys() {
                return _globalKeyRegistry.numberOfKeys;
            }
        }
        class KeyRegistry {
            constructor() {
                this._allKeys = new Map;
            }
            get(token) {
                if (token instanceof ReflectiveKey) {
                    return token;
                }
                if (this._allKeys.has(token)) {
                    return this._allKeys.get(token);
                }
                const newKey = new ReflectiveKey(token, ReflectiveKey.numberOfKeys);
                this._allKeys.set(token, newKey);
                return newKey;
            }
            get numberOfKeys() {
                return this._allKeys.size;
            }
        }
        const _globalKeyRegistry = new KeyRegistry;
        class ReflectiveDependency {
            constructor(key, optional, visibility) {
                this.key = key;
                this.optional = optional;
                this.visibility = visibility;
            }
            static fromKey(key) {
                return new ReflectiveDependency(key, false, null);
            }
        }
        const _EMPTY_LIST = null;
        class ResolvedReflectiveProvider_ {
            constructor(key, resolvedFactories, multiProvider) {
                this.key = key;
                this.resolvedFactories = resolvedFactories;
                this.multiProvider = multiProvider;
                this.resolvedFactory = this.resolvedFactories[0];
            }
        }
        class ResolvedReflectiveFactory {
            constructor(factory, dependencies) {
                this.factory = factory;
                this.dependencies = dependencies;
            }
        }
        function resolveReflectiveFactory(provider) {
            let factoryFn;
            let resolvedDeps;
            if (provider.useClass) {
                const useClass = resolveForwardRef(provider.useClass);
                factoryFn = getReflect().factory(useClass);
                resolvedDeps = _dependenciesFor(useClass);
            } else if (provider.useExisting) {
                factoryFn = aliasInstance => aliasInstance;
                resolvedDeps = [ ReflectiveDependency.fromKey(ReflectiveKey.get(provider.useExisting)) ];
            } else if (provider.useFactory) {
                factoryFn = provider.useFactory;
                resolvedDeps = constructDependencies(provider.useFactory, provider.deps);
            } else {
                factoryFn = () => provider.useValue;
                resolvedDeps = _EMPTY_LIST;
            }
            return new ResolvedReflectiveFactory(factoryFn, resolvedDeps);
        }
        function resolveReflectiveProvider(provider) {
            return new ResolvedReflectiveProvider_(ReflectiveKey.get(provider.provide), [ resolveReflectiveFactory(provider) ], provider.multi || false);
        }
        function resolveReflectiveProviders(providers) {
            const normalized = _normalizeProviders(providers, []);
            const resolved = normalized.map(resolveReflectiveProvider);
            const resolvedProviderMap = mergeResolvedReflectiveProviders(resolved, new Map);
            return Array.from(resolvedProviderMap.values());
        }
        function mergeResolvedReflectiveProviders(providers, normalizedProvidersMap) {
            for (let i = 0; i < providers.length; i++) {
                const provider = providers[i];
                const existing = normalizedProvidersMap.get(provider.key.id);
                if (existing) {
                    if (provider.multiProvider !== existing.multiProvider) {
                        throw mixingMultiProvidersWithRegularProvidersError(existing, provider);
                    }
                    if (provider.multiProvider) {
                        for (let j = 0; j < provider.resolvedFactories.length; j++) {
                            existing.resolvedFactories.push(provider.resolvedFactories[j]);
                        }
                    } else {
                        normalizedProvidersMap.set(provider.key.id, provider);
                    }
                } else {
                    let resolvedProvider;
                    if (provider.multiProvider) {
                        resolvedProvider = new ResolvedReflectiveProvider_(provider.key, provider.resolvedFactories.slice(), provider.multiProvider);
                    } else {
                        resolvedProvider = provider;
                    }
                    normalizedProvidersMap.set(provider.key.id, resolvedProvider);
                }
            }
            return normalizedProvidersMap;
        }
        function _normalizeProviders(providers, res) {
            providers.forEach(b => {
                if (b instanceof Type) {
                    res.push({
                        provide: b,
                        useClass: b
                    });
                } else if (b && typeof b == "object" && b.provide !== void 0) {
                    res.push(b);
                } else if (Array.isArray(b)) {
                    _normalizeProviders(b, res);
                } else {
                    throw invalidProviderError(b);
                }
            });
            return res;
        }
        function constructDependencies(typeOrFunc, dependencies) {
            if (!dependencies) {
                return _dependenciesFor(typeOrFunc);
            } else {
                const params = dependencies.map(t => [ t ]);
                return dependencies.map(t => _extractToken(typeOrFunc, t, params));
            }
        }
        function _dependenciesFor(typeOrFunc) {
            const params = getReflect().parameters(typeOrFunc);
            if (!params) {
                return [];
            }
            if (params.some(p => p == null)) {
                throw noAnnotationError(typeOrFunc, params);
            }
            return params.map(p => _extractToken(typeOrFunc, p, params));
        }
        function _extractToken(typeOrFunc, metadata, params) {
            let token = null;
            let optional = false;
            if (!Array.isArray(metadata)) {
                if (metadata instanceof Inject) {
                    return _createDependency(metadata.token, optional, null);
                } else {
                    return _createDependency(metadata, optional, null);
                }
            }
            let visibility = null;
            for (let i = 0; i < metadata.length; ++i) {
                const paramMetadata = metadata[i];
                if (paramMetadata instanceof Type) {
                    token = paramMetadata;
                } else if (paramMetadata instanceof Inject) {
                    token = paramMetadata.token;
                } else if (paramMetadata instanceof core_Optional) {
                    optional = true;
                } else if (paramMetadata instanceof Self || paramMetadata instanceof SkipSelf) {
                    visibility = paramMetadata;
                } else if (paramMetadata instanceof InjectionToken) {
                    token = paramMetadata;
                }
            }
            token = resolveForwardRef(token);
            if (token != null) {
                return _createDependency(token, optional, visibility);
            } else {
                throw noAnnotationError(typeOrFunc, params);
            }
        }
        function _createDependency(token, optional, visibility) {
            return new ReflectiveDependency(ReflectiveKey.get(token), optional, visibility);
        }
        const UNDEFINED = {};
        class ReflectiveInjector {
            static resolve(providers) {
                return resolveReflectiveProviders(providers);
            }
            static resolveAndCreate(providers, parent) {
                const ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);
                return ReflectiveInjector.fromResolvedProviders(ResolvedReflectiveProviders, parent);
            }
            static fromResolvedProviders(providers, parent) {
                return new ReflectiveInjector_(providers, parent);
            }
        }
        let ReflectiveInjector_ = null;
        function _mapProviders(injector, fn) {
            const res = [];
            for (let i = 0; i < injector._providers.length; ++i) {
                res[i] = fn(injector.getProviderAtIndex(i));
            }
            return res;
        }
        function directiveInject(token, flags = InjectFlags.Default) {
            const lView = getLView();
            if (lView === null) {
                return core_inject(token, flags);
            }
            const tNode = getCurrentTNode();
            return getOrCreateInjectable(tNode, lView, resolveForwardRef(token), flags);
        }
        function invalidFactory() {
            const msg = false ? `This constructor was not compatible with Dependency Injection.` : "invalid";
            throw new Error(msg);
        }
        function createNamedArrayType(name) {
            if (false) {
                try {
                    return newTrustedFunctionForDev("Array", `return class ${name} extends Array{}`)(Array);
                } catch (e) {
                    return Array;
                }
            } else {
                throw new Error("Looks like we are in 'prod mode', but we are creating a named Array type, which is wrong! Check your code");
            }
        }
        function toTStylingRange(prev, next) {
            return prev << 17 | next << 2;
        }
        function getTStylingRangePrev(tStylingRange) {
            return tStylingRange >> 17 & 32767;
        }
        function getTStylingRangePrevDuplicate(tStylingRange) {
            return (tStylingRange & 2) == 2;
        }
        function setTStylingRangePrev(tStylingRange, previous) {
            return tStylingRange & ~4294836224 | previous << 17;
        }
        function setTStylingRangePrevDuplicate(tStylingRange) {
            return tStylingRange | 2;
        }
        function getTStylingRangeNext(tStylingRange) {
            return (tStylingRange & 131068) >> 2;
        }
        function setTStylingRangeNext(tStylingRange, next) {
            return tStylingRange & ~131068 | next << 2;
        }
        function getTStylingRangeNextDuplicate(tStylingRange) {
            return (tStylingRange & 1) === 1;
        }
        function setTStylingRangeNextDuplicate(tStylingRange) {
            return tStylingRange | 1;
        }
        function getTStylingRangeTail(tStylingRange) {
            const next = getTStylingRangeNext(tStylingRange);
            return next === 0 ? getTStylingRangePrev(tStylingRange) : next;
        }
        function attachDebugObject(obj, debug) {
            if (false) {
                Object.defineProperty(obj, "debug", {
                    value: debug,
                    enumerable: false
                });
            } else {
                throw new Error("This method should be guarded with `ngDevMode` so that it can be tree shaken in production!");
            }
        }
        function attachDebugGetter(obj, debugGetter) {
            if (false) {
                Object.defineProperty(obj, "debug", {
                    get: debugGetter,
                    enumerable: false
                });
            } else {
                throw new Error("This method should be guarded with `ngDevMode` so that it can be tree shaken in production!");
            }
        }
        let LVIEW_COMPONENT_CACHE;
        let LVIEW_EMBEDDED_CACHE;
        let LVIEW_ROOT;
        let LVIEW_COMPONENT;
        let LVIEW_EMBEDDED;
        function cloneToLViewFromTViewBlueprint(tView) {
            const debugTView = tView;
            const lView = getLViewToClone(debugTView.type, tView.template && tView.template.name);
            return lView.concat(tView.blueprint);
        }
        class LRootView extends Array {}
        class LComponentView extends Array {}
        class LEmbeddedView extends Array {}
        function getLViewToClone(type, name) {
            switch (type) {
              case 0:
                if (LVIEW_ROOT === void 0) {
                    LVIEW_ROOT = new LRootView;
                }
                return LVIEW_ROOT;

              case 1:
                if (true) {
                    if (LVIEW_COMPONENT === void 0) {
                        LVIEW_COMPONENT = new LComponentView;
                    }
                    return LVIEW_COMPONENT;
                }
                if (LVIEW_COMPONENT_CACHE === void 0) {
                    LVIEW_COMPONENT_CACHE = new Map;
                }
                let componentArray = LVIEW_COMPONENT_CACHE.get(name);
                if (componentArray === void 0) {
                    componentArray = new (createNamedArrayType("LComponentView" + nameSuffix(name)));
                    LVIEW_COMPONENT_CACHE.set(name, componentArray);
                }
                return componentArray;

              case 2:
                if (true) {
                    if (LVIEW_EMBEDDED === void 0) {
                        LVIEW_EMBEDDED = new LEmbeddedView;
                    }
                    return LVIEW_EMBEDDED;
                }
                if (LVIEW_EMBEDDED_CACHE === void 0) {
                    LVIEW_EMBEDDED_CACHE = new Map;
                }
                let embeddedArray = LVIEW_EMBEDDED_CACHE.get(name);
                if (embeddedArray === void 0) {
                    embeddedArray = new (createNamedArrayType("LEmbeddedView" + nameSuffix(name)));
                    LVIEW_EMBEDDED_CACHE.set(name, embeddedArray);
                }
                return embeddedArray;
            }
        }
        function nameSuffix(text) {
            if (text == null) {
                return "";
            }
            const index = text.lastIndexOf("_Template");
            return "_" + (index === -1 ? text : text.slice(0, index));
        }
        const TViewConstructor = class TView {
            constructor(type, blueprint, template, queries, viewQuery, declTNode, data, bindingStartIndex, expandoStartIndex, hostBindingOpCodes, firstCreatePass, firstUpdatePass, staticViewQueries, staticContentQueries, preOrderHooks, preOrderCheckHooks, contentHooks, contentCheckHooks, viewHooks, viewCheckHooks, destroyHooks, cleanup, contentQueries, components, directiveRegistry, pipeRegistry, firstChild, schemas, consts, incompleteFirstPass, _decls, _vars) {
                this.type = type;
                this.blueprint = blueprint;
                this.template = template;
                this.queries = queries;
                this.viewQuery = viewQuery;
                this.declTNode = declTNode;
                this.data = data;
                this.bindingStartIndex = bindingStartIndex;
                this.expandoStartIndex = expandoStartIndex;
                this.hostBindingOpCodes = hostBindingOpCodes;
                this.firstCreatePass = firstCreatePass;
                this.firstUpdatePass = firstUpdatePass;
                this.staticViewQueries = staticViewQueries;
                this.staticContentQueries = staticContentQueries;
                this.preOrderHooks = preOrderHooks;
                this.preOrderCheckHooks = preOrderCheckHooks;
                this.contentHooks = contentHooks;
                this.contentCheckHooks = contentCheckHooks;
                this.viewHooks = viewHooks;
                this.viewCheckHooks = viewCheckHooks;
                this.destroyHooks = destroyHooks;
                this.cleanup = cleanup;
                this.contentQueries = contentQueries;
                this.components = components;
                this.directiveRegistry = directiveRegistry;
                this.pipeRegistry = pipeRegistry;
                this.firstChild = firstChild;
                this.schemas = schemas;
                this.consts = consts;
                this.incompleteFirstPass = incompleteFirstPass;
                this._decls = _decls;
                this._vars = _vars;
            }
            get template_() {
                const buf = [];
                processTNodeChildren(this.firstChild, buf);
                return buf.join("");
            }
            get type_() {
                return TViewTypeAsString[this.type] || `TViewType.?${this.type}?`;
            }
        };
        class TNode {
            constructor(tView_, type, index, insertBeforeIndex, injectorIndex, directiveStart, directiveEnd, directiveStylingLast, propertyBindings, flags, providerIndexes, value, attrs, mergedAttrs, localNames, initialInputs, inputs, outputs, tViews, next, projectionNext, child, parent, projection, styles, stylesWithoutHost, residualStyles, classes, classesWithoutHost, residualClasses, classBindings, styleBindings) {
                this.tView_ = tView_;
                this.type = type;
                this.index = index;
                this.insertBeforeIndex = insertBeforeIndex;
                this.injectorIndex = injectorIndex;
                this.directiveStart = directiveStart;
                this.directiveEnd = directiveEnd;
                this.directiveStylingLast = directiveStylingLast;
                this.propertyBindings = propertyBindings;
                this.flags = flags;
                this.providerIndexes = providerIndexes;
                this.value = value;
                this.attrs = attrs;
                this.mergedAttrs = mergedAttrs;
                this.localNames = localNames;
                this.initialInputs = initialInputs;
                this.inputs = inputs;
                this.outputs = outputs;
                this.tViews = tViews;
                this.next = next;
                this.projectionNext = projectionNext;
                this.child = child;
                this.parent = parent;
                this.projection = projection;
                this.styles = styles;
                this.stylesWithoutHost = stylesWithoutHost;
                this.residualStyles = residualStyles;
                this.classes = classes;
                this.classesWithoutHost = classesWithoutHost;
                this.residualClasses = residualClasses;
                this.classBindings = classBindings;
                this.styleBindings = styleBindings;
            }
            debugNodeInjectorPath(lView) {
                const path = [];
                let injectorIndex = getInjectorIndex(this, lView);
                if (injectorIndex === -1) {
                    const parentLocation = getParentInjectorLocation(this, lView);
                    if (parentLocation !== NO_PARENT_INJECTOR) {
                        injectorIndex = getParentInjectorIndex(parentLocation);
                        lView = getParentInjectorView(parentLocation, lView);
                    } else {}
                }
                while (injectorIndex !== -1) {
                    const tNode = lView[TVIEW].data[injectorIndex + 8];
                    path.push(buildDebugNode(tNode, lView));
                    const parentLocation = lView[injectorIndex + 8];
                    if (parentLocation === NO_PARENT_INJECTOR) {
                        injectorIndex = -1;
                    } else {
                        injectorIndex = getParentInjectorIndex(parentLocation);
                        lView = getParentInjectorView(parentLocation, lView);
                    }
                }
                return path;
            }
            get type_() {
                return toTNodeTypeAsString(this.type) || `TNodeType.?${this.type}?`;
            }
            get flags_() {
                const flags = [];
                if (this.flags & 16) {
                    flags.push("TNodeFlags.hasClassInput");
                }
                if (this.flags & 8) {
                    flags.push("TNodeFlags.hasContentQuery");
                }
                if (this.flags & 32) {
                    flags.push("TNodeFlags.hasStyleInput");
                }
                if (this.flags & 128) {
                    flags.push("TNodeFlags.hasHostBindings");
                }
                if (this.flags & 2) {
                    flags.push("TNodeFlags.isComponentHost");
                }
                if (this.flags & 1) {
                    flags.push("TNodeFlags.isDirectiveHost");
                }
                if (this.flags & 64) {
                    flags.push("TNodeFlags.isDetached");
                }
                if (this.flags & 4) {
                    flags.push("TNodeFlags.isProjected");
                }
                return flags.join("|");
            }
            get template_() {
                if (this.type & 1) {
                    return this.value;
                }
                const buf = [];
                const tagName = typeof this.value === "string" && this.value || this.type_;
                buf.push("<", tagName);
                if (this.flags) {
                    buf.push(" ", this.flags_);
                }
                if (this.attrs) {
                    for (let i = 0; i < this.attrs.length; ) {
                        const attrName = this.attrs[i++];
                        if (typeof attrName == "number") {
                            break;
                        }
                        const attrValue = this.attrs[i++];
                        buf.push(" ", attrName, '="', attrValue, '"');
                    }
                }
                buf.push(">");
                processTNodeChildren(this.child, buf);
                buf.push("</", tagName, ">");
                return buf.join("");
            }
            get styleBindings_() {
                return toDebugStyleBinding(this, false);
            }
            get classBindings_() {
                return toDebugStyleBinding(this, true);
            }
            get providerIndexStart_() {
                return this.providerIndexes & 1048575;
            }
            get providerIndexEnd_() {
                return this.providerIndexStart_ + (this.providerIndexes >>> 20);
            }
        }
        const TNodeDebug = TNode;
        function toDebugStyleBinding(tNode, isClassBased) {
            const tData = tNode.tView_.data;
            const bindings = [];
            const range = isClassBased ? tNode.classBindings : tNode.styleBindings;
            const prev = getTStylingRangePrev(range);
            const next = getTStylingRangeNext(range);
            let isTemplate = next !== 0;
            let cursor = isTemplate ? next : prev;
            while (cursor !== 0) {
                const itemKey = tData[cursor];
                const itemRange = tData[cursor + 1];
                bindings.unshift({
                    key: itemKey,
                    index: cursor,
                    isTemplate,
                    prevDuplicate: getTStylingRangePrevDuplicate(itemRange),
                    nextDuplicate: getTStylingRangeNextDuplicate(itemRange),
                    nextIndex: getTStylingRangeNext(itemRange),
                    prevIndex: getTStylingRangePrev(itemRange)
                });
                if (cursor === prev) {
                    isTemplate = false;
                }
                cursor = getTStylingRangePrev(itemRange);
            }
            bindings.push((isClassBased ? tNode.residualClasses : tNode.residualStyles) || null);
            return bindings;
        }
        function processTNodeChildren(tNode, buf) {
            while (tNode) {
                buf.push(tNode.template_);
                tNode = tNode.next;
            }
        }
        class TViewData extends Array {}
        let TVIEWDATA_EMPTY;
        function cloneToTViewData(list) {
            if (TVIEWDATA_EMPTY === void 0) {
                TVIEWDATA_EMPTY = new TViewData;
            }
            return TVIEWDATA_EMPTY.concat(list);
        }
        class LViewBlueprint extends Array {}
        class MatchesArray extends Array {}
        class TViewComponents extends Array {}
        class TNodeLocalNames extends Array {}
        class TNodeInitialInputs extends Array {}
        class LCleanup extends Array {}
        class TCleanup extends Array {}
        function attachLViewDebug(lView) {
            attachDebugObject(lView, new LViewDebug(lView));
        }
        function attachLContainerDebug(lContainer) {
            attachDebugObject(lContainer, new LContainerDebug(lContainer));
        }
        function toDebug(obj) {
            if (obj) {
                const debug = obj.debug;
                assertDefined(debug, "Object does not have a debug representation.");
                return debug;
            } else {
                return obj;
            }
        }
        function toHtml(value, includeChildren = false) {
            const node = unwrapRNode(value);
            if (node) {
                switch (node.nodeType) {
                  case Node.TEXT_NODE:
                    return node.textContent;

                  case Node.COMMENT_NODE:
                    return `\x3c!--${node.textContent}--\x3e`;

                  case Node.ELEMENT_NODE:
                    const outerHTML = node.outerHTML;
                    if (includeChildren) {
                        return outerHTML;
                    } else {
                        const innerHTML = ">" + node.innerHTML + "<";
                        return outerHTML.split(innerHTML)[0] + ">";
                    }
                }
            }
            return null;
        }
        class LViewDebug {
            constructor(_raw_lView) {
                this._raw_lView = _raw_lView;
            }
            get flags() {
                const flags = this._raw_lView[FLAGS];
                return {
                    __raw__flags__: flags,
                    initPhaseState: flags & 3,
                    creationMode: !!(flags & 4),
                    firstViewPass: !!(flags & 8),
                    checkAlways: !!(flags & 16),
                    dirty: !!(flags & 32),
                    attached: !!(flags & 64),
                    destroyed: !!(flags & 128),
                    isRoot: !!(flags & 256),
                    indexWithinInitPhase: flags >> 11
                };
            }
            get parent() {
                return toDebug(this._raw_lView[PARENT]);
            }
            get hostHTML() {
                return toHtml(this._raw_lView[HOST], true);
            }
            get html() {
                return (this.nodes || []).map(mapToHTML).join("");
            }
            get context() {
                return this._raw_lView[CONTEXT];
            }
            get nodes() {
                const lView = this._raw_lView;
                const tNode = lView[TVIEW].firstChild;
                return toDebugNodes(tNode, lView);
            }
            get template() {
                return this.tView.template_;
            }
            get tView() {
                return this._raw_lView[TVIEW];
            }
            get cleanup() {
                return this._raw_lView[CLEANUP];
            }
            get injector() {
                return this._raw_lView[INJECTOR$1];
            }
            get rendererFactory() {
                return this._raw_lView[RENDERER_FACTORY];
            }
            get renderer() {
                return this._raw_lView[RENDERER];
            }
            get sanitizer() {
                return this._raw_lView[SANITIZER];
            }
            get childHead() {
                return toDebug(this._raw_lView[CHILD_HEAD]);
            }
            get next() {
                return toDebug(this._raw_lView[NEXT]);
            }
            get childTail() {
                return toDebug(this._raw_lView[CHILD_TAIL]);
            }
            get declarationView() {
                return toDebug(this._raw_lView[DECLARATION_VIEW]);
            }
            get queries() {
                return this._raw_lView[QUERIES];
            }
            get tHost() {
                return this._raw_lView[T_HOST];
            }
            get id() {
                return this._raw_lView[ID];
            }
            get decls() {
                return toLViewRange(this.tView, this._raw_lView, HEADER_OFFSET, this.tView.bindingStartIndex);
            }
            get vars() {
                return toLViewRange(this.tView, this._raw_lView, this.tView.bindingStartIndex, this.tView.expandoStartIndex);
            }
            get expando() {
                return toLViewRange(this.tView, this._raw_lView, this.tView.expandoStartIndex, this._raw_lView.length);
            }
            get childViews() {
                const childViews = [];
                let child = this.childHead;
                while (child) {
                    childViews.push(child);
                    child = child.next;
                }
                return childViews;
            }
        }
        function mapToHTML(node) {
            if (node.type === "ElementContainer") {
                return (node.children || []).map(mapToHTML).join("");
            } else if (node.type === "IcuContainer") {
                throw new Error("Not implemented");
            } else {
                return toHtml(node.native, true) || "";
            }
        }
        function toLViewRange(tView, lView, start, end) {
            let content = [];
            for (let index = start; index < end; index++) {
                content.push({
                    index,
                    t: tView.data[index],
                    l: lView[index]
                });
            }
            return {
                start,
                end,
                length: end - start,
                content
            };
        }
        function toDebugNodes(tNode, lView) {
            if (tNode) {
                const debugNodes = [];
                let tNodeCursor = tNode;
                while (tNodeCursor) {
                    debugNodes.push(buildDebugNode(tNodeCursor, lView));
                    tNodeCursor = tNodeCursor.next;
                }
                return debugNodes;
            } else {
                return [];
            }
        }
        function buildDebugNode(tNode, lView) {
            const rawValue = lView[tNode.index];
            const native = unwrapRNode(rawValue);
            const factories = [];
            const instances = [];
            const tView = lView[TVIEW];
            for (let i = tNode.directiveStart; i < tNode.directiveEnd; i++) {
                const def = tView.data[i];
                factories.push(def.type);
                instances.push(lView[i]);
            }
            return {
                html: toHtml(native),
                type: toTNodeTypeAsString(tNode.type),
                tNode,
                native,
                children: toDebugNodes(tNode.child, lView),
                factories,
                instances,
                injector: buildNodeInjectorDebug(tNode, tView, lView),
                get injectorResolutionPath() {
                    return tNode.debugNodeInjectorPath(lView);
                }
            };
        }
        function buildNodeInjectorDebug(tNode, tView, lView) {
            const viewProviders = [];
            for (let i = tNode.providerIndexStart_; i < tNode.providerIndexEnd_; i++) {
                viewProviders.push(tView.data[i]);
            }
            const providers = [];
            for (let i = tNode.providerIndexEnd_; i < tNode.directiveEnd; i++) {
                providers.push(tView.data[i]);
            }
            const nodeInjectorDebug = {
                bloom: toBloom(lView, tNode.injectorIndex),
                cumulativeBloom: toBloom(tView.data, tNode.injectorIndex),
                providers,
                viewProviders,
                parentInjectorIndex: lView[tNode.providerIndexStart_ - 1]
            };
            return nodeInjectorDebug;
        }
        function binary(array, idx) {
            const value = array[idx];
            if (typeof value !== "number") {
                return "????????";
            }
            const text = "00000000" + value.toString(2);
            return text.substring(text.length - 8);
        }
        function toBloom(array, idx) {
            if (idx < 0) {
                return "NO_NODE_INJECTOR";
            }
            return `${binary(array, idx + 7)}_${binary(array, idx + 6)}_${binary(array, idx + 5)}_${binary(array, idx + 4)}_${binary(array, idx + 3)}_${binary(array, idx + 2)}_${binary(array, idx + 1)}_${binary(array, idx + 0)}`;
        }
        class LContainerDebug {
            constructor(_raw_lContainer) {
                this._raw_lContainer = _raw_lContainer;
            }
            get hasTransplantedViews() {
                return this._raw_lContainer[HAS_TRANSPLANTED_VIEWS];
            }
            get views() {
                return this._raw_lContainer.slice(CONTAINER_HEADER_OFFSET).map(toDebug);
            }
            get parent() {
                return toDebug(this._raw_lContainer[PARENT]);
            }
            get movedViews() {
                return this._raw_lContainer[MOVED_VIEWS];
            }
            get host() {
                return this._raw_lContainer[HOST];
            }
            get native() {
                return this._raw_lContainer[NATIVE];
            }
            get next() {
                return toDebug(this._raw_lContainer[NEXT]);
            }
        }
        function processHostBindingOpCodes(tView, lView) {
            const hostBindingOpCodes = tView.hostBindingOpCodes;
            if (hostBindingOpCodes === null) {
                return;
            }
            try {
                for (let i = 0; i < hostBindingOpCodes.length; i++) {
                    const opCode = hostBindingOpCodes[i];
                    if (opCode < 0) {
                        setSelectedIndex(~opCode);
                    } else {
                        const directiveIdx = opCode;
                        const bindingRootIndx = hostBindingOpCodes[++i];
                        const hostBindingFn = hostBindingOpCodes[++i];
                        setBindingRootForHostBindings(bindingRootIndx, directiveIdx);
                        const context2 = lView[directiveIdx];
                        hostBindingFn(2, context2);
                    }
                }
            } finally {
                setSelectedIndex(-1);
            }
        }
        function refreshContentQueries(tView, lView) {
            const contentQueries = tView.contentQueries;
            if (contentQueries !== null) {
                for (let i = 0; i < contentQueries.length; i += 2) {
                    const queryStartIdx = contentQueries[i];
                    const directiveDefIdx = contentQueries[i + 1];
                    if (directiveDefIdx !== -1) {
                        const directiveDef = tView.data[directiveDefIdx];
                        setCurrentQueryIndex(queryStartIdx);
                        directiveDef.contentQueries(2, lView[directiveDefIdx], directiveDefIdx);
                    }
                }
            }
        }
        function refreshChildComponents(hostLView, components) {
            for (let i = 0; i < components.length; i++) {
                refreshComponent(hostLView, components[i]);
            }
        }
        function renderChildComponents(hostLView, components) {
            for (let i = 0; i < components.length; i++) {
                renderComponent(hostLView, components[i]);
            }
        }
        function createLView(parentLView, tView, context2, flags, host, tHostNode, rendererFactory, renderer, sanitizer, injector, embeddedViewInjector) {
            const lView = false ? cloneToLViewFromTViewBlueprint(tView) : tView.blueprint.slice();
            lView[HOST] = host;
            lView[FLAGS] = flags | 4 | 64 | 8;
            if (embeddedViewInjector !== null || parentLView && parentLView[FLAGS] & 1024) {
                lView[FLAGS] |= 1024;
            }
            resetPreOrderHookFlags(lView);
            lView[PARENT] = lView[DECLARATION_VIEW] = parentLView;
            lView[CONTEXT] = context2;
            lView[RENDERER_FACTORY] = rendererFactory || parentLView && parentLView[RENDERER_FACTORY];
            lView[RENDERER] = renderer || parentLView && parentLView[RENDERER];
            lView[SANITIZER] = sanitizer || parentLView && parentLView[SANITIZER] || null;
            lView[INJECTOR$1] = injector || parentLView && parentLView[INJECTOR$1] || null;
            lView[T_HOST] = tHostNode;
            lView[ID] = getUniqueLViewId();
            lView[EMBEDDED_VIEW_INJECTOR] = embeddedViewInjector;
            lView[DECLARATION_COMPONENT_VIEW] = tView.type == 2 ? parentLView[DECLARATION_COMPONENT_VIEW] : lView;
            return lView;
        }
        function getOrCreateTNode(tView, index, type, name, attrs) {
            let tNode = tView.data[index];
            if (tNode === null) {
                tNode = createTNodeAtIndex(tView, index, type, name, attrs);
                if (isInI18nBlock()) {
                    tNode.flags |= 64;
                }
            } else if (tNode.type & 64) {
                tNode.type = type;
                tNode.value = name;
                tNode.attrs = attrs;
                const parent = getCurrentParentTNode();
                tNode.injectorIndex = parent === null ? -1 : parent.injectorIndex;
            }
            setCurrentTNode(tNode, true);
            return tNode;
        }
        function createTNodeAtIndex(tView, index, type, name, attrs) {
            const currentTNode = getCurrentTNodePlaceholderOk();
            const isParent = isCurrentTNodeParent();
            const parent = isParent ? currentTNode : currentTNode && currentTNode.parent;
            const tNode = tView.data[index] = createTNode(tView, parent, type, index, name, attrs);
            if (tView.firstChild === null) {
                tView.firstChild = tNode;
            }
            if (currentTNode !== null) {
                if (isParent) {
                    if (currentTNode.child == null && tNode.parent !== null) {
                        currentTNode.child = tNode;
                    }
                } else {
                    if (currentTNode.next === null) {
                        currentTNode.next = tNode;
                    }
                }
            }
            return tNode;
        }
        function allocExpando(tView, lView, numSlotsToAlloc, initialValue) {
            if (numSlotsToAlloc === 0) {
                return -1;
            }
            if (false) {
                assertFirstCreatePass(tView);
                assertSame(tView, lView[TVIEW], "`LView` must be associated with `TView`!");
                assertEqual(tView.data.length, lView.length, "Expecting LView to be same size as TView");
                assertEqual(tView.data.length, tView.blueprint.length, "Expecting Blueprint to be same size as TView");
                assertFirstUpdatePass(tView);
            }
            const allocIdx = lView.length;
            for (let i = 0; i < numSlotsToAlloc; i++) {
                lView.push(initialValue);
                tView.blueprint.push(initialValue);
                tView.data.push(null);
            }
            return allocIdx;
        }
        function renderView(tView, lView, context2) {
            enterView(lView);
            try {
                const viewQuery = tView.viewQuery;
                if (viewQuery !== null) {
                    executeViewQueryFn(1, viewQuery, context2);
                }
                const templateFn = tView.template;
                if (templateFn !== null) {
                    executeTemplate(tView, lView, templateFn, 1, context2);
                }
                if (tView.firstCreatePass) {
                    tView.firstCreatePass = false;
                }
                if (tView.staticContentQueries) {
                    refreshContentQueries(tView, lView);
                }
                if (tView.staticViewQueries) {
                    executeViewQueryFn(2, tView.viewQuery, context2);
                }
                const components = tView.components;
                if (components !== null) {
                    renderChildComponents(lView, components);
                }
            } catch (error) {
                if (tView.firstCreatePass) {
                    tView.incompleteFirstPass = true;
                    tView.firstCreatePass = false;
                }
                throw error;
            } finally {
                lView[FLAGS] &= ~4;
                leaveView();
            }
        }
        function refreshView(tView, lView, templateFn, context2) {
            const flags = lView[FLAGS];
            if ((flags & 128) === 128) {
                return;
            }
            enterView(lView);
            const isInCheckNoChangesPass = false;
            try {
                resetPreOrderHookFlags(lView);
                setBindingIndex(tView.bindingStartIndex);
                if (templateFn !== null) {
                    executeTemplate(tView, lView, templateFn, 2, context2);
                }
                const hooksInitPhaseCompleted = (flags & 3) === 3;
                if (!isInCheckNoChangesPass) {
                    if (hooksInitPhaseCompleted) {
                        const preOrderCheckHooks = tView.preOrderCheckHooks;
                        if (preOrderCheckHooks !== null) {
                            executeCheckHooks(lView, preOrderCheckHooks, null);
                        }
                    } else {
                        const preOrderHooks = tView.preOrderHooks;
                        if (preOrderHooks !== null) {
                            executeInitAndCheckHooks(lView, preOrderHooks, 0, null);
                        }
                        incrementInitPhaseFlags(lView, 0);
                    }
                }
                markTransplantedViewsForRefresh(lView);
                refreshEmbeddedViews(lView);
                if (tView.contentQueries !== null) {
                    refreshContentQueries(tView, lView);
                }
                if (!isInCheckNoChangesPass) {
                    if (hooksInitPhaseCompleted) {
                        const contentCheckHooks = tView.contentCheckHooks;
                        if (contentCheckHooks !== null) {
                            executeCheckHooks(lView, contentCheckHooks);
                        }
                    } else {
                        const contentHooks = tView.contentHooks;
                        if (contentHooks !== null) {
                            executeInitAndCheckHooks(lView, contentHooks, 1);
                        }
                        incrementInitPhaseFlags(lView, 1);
                    }
                }
                processHostBindingOpCodes(tView, lView);
                const components = tView.components;
                if (components !== null) {
                    refreshChildComponents(lView, components);
                }
                const viewQuery = tView.viewQuery;
                if (viewQuery !== null) {
                    executeViewQueryFn(2, viewQuery, context2);
                }
                if (!isInCheckNoChangesPass) {
                    if (hooksInitPhaseCompleted) {
                        const viewCheckHooks = tView.viewCheckHooks;
                        if (viewCheckHooks !== null) {
                            executeCheckHooks(lView, viewCheckHooks);
                        }
                    } else {
                        const viewHooks = tView.viewHooks;
                        if (viewHooks !== null) {
                            executeInitAndCheckHooks(lView, viewHooks, 2);
                        }
                        incrementInitPhaseFlags(lView, 2);
                    }
                }
                if (tView.firstUpdatePass === true) {
                    tView.firstUpdatePass = false;
                }
                if (!isInCheckNoChangesPass) {
                    lView[FLAGS] &= ~(32 | 8);
                }
                if (lView[FLAGS] & 512) {
                    lView[FLAGS] &= ~512;
                    updateTransplantedViewCount(lView[PARENT], -1);
                }
            } finally {
                leaveView();
            }
        }
        function executeTemplate(tView, lView, templateFn, rf, context2) {
            const prevSelectedIndex = getSelectedIndex();
            const isUpdatePhase = rf & 2;
            try {
                setSelectedIndex(-1);
                if (isUpdatePhase && lView.length > HEADER_OFFSET) {
                    selectIndexInternal(tView, lView, HEADER_OFFSET, false);
                }
                const preHookType = isUpdatePhase ? 2 : 0;
                profiler(preHookType, context2);
                templateFn(rf, context2);
            } finally {
                setSelectedIndex(prevSelectedIndex);
                const postHookType = isUpdatePhase ? 3 : 1;
                profiler(postHookType, context2);
            }
        }
        function executeContentQueries(tView, tNode, lView) {
            if (isContentQueryHost(tNode)) {
                const start = tNode.directiveStart;
                const end = tNode.directiveEnd;
                for (let directiveIndex = start; directiveIndex < end; directiveIndex++) {
                    const def = tView.data[directiveIndex];
                    if (def.contentQueries) {
                        def.contentQueries(1, lView[directiveIndex], directiveIndex);
                    }
                }
            }
        }
        function createDirectivesInstances(tView, lView, tNode) {
            if (!getBindingsEnabled()) {
                return;
            }
            instantiateAllDirectives(tView, lView, tNode, getNativeByTNode(tNode, lView));
            if ((tNode.flags & 128) === 128) {
                invokeDirectivesHostBindings(tView, lView, tNode);
            }
        }
        function saveResolvedLocalsInData(viewData, tNode, localRefExtractor = getNativeByTNode) {
            const localNames = tNode.localNames;
            if (localNames !== null) {
                let localIndex = tNode.index + 1;
                for (let i = 0; i < localNames.length; i += 2) {
                    const index = localNames[i + 1];
                    const value = index === -1 ? localRefExtractor(tNode, viewData) : viewData[index];
                    viewData[localIndex++] = value;
                }
            }
        }
        function getOrCreateComponentTView(def) {
            const tView = def.tView;
            if (tView === null || tView.incompleteFirstPass) {
                const declTNode = null;
                return def.tView = createTView(1, declTNode, def.template, def.decls, def.vars, def.directiveDefs, def.pipeDefs, def.viewQuery, def.schemas, def.consts);
            }
            return tView;
        }
        function createTView(type, declTNode, templateFn, decls, vars, directives, pipes, viewQuery, schemas, constsOrFactory) {
            const bindingStartIndex = HEADER_OFFSET + decls;
            const initialViewLength = bindingStartIndex + vars;
            const blueprint = createViewBlueprint(bindingStartIndex, initialViewLength);
            const consts = typeof constsOrFactory === "function" ? constsOrFactory() : constsOrFactory;
            const tView = blueprint[TVIEW] = false ? new TViewConstructor(type, blueprint, templateFn, null, viewQuery, declTNode, cloneToTViewData(blueprint).fill(null, bindingStartIndex), bindingStartIndex, initialViewLength, null, true, true, false, false, null, null, null, null, null, null, null, null, null, null, typeof directives === "function" ? directives() : directives, typeof pipes === "function" ? pipes() : pipes, null, schemas, consts, false, decls, vars) : {
                type,
                blueprint,
                template: templateFn,
                queries: null,
                viewQuery,
                declTNode,
                data: blueprint.slice().fill(null, bindingStartIndex),
                bindingStartIndex,
                expandoStartIndex: initialViewLength,
                hostBindingOpCodes: null,
                firstCreatePass: true,
                firstUpdatePass: true,
                staticViewQueries: false,
                staticContentQueries: false,
                preOrderHooks: null,
                preOrderCheckHooks: null,
                contentHooks: null,
                contentCheckHooks: null,
                viewHooks: null,
                viewCheckHooks: null,
                destroyHooks: null,
                cleanup: null,
                contentQueries: null,
                components: null,
                directiveRegistry: typeof directives === "function" ? directives() : directives,
                pipeRegistry: typeof pipes === "function" ? pipes() : pipes,
                firstChild: null,
                schemas,
                consts,
                incompleteFirstPass: false
            };
            if (false) {
                Object.seal(tView);
            }
            return tView;
        }
        function createViewBlueprint(bindingStartIndex, initialViewLength) {
            const blueprint = false ? new LViewBlueprint : [];
            for (let i = 0; i < initialViewLength; i++) {
                blueprint.push(i < bindingStartIndex ? null : NO_CHANGE);
            }
            return blueprint;
        }
        function createError(text, token) {
            return new Error(`Renderer: ${text} [${stringifyForError(token)}]`);
        }
        function locateHostElement(renderer, elementOrSelector, encapsulation) {
            const preserveContent = encapsulation === ViewEncapsulation$1.ShadowDom;
            return renderer.selectRootElement(elementOrSelector, preserveContent);
        }
        function storeCleanupWithContext(tView, lView, context2, cleanupFn) {
            const lCleanup = getOrCreateLViewCleanup(lView);
            if (context2 === null) {
                if (false) {
                    Object.freeze(getOrCreateTViewCleanup(tView));
                }
                lCleanup.push(cleanupFn);
            } else {
                lCleanup.push(context2);
                if (tView.firstCreatePass) {
                    getOrCreateTViewCleanup(tView).push(cleanupFn, lCleanup.length - 1);
                }
            }
        }
        function createTNode(tView, tParent, type, index, value, attrs) {
            let injectorIndex = tParent ? tParent.injectorIndex : -1;
            const tNode = false ? new TNodeDebug(tView, type, index, null, injectorIndex, -1, -1, -1, null, 0, 0, value, attrs, null, null, void 0, null, null, null, null, null, null, tParent, null, null, null, void 0, null, null, void 0, 0, 0) : {
                type,
                index,
                insertBeforeIndex: null,
                injectorIndex,
                directiveStart: -1,
                directiveEnd: -1,
                directiveStylingLast: -1,
                propertyBindings: null,
                flags: 0,
                providerIndexes: 0,
                value,
                attrs,
                mergedAttrs: null,
                localNames: null,
                initialInputs: void 0,
                inputs: null,
                outputs: null,
                tViews: null,
                next: null,
                projectionNext: null,
                child: null,
                parent: tParent,
                projection: null,
                styles: null,
                stylesWithoutHost: null,
                residualStyles: void 0,
                classes: null,
                classesWithoutHost: null,
                residualClasses: void 0,
                classBindings: 0,
                styleBindings: 0
            };
            if (false) {
                Object.seal(tNode);
            }
            return tNode;
        }
        function generatePropertyAliases(inputAliasMap, directiveDefIdx, propStore) {
            for (let publicName in inputAliasMap) {
                if (inputAliasMap.hasOwnProperty(publicName)) {
                    propStore = propStore === null ? {} : propStore;
                    const internalName = inputAliasMap[publicName];
                    if (propStore.hasOwnProperty(publicName)) {
                        propStore[publicName].push(directiveDefIdx, internalName);
                    } else {
                        propStore[publicName] = [ directiveDefIdx, internalName ];
                    }
                }
            }
            return propStore;
        }
        function initializeInputAndOutputAliases(tView, tNode) {
            const start = tNode.directiveStart;
            const end = tNode.directiveEnd;
            const tViewData = tView.data;
            const tNodeAttrs = tNode.attrs;
            const inputsFromAttrs = false ? new TNodeInitialInputs : [];
            let inputsStore = null;
            let outputsStore = null;
            for (let i = start; i < end; i++) {
                const directiveDef = tViewData[i];
                const directiveInputs = directiveDef.inputs;
                const initialInputs = tNodeAttrs !== null && !isInlineTemplate(tNode) ? generateInitialInputs(directiveInputs, tNodeAttrs) : null;
                inputsFromAttrs.push(initialInputs);
                inputsStore = generatePropertyAliases(directiveInputs, i, inputsStore);
                outputsStore = generatePropertyAliases(directiveDef.outputs, i, outputsStore);
            }
            if (inputsStore !== null) {
                if (inputsStore.hasOwnProperty("class")) {
                    tNode.flags |= 16;
                }
                if (inputsStore.hasOwnProperty("style")) {
                    tNode.flags |= 32;
                }
            }
            tNode.initialInputs = inputsFromAttrs;
            tNode.inputs = inputsStore;
            tNode.outputs = outputsStore;
        }
        function mapPropName(name) {
            if (name === "class") {
                return "className";
            }
            if (name === "for") {
                return "htmlFor";
            }
            if (name === "formaction") {
                return "formAction";
            }
            if (name === "innerHtml") {
                return "innerHTML";
            }
            if (name === "readonly") {
                return "readOnly";
            }
            if (name === "tabindex") {
                return "tabIndex";
            }
            return name;
        }
        function elementPropertyInternal(tView, tNode, lView, propName, value, renderer, sanitizer, nativeOnly) {
            const element = getNativeByTNode(tNode, lView);
            let inputData = tNode.inputs;
            let dataValue;
            if (!nativeOnly && inputData != null && (dataValue = inputData[propName])) {
                setInputsForProperty(tView, lView, dataValue, propName, value);
                if (isComponentHost(tNode)) {
                    markDirtyIfOnPush(lView, tNode.index);
                }
                if (false) {
                    setNgReflectProperties(lView, element, tNode.type, dataValue, value);
                }
            } else if (tNode.type & 3) {
                propName = mapPropName(propName);
                if (false) {
                    validateAgainstEventProperties(propName);
                    if (!isPropertyValid(element, propName, tNode.value, tView.schemas)) {
                        handleUnknownPropertyError(propName, tNode.value, tNode.type, lView);
                    }
                    false.rendererSetProperty++;
                }
                value = sanitizer != null ? sanitizer(value, tNode.value || "", propName) : value;
                renderer.setProperty(element, propName, value);
            } else if (tNode.type & 12) {
                if (false) {
                    handleUnknownPropertyError(propName, tNode.value, tNode.type, lView);
                }
            }
        }
        function markDirtyIfOnPush(lView, viewIndex) {
            const childComponentLView = getComponentLViewByIndex(viewIndex, lView);
            if (!(childComponentLView[FLAGS] & 16)) {
                childComponentLView[FLAGS] |= 32;
            }
        }
        function setNgReflectProperty(lView, element, type, attrName, value) {
            const renderer = lView[RENDERER];
            attrName = normalizeDebugBindingName(attrName);
            const debugValue = normalizeDebugBindingValue(value);
            if (type & 3) {
                if (value == null) {
                    renderer.removeAttribute(element, attrName);
                } else {
                    renderer.setAttribute(element, attrName, debugValue);
                }
            } else {
                const textContent = escapeCommentText(`bindings=${JSON.stringify({
                    [attrName]: debugValue
                }, null, 2)}`);
                renderer.setValue(element, textContent);
            }
        }
        function setNgReflectProperties(lView, element, type, dataValue, value) {
            if (type & (3 | 4)) {
                for (let i = 0; i < dataValue.length; i += 2) {
                    setNgReflectProperty(lView, element, type, dataValue[i + 1], value);
                }
            }
        }
        function instantiateRootComponent(tView, lView, def) {
            const rootTNode = getCurrentTNode();
            if (tView.firstCreatePass) {
                if (def.providersResolver) {
                    def.providersResolver(def);
                }
                const directiveIndex = allocExpando(tView, lView, 1, null);
                configureViewWithDirective(tView, rootTNode, lView, directiveIndex, def);
                initializeInputAndOutputAliases(tView, rootTNode);
            }
            const directive = getNodeInjectable(lView, tView, rootTNode.directiveStart, rootTNode);
            attachPatchData(directive, lView);
            const native = getNativeByTNode(rootTNode, lView);
            if (native) {
                attachPatchData(native, lView);
            }
            return directive;
        }
        function resolveDirectives(tView, lView, tNode, localRefs) {
            let hasDirectives = false;
            if (getBindingsEnabled()) {
                const directiveDefs = findDirectiveDefMatches(tView, lView, tNode);
                const exportsMap = localRefs === null ? null : {
                    "": -1
                };
                if (directiveDefs !== null) {
                    hasDirectives = true;
                    initTNodeFlags(tNode, tView.data.length, directiveDefs.length);
                    for (let i = 0; i < directiveDefs.length; i++) {
                        const def = directiveDefs[i];
                        if (def.providersResolver) {
                            def.providersResolver(def);
                        }
                    }
                    let preOrderHooksFound = false;
                    let preOrderCheckHooksFound = false;
                    let directiveIdx = allocExpando(tView, lView, directiveDefs.length, null);
                    for (let i = 0; i < directiveDefs.length; i++) {
                        const def = directiveDefs[i];
                        tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, def.hostAttrs);
                        configureViewWithDirective(tView, tNode, lView, directiveIdx, def);
                        saveNameToExportMap(directiveIdx, def, exportsMap);
                        if (def.contentQueries !== null) {
                            tNode.flags |= 8;
                        }
                        if (def.hostBindings !== null || def.hostAttrs !== null || def.hostVars !== 0) {
                            tNode.flags |= 128;
                        }
                        const lifeCycleHooks = def.type.prototype;
                        if (!preOrderHooksFound && (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngOnInit || lifeCycleHooks.ngDoCheck)) {
                            (tView.preOrderHooks || (tView.preOrderHooks = [])).push(tNode.index);
                            preOrderHooksFound = true;
                        }
                        if (!preOrderCheckHooksFound && (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngDoCheck)) {
                            (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [])).push(tNode.index);
                            preOrderCheckHooksFound = true;
                        }
                        directiveIdx++;
                    }
                    initializeInputAndOutputAliases(tView, tNode);
                }
                if (exportsMap) {
                    cacheMatchingLocalNames(tNode, localRefs, exportsMap);
                }
            }
            tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, tNode.attrs);
            return hasDirectives;
        }
        function registerHostBindingOpCodes(tView, tNode, lView, directiveIdx, directiveVarsIdx, def) {
            const hostBindings = def.hostBindings;
            if (hostBindings) {
                let hostBindingOpCodes = tView.hostBindingOpCodes;
                if (hostBindingOpCodes === null) {
                    hostBindingOpCodes = tView.hostBindingOpCodes = [];
                }
                const elementIndx = ~tNode.index;
                if (lastSelectedElementIdx(hostBindingOpCodes) != elementIndx) {
                    hostBindingOpCodes.push(elementIndx);
                }
                hostBindingOpCodes.push(directiveIdx, directiveVarsIdx, hostBindings);
            }
        }
        function lastSelectedElementIdx(hostBindingOpCodes) {
            let i = hostBindingOpCodes.length;
            while (i > 0) {
                const value = hostBindingOpCodes[--i];
                if (typeof value === "number" && value < 0) {
                    return value;
                }
            }
            return 0;
        }
        function instantiateAllDirectives(tView, lView, tNode, native) {
            const start = tNode.directiveStart;
            const end = tNode.directiveEnd;
            if (!tView.firstCreatePass) {
                getOrCreateNodeInjectorForNode(tNode, lView);
            }
            attachPatchData(native, lView);
            const initialInputs = tNode.initialInputs;
            for (let i = start; i < end; i++) {
                const def = tView.data[i];
                const isComponent = isComponentDef(def);
                if (isComponent) {
                    addComponentLogic(lView, tNode, def);
                }
                const directive = getNodeInjectable(lView, tView, i, tNode);
                attachPatchData(directive, lView);
                if (initialInputs !== null) {
                    setInputsFromAttrs(lView, i - start, directive, def, tNode, initialInputs);
                }
                if (isComponent) {
                    const componentView = getComponentLViewByIndex(tNode.index, lView);
                    componentView[CONTEXT] = directive;
                }
            }
        }
        function invokeDirectivesHostBindings(tView, lView, tNode) {
            const start = tNode.directiveStart;
            const end = tNode.directiveEnd;
            const elementIndex = tNode.index;
            const currentDirectiveIndex = getCurrentDirectiveIndex();
            try {
                setSelectedIndex(elementIndex);
                for (let dirIndex = start; dirIndex < end; dirIndex++) {
                    const def = tView.data[dirIndex];
                    const directive = lView[dirIndex];
                    setCurrentDirectiveIndex(dirIndex);
                    if (def.hostBindings !== null || def.hostVars !== 0 || def.hostAttrs !== null) {
                        invokeHostBindingsInCreationMode(def, directive);
                    }
                }
            } finally {
                setSelectedIndex(-1);
                setCurrentDirectiveIndex(currentDirectiveIndex);
            }
        }
        function invokeHostBindingsInCreationMode(def, directive) {
            if (def.hostBindings !== null) {
                def.hostBindings(1, directive);
            }
        }
        function findDirectiveDefMatches(tView, viewData, tNode) {
            const registry = tView.directiveRegistry;
            let matches = null;
            if (registry) {
                for (let i = 0; i < registry.length; i++) {
                    const def = registry[i];
                    if (isNodeMatchingSelectorList(tNode, def.selectors, false)) {
                        matches || (matches = false ? new MatchesArray : []);
                        diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, viewData), tView, def.type);
                        if (isComponentDef(def)) {
                            if (false) {
                                assertTNodeType(tNode, 2, `"${tNode.value}" tags cannot be used as component hosts. Please use a different tag to activate the ${stringify(def.type)} component.`);
                                if (tNode.flags & 2) {
                                    throwMultipleComponentError(tNode, matches[0].type, def.type);
                                }
                            }
                            markAsComponentHost(tView, tNode);
                            matches.unshift(def);
                        } else {
                            matches.push(def);
                        }
                    }
                }
            }
            return matches;
        }
        function markAsComponentHost(tView, hostTNode) {
            hostTNode.flags |= 2;
            (tView.components || (tView.components = false ? new TViewComponents : [])).push(hostTNode.index);
        }
        function cacheMatchingLocalNames(tNode, localRefs, exportsMap) {
            if (localRefs) {
                const localNames = tNode.localNames = false ? new TNodeLocalNames : [];
                for (let i = 0; i < localRefs.length; i += 2) {
                    const index = exportsMap[localRefs[i + 1]];
                    if (index == null) {
                        throw new RuntimeError(-301, false);
                    }
                    localNames.push(localRefs[i], index);
                }
            }
        }
        function saveNameToExportMap(directiveIdx, def, exportsMap) {
            if (exportsMap) {
                if (def.exportAs) {
                    for (let i = 0; i < def.exportAs.length; i++) {
                        exportsMap[def.exportAs[i]] = directiveIdx;
                    }
                }
                if (isComponentDef(def)) {
                    exportsMap[""] = directiveIdx;
                }
            }
        }
        function initTNodeFlags(tNode, index, numberOfDirectives) {
            tNode.flags |= 1;
            tNode.directiveStart = index;
            tNode.directiveEnd = index + numberOfDirectives;
            tNode.providerIndexes = index;
        }
        function configureViewWithDirective(tView, tNode, lView, directiveIndex, def) {
            tView.data[directiveIndex] = def;
            const directiveFactory = def.factory || (def.factory = getFactoryDef(def.type, true));
            const nodeInjectorFactory = new NodeInjectorFactory(directiveFactory, isComponentDef(def), directiveInject);
            tView.blueprint[directiveIndex] = nodeInjectorFactory;
            lView[directiveIndex] = nodeInjectorFactory;
            registerHostBindingOpCodes(tView, tNode, lView, directiveIndex, allocExpando(tView, lView, def.hostVars, NO_CHANGE), def);
        }
        function addComponentLogic(lView, hostTNode, def) {
            const native = getNativeByTNode(hostTNode, lView);
            const tView = getOrCreateComponentTView(def);
            const rendererFactory = lView[RENDERER_FACTORY];
            const componentView = addToViewTree(lView, createLView(lView, tView, null, def.onPush ? 32 : 16, native, hostTNode, rendererFactory, rendererFactory.createRenderer(native, def), null, null, null));
            lView[hostTNode.index] = componentView;
        }
        function elementAttributeInternal(tNode, lView, name, value, sanitizer, namespace) {
            if (false) {
                assertNotSame(value, NO_CHANGE, "Incoming value should never be NO_CHANGE.");
                validateAgainstEventAttributes(name);
                assertTNodeType(tNode, 2, `Attempted to set attribute \`${name}\` on a container node. Host bindings are not valid on ng-container or ng-template.`);
            }
            const element = getNativeByTNode(tNode, lView);
            setElementAttribute(lView[RENDERER], element, namespace, tNode.value, name, value, sanitizer);
        }
        function setElementAttribute(renderer, element, namespace, tagName, name, value, sanitizer) {
            if (value == null) {
                renderer.removeAttribute(element, name, namespace);
            } else {
                const strValue = sanitizer == null ? renderStringify(value) : sanitizer(value, tagName || "", name);
                renderer.setAttribute(element, name, strValue, namespace);
            }
        }
        function setInputsFromAttrs(lView, directiveIndex, instance, def, tNode, initialInputData) {
            const initialInputs = initialInputData[directiveIndex];
            if (initialInputs !== null) {
                const setInput = def.setInput;
                for (let i = 0; i < initialInputs.length; ) {
                    const publicName = initialInputs[i++];
                    const privateName = initialInputs[i++];
                    const value = initialInputs[i++];
                    if (setInput !== null) {
                        def.setInput(instance, value, publicName, privateName);
                    } else {
                        instance[privateName] = value;
                    }
                    if (false) {
                        const nativeElement = getNativeByTNode(tNode, lView);
                        setNgReflectProperty(lView, nativeElement, tNode.type, privateName, value);
                    }
                }
            }
        }
        function generateInitialInputs(inputs, attrs) {
            let inputsToStore = null;
            let i = 0;
            while (i < attrs.length) {
                const attrName = attrs[i];
                if (attrName === 0) {
                    i += 4;
                    continue;
                } else if (attrName === 5) {
                    i += 2;
                    continue;
                }
                if (typeof attrName === "number") {
                    break;
                }
                if (inputs.hasOwnProperty(attrName)) {
                    if (inputsToStore === null) {
                        inputsToStore = [];
                    }
                    inputsToStore.push(attrName, inputs[attrName], attrs[i + 1]);
                }
                i += 2;
            }
            return inputsToStore;
        }
        const LContainerArray = class LContainer extends Array {};
        function createLContainer(hostNative, currentView, native, tNode) {
            const lContainer = new (false ? LContainerArray : Array)(hostNative, true, false, currentView, null, 0, tNode, native, null, null);
            return lContainer;
        }
        function refreshEmbeddedViews(lView) {
            for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {
                for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
                    const embeddedLView = lContainer[i];
                    const embeddedTView = embeddedLView[TVIEW];
                    if (viewAttachedToChangeDetector(embeddedLView)) {
                        refreshView(embeddedTView, embeddedLView, embeddedTView.template, embeddedLView[CONTEXT]);
                    }
                }
            }
        }
        function markTransplantedViewsForRefresh(lView) {
            for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {
                if (!lContainer[HAS_TRANSPLANTED_VIEWS]) {
                    continue;
                }
                const movedViews = lContainer[MOVED_VIEWS];
                for (let i = 0; i < movedViews.length; i++) {
                    const movedLView = movedViews[i];
                    const insertionLContainer = movedLView[PARENT];
                    if ((movedLView[FLAGS] & 512) === 0) {
                        updateTransplantedViewCount(insertionLContainer, 1);
                    }
                    movedLView[FLAGS] |= 512;
                }
            }
        }
        function refreshComponent(hostLView, componentHostIdx) {
            const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);
            if (viewAttachedToChangeDetector(componentView)) {
                const tView = componentView[TVIEW];
                if (componentView[FLAGS] & (16 | 32)) {
                    refreshView(tView, componentView, tView.template, componentView[CONTEXT]);
                } else if (componentView[TRANSPLANTED_VIEWS_TO_REFRESH] > 0) {
                    refreshContainsDirtyView(componentView);
                }
            }
        }
        function refreshContainsDirtyView(lView) {
            for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {
                for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
                    const embeddedLView = lContainer[i];
                    if (viewAttachedToChangeDetector(embeddedLView)) {
                        if (embeddedLView[FLAGS] & 512) {
                            const embeddedTView = embeddedLView[TVIEW];
                            refreshView(embeddedTView, embeddedLView, embeddedTView.template, embeddedLView[CONTEXT]);
                        } else if (embeddedLView[TRANSPLANTED_VIEWS_TO_REFRESH] > 0) {
                            refreshContainsDirtyView(embeddedLView);
                        }
                    }
                }
            }
            const tView = lView[TVIEW];
            const components = tView.components;
            if (components !== null) {
                for (let i = 0; i < components.length; i++) {
                    const componentView = getComponentLViewByIndex(components[i], lView);
                    if (viewAttachedToChangeDetector(componentView) && componentView[TRANSPLANTED_VIEWS_TO_REFRESH] > 0) {
                        refreshContainsDirtyView(componentView);
                    }
                }
            }
        }
        function renderComponent(hostLView, componentHostIdx) {
            const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);
            const componentTView = componentView[TVIEW];
            syncViewWithBlueprint(componentTView, componentView);
            renderView(componentTView, componentView, componentView[CONTEXT]);
        }
        function syncViewWithBlueprint(tView, lView) {
            for (let i = lView.length; i < tView.blueprint.length; i++) {
                lView.push(tView.blueprint[i]);
            }
        }
        function addToViewTree(lView, lViewOrLContainer) {
            if (lView[CHILD_HEAD]) {
                lView[CHILD_TAIL][NEXT] = lViewOrLContainer;
            } else {
                lView[CHILD_HEAD] = lViewOrLContainer;
            }
            lView[CHILD_TAIL] = lViewOrLContainer;
            return lViewOrLContainer;
        }
        function markViewDirty(lView) {
            while (lView) {
                lView[FLAGS] |= 32;
                const parent = getLViewParent(lView);
                if (isRootView(lView) && !parent) {
                    return lView;
                }
                lView = parent;
            }
            return null;
        }
        function detectChangesInternal(tView, lView, context2, notifyErrorHandler = true) {
            const rendererFactory = lView[RENDERER_FACTORY];
            const checkNoChangesMode = false;
            if (!checkNoChangesMode && rendererFactory.begin) {
                rendererFactory.begin();
            }
            try {
                refreshView(tView, lView, tView.template, context2);
            } catch (error) {
                if (notifyErrorHandler) {
                    handleError(lView, error);
                }
                throw error;
            } finally {
                if (!checkNoChangesMode && rendererFactory.end) {
                    rendererFactory.end();
                }
            }
        }
        function checkNoChangesInternal(tView, lView, context2, notifyErrorHandler = true) {
            setIsInCheckNoChangesMode(true);
            try {
                detectChangesInternal(tView, lView, context2, notifyErrorHandler);
            } finally {
                setIsInCheckNoChangesMode(false);
            }
        }
        function executeViewQueryFn(flags, viewQueryFn, component) {
            setCurrentQueryIndex(0);
            viewQueryFn(flags, component);
        }
        function storePropertyBindingMetadata(tData, tNode, propertyName, bindingIndex, ...interpolationParts) {
            if (tData[bindingIndex] === null) {
                if (tNode.inputs == null || !tNode.inputs[propertyName]) {
                    const propBindingIdxs = tNode.propertyBindings || (tNode.propertyBindings = []);
                    propBindingIdxs.push(bindingIndex);
                    let bindingMetadata = propertyName;
                    if (interpolationParts.length > 0) {
                        bindingMetadata += INTERPOLATION_DELIMITER + interpolationParts.join(INTERPOLATION_DELIMITER);
                    }
                    tData[bindingIndex] = bindingMetadata;
                }
            }
        }
        function getOrCreateLViewCleanup(view) {
            return view[CLEANUP] || (view[CLEANUP] = false ? new LCleanup : []);
        }
        function getOrCreateTViewCleanup(tView) {
            return tView.cleanup || (tView.cleanup = false ? new TCleanup : []);
        }
        function loadComponentRenderer(currentDef, tNode, lView) {
            if (currentDef === null || isComponentDef(currentDef)) {
                lView = unwrapLView(lView[tNode.index]);
            }
            return lView[RENDERER];
        }
        function handleError(lView, error) {
            const injector = lView[INJECTOR$1];
            const errorHandler2 = injector ? injector.get(ErrorHandler, null) : null;
            errorHandler2 && errorHandler2.handleError(error);
        }
        function setInputsForProperty(tView, lView, inputs, publicName, value) {
            for (let i = 0; i < inputs.length; ) {
                const index = inputs[i++];
                const privateName = inputs[i++];
                const instance = lView[index];
                const def = tView.data[index];
                if (def.setInput !== null) {
                    def.setInput(instance, value, publicName, privateName);
                } else {
                    instance[privateName] = value;
                }
            }
        }
        function textBindingInternal(lView, index, value) {
            const element = getNativeByIndex(index, lView);
            updateTextNode(lView[RENDERER], element, value);
        }
        function computeStaticStyling(tNode, attrs, writeToHost) {
            let styles = writeToHost ? tNode.styles : null;
            let classes = writeToHost ? tNode.classes : null;
            let mode = 0;
            if (attrs !== null) {
                for (let i = 0; i < attrs.length; i++) {
                    const value = attrs[i];
                    if (typeof value === "number") {
                        mode = value;
                    } else if (mode == 1) {
                        classes = concatStringsWithSpace(classes, value);
                    } else if (mode == 2) {
                        const style = value;
                        const styleValue = attrs[++i];
                        styles = concatStringsWithSpace(styles, style + ": " + styleValue + ";");
                    }
                }
            }
            writeToHost ? tNode.styles = styles : tNode.stylesWithoutHost = styles;
            writeToHost ? tNode.classes = classes : tNode.classesWithoutHost = classes;
        }
        function collectNativeNodes(tView, lView, tNode, result, isProjection = false) {
            while (tNode !== null) {
                const lNode = lView[tNode.index];
                if (lNode !== null) {
                    result.push(unwrapRNode(lNode));
                }
                if (isLContainer(lNode)) {
                    for (let i = CONTAINER_HEADER_OFFSET; i < lNode.length; i++) {
                        const lViewInAContainer = lNode[i];
                        const lViewFirstChildTNode = lViewInAContainer[TVIEW].firstChild;
                        if (lViewFirstChildTNode !== null) {
                            collectNativeNodes(lViewInAContainer[TVIEW], lViewInAContainer, lViewFirstChildTNode, result);
                        }
                    }
                }
                const tNodeType = tNode.type;
                if (tNodeType & 8) {
                    collectNativeNodes(tView, lView, tNode.child, result);
                } else if (tNodeType & 32) {
                    const nextRNode = icuContainerIterate(tNode, lView);
                    let rNode;
                    while (rNode = nextRNode()) {
                        result.push(rNode);
                    }
                } else if (tNodeType & 16) {
                    const nodesInSlot = getProjectionNodes(lView, tNode);
                    if (Array.isArray(nodesInSlot)) {
                        result.push(...nodesInSlot);
                    } else {
                        const parentView = getLViewParent(lView[DECLARATION_COMPONENT_VIEW]);
                        collectNativeNodes(parentView[TVIEW], parentView, nodesInSlot, result, true);
                    }
                }
                tNode = isProjection ? tNode.projectionNext : tNode.next;
            }
            return result;
        }
        class ViewRef$1 {
            constructor(_lView, _cdRefInjectingView) {
                this._lView = _lView;
                this._cdRefInjectingView = _cdRefInjectingView;
                this._appRef = null;
                this._attachedToViewContainer = false;
            }
            get rootNodes() {
                const lView = this._lView;
                const tView = lView[TVIEW];
                return collectNativeNodes(tView, lView, tView.firstChild, []);
            }
            get context() {
                return this._lView[CONTEXT];
            }
            set context(value) {
                this._lView[CONTEXT] = value;
            }
            get destroyed() {
                return (this._lView[FLAGS] & 128) === 128;
            }
            destroy() {
                if (this._appRef) {
                    this._appRef.detachView(this);
                } else if (this._attachedToViewContainer) {
                    const parent = this._lView[PARENT];
                    if (isLContainer(parent)) {
                        const viewRefs = parent[VIEW_REFS];
                        const index = viewRefs ? viewRefs.indexOf(this) : -1;
                        if (index > -1) {
                            detachView(parent, index);
                            removeFromArray(viewRefs, index);
                        }
                    }
                    this._attachedToViewContainer = false;
                }
                destroyLView(this._lView[TVIEW], this._lView);
            }
            onDestroy(callback) {
                storeCleanupWithContext(this._lView[TVIEW], this._lView, null, callback);
            }
            markForCheck() {
                markViewDirty(this._cdRefInjectingView || this._lView);
            }
            detach() {
                this._lView[FLAGS] &= ~64;
            }
            reattach() {
                this._lView[FLAGS] |= 64;
            }
            detectChanges() {
                detectChangesInternal(this._lView[TVIEW], this._lView, this.context);
            }
            checkNoChanges() {
                if (false) {
                    checkNoChangesInternal(this._lView[TVIEW], this._lView, this.context);
                }
            }
            attachToViewContainerRef() {
                if (this._appRef) {
                    throw new RuntimeError(902, false);
                }
                this._attachedToViewContainer = true;
            }
            detachFromAppRef() {
                this._appRef = null;
                renderDetachView(this._lView[TVIEW], this._lView);
            }
            attachToAppRef(appRef) {
                if (this._attachedToViewContainer) {
                    throw new RuntimeError(902, false);
                }
                this._appRef = appRef;
            }
        }
        class RootViewRef extends ViewRef$1 {
            constructor(_view) {
                super(_view);
                this._view = _view;
            }
            detectChanges() {
                const lView = this._view;
                const tView = lView[TVIEW];
                const context2 = lView[CONTEXT];
                detectChangesInternal(tView, lView, context2, false);
            }
            checkNoChanges() {
                if (false) {
                    const lView = this._view;
                    const tView = lView[TVIEW];
                    const context2 = lView[CONTEXT];
                    checkNoChangesInternal(tView, lView, context2, false);
                }
            }
            get context() {
                return null;
            }
        }
        class ComponentFactoryResolver extends ComponentFactoryResolver$1 {
            constructor(ngModule) {
                super();
                this.ngModule = ngModule;
            }
            resolveComponentFactory(component) {
                const componentDef = getComponentDef(component);
                return new ComponentFactory(componentDef, this.ngModule);
            }
        }
        function toRefArray(map2) {
            const array = [];
            for (let nonMinified in map2) {
                if (map2.hasOwnProperty(nonMinified)) {
                    const minified = map2[nonMinified];
                    array.push({
                        propName: minified,
                        templateName: nonMinified
                    });
                }
            }
            return array;
        }
        function getNamespace(elementName) {
            const name = elementName.toLowerCase();
            return name === "svg" ? SVG_NAMESPACE : name === "math" ? MATH_ML_NAMESPACE : null;
        }
        class ChainedInjector {
            constructor(injector, parentInjector) {
                this.injector = injector;
                this.parentInjector = parentInjector;
            }
            get(token, notFoundValue, flags) {
                const value = this.injector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR, flags);
                if (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR || notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) {
                    return value;
                }
                return this.parentInjector.get(token, notFoundValue, flags);
            }
        }
        class ComponentFactory extends ComponentFactory$1 {
            constructor(componentDef, ngModule) {
                super();
                this.componentDef = componentDef;
                this.ngModule = ngModule;
                this.componentType = componentDef.type;
                this.selector = stringifyCSSSelectorList(componentDef.selectors);
                this.ngContentSelectors = componentDef.ngContentSelectors ? componentDef.ngContentSelectors : [];
                this.isBoundToModule = !!ngModule;
            }
            get inputs() {
                return toRefArray(this.componentDef.inputs);
            }
            get outputs() {
                return toRefArray(this.componentDef.outputs);
            }
            create(injector, projectableNodes, rootSelectorOrNode, environmentInjector) {
                environmentInjector = environmentInjector || this.ngModule;
                let realEnvironmentInjector = environmentInjector instanceof EnvironmentInjector ? environmentInjector : environmentInjector?.injector;
                if (realEnvironmentInjector && this.componentDef.getStandaloneInjector !== null) {
                    realEnvironmentInjector = this.componentDef.getStandaloneInjector(realEnvironmentInjector) || realEnvironmentInjector;
                }
                const rootViewInjector = realEnvironmentInjector ? new ChainedInjector(injector, realEnvironmentInjector) : injector;
                const rendererFactory = rootViewInjector.get(RendererFactory2, null);
                if (rendererFactory === null) {
                    throw new RuntimeError(407, false);
                }
                const sanitizer = rootViewInjector.get(Sanitizer, null);
                const hostRenderer = rendererFactory.createRenderer(null, this.componentDef);
                const elementName = this.componentDef.selectors[0][0] || "div";
                const hostRNode = rootSelectorOrNode ? locateHostElement(hostRenderer, rootSelectorOrNode, this.componentDef.encapsulation) : createElementNode(hostRenderer, elementName, getNamespace(elementName));
                const rootFlags = this.componentDef.onPush ? 32 | 256 : 16 | 256;
                const rootTView = createTView(0, null, null, 1, 0, null, null, null, null, null);
                const rootLView = createLView(null, rootTView, null, rootFlags, null, null, rendererFactory, hostRenderer, sanitizer, rootViewInjector, null);
                enterView(rootLView);
                let component;
                let tElementNode;
                try {
                    const componentView = createRootComponentView(hostRNode, this.componentDef, rootLView, rendererFactory, hostRenderer);
                    if (hostRNode) {
                        if (rootSelectorOrNode) {
                            setUpAttributes(hostRenderer, hostRNode, [ "ng-version", VERSION.full ]);
                        } else {
                            const {attrs, classes} = extractAttrsAndClassesFromSelector(this.componentDef.selectors[0]);
                            if (attrs) {
                                setUpAttributes(hostRenderer, hostRNode, attrs);
                            }
                            if (classes && classes.length > 0) {
                                writeDirectClass(hostRenderer, hostRNode, classes.join(" "));
                            }
                        }
                    }
                    tElementNode = getTNode(rootTView, HEADER_OFFSET);
                    if (projectableNodes !== void 0) {
                        const projection = tElementNode.projection = [];
                        for (let i = 0; i < this.ngContentSelectors.length; i++) {
                            const nodesforSlot = projectableNodes[i];
                            projection.push(nodesforSlot != null ? Array.from(nodesforSlot) : null);
                        }
                    }
                    component = createRootComponent(componentView, this.componentDef, rootLView, [ LifecycleHooksFeature ]);
                    renderView(rootTView, rootLView, null);
                } finally {
                    leaveView();
                }
                return new ComponentRef(this.componentType, component, createElementRef(tElementNode, rootLView), rootLView, tElementNode);
            }
        }
        const componentFactoryResolver = new ComponentFactoryResolver;
        function injectComponentFactoryResolver() {
            return componentFactoryResolver;
        }
        class ComponentRef extends ComponentRef$1 {
            constructor(componentType, instance, location2, _rootLView, _tNode) {
                super();
                this.location = location2;
                this._rootLView = _rootLView;
                this._tNode = _tNode;
                this.instance = instance;
                this.hostView = this.changeDetectorRef = new RootViewRef(_rootLView);
                this.componentType = componentType;
            }
            setInput(name, value) {
                const inputData = this._tNode.inputs;
                let dataValue;
                if (inputData !== null && (dataValue = inputData[name])) {
                    const lView = this._rootLView;
                    setInputsForProperty(lView[TVIEW], lView, dataValue, name, value);
                    markDirtyIfOnPush(lView, this._tNode.index);
                } else {
                    if (false) {
                        const cmpNameForError = stringifyForError(this.componentType);
                        let message = `Can't set value of the '${name}' input on the '${cmpNameForError}' component. `;
                        message += `Make sure that the '${name}' property is annotated with @Input() or a mapped @Input('${name}') exists.`;
                        reportUnknownPropertyError(message);
                    }
                }
            }
            get injector() {
                return new NodeInjector(this._tNode, this._rootLView);
            }
            destroy() {
                this.hostView.destroy();
            }
            onDestroy(callback) {
                this.hostView.onDestroy(callback);
            }
        }
        const NULL_INJECTOR = {
            get: (token, notFoundValue) => {
                throwProviderNotFoundError(token, "NullInjector");
            }
        };
        function createRootComponentView(rNode, def, rootView, rendererFactory, hostRenderer, sanitizer) {
            const tView = rootView[TVIEW];
            const index = HEADER_OFFSET;
            rootView[index] = rNode;
            const tNode = getOrCreateTNode(tView, index, 2, "#host", null);
            const mergedAttrs = tNode.mergedAttrs = def.hostAttrs;
            if (mergedAttrs !== null) {
                computeStaticStyling(tNode, mergedAttrs, true);
                if (rNode !== null) {
                    setUpAttributes(hostRenderer, rNode, mergedAttrs);
                    if (tNode.classes !== null) {
                        writeDirectClass(hostRenderer, rNode, tNode.classes);
                    }
                    if (tNode.styles !== null) {
                        writeDirectStyle(hostRenderer, rNode, tNode.styles);
                    }
                }
            }
            const viewRenderer = rendererFactory.createRenderer(rNode, def);
            const componentView = createLView(rootView, getOrCreateComponentTView(def), null, def.onPush ? 32 : 16, rootView[index], tNode, rendererFactory, viewRenderer, sanitizer || null, null, null);
            if (tView.firstCreatePass) {
                diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, rootView), tView, def.type);
                markAsComponentHost(tView, tNode);
                initTNodeFlags(tNode, rootView.length, 1);
            }
            addToViewTree(rootView, componentView);
            return rootView[index] = componentView;
        }
        function createRootComponent(componentView, componentDef, rootLView, hostFeatures) {
            const tView = rootLView[TVIEW];
            const component = instantiateRootComponent(tView, rootLView, componentDef);
            componentView[CONTEXT] = rootLView[CONTEXT] = component;
            if (hostFeatures !== null) {
                for (const feature of hostFeatures) {
                    feature(component, componentDef);
                }
            }
            if (componentDef.contentQueries) {
                const tNode = getCurrentTNode();
                componentDef.contentQueries(1, component, tNode.directiveStart);
            }
            const rootTNode = getCurrentTNode();
            if (tView.firstCreatePass && (componentDef.hostBindings !== null || componentDef.hostAttrs !== null)) {
                setSelectedIndex(rootTNode.index);
                const rootTView = rootLView[TVIEW];
                registerHostBindingOpCodes(rootTView, rootTNode, rootLView, rootTNode.directiveStart, rootTNode.directiveEnd, componentDef);
                invokeHostBindingsInCreationMode(componentDef, component);
            }
            return component;
        }
        function LifecycleHooksFeature() {
            const tNode = getCurrentTNode();
            registerPostOrderHooks(getLView()[TVIEW], tNode);
        }
        function getSuperType(type) {
            return Object.getPrototypeOf(type.prototype).constructor;
        }
        function InheritDefinitionFeature(definition) {
            let superType = getSuperType(definition.type);
            let shouldInheritFields = true;
            const inheritanceChain = [ definition ];
            while (superType) {
                let superDef = void 0;
                if (isComponentDef(definition)) {
                    superDef = superType.cmp || superType.dir;
                } else {
                    if (superType.cmp) {
                        throw new RuntimeError(903, false);
                    }
                    superDef = superType.dir;
                }
                if (superDef) {
                    if (shouldInheritFields) {
                        inheritanceChain.push(superDef);
                        const writeableDef = definition;
                        writeableDef.inputs = maybeUnwrapEmpty(definition.inputs);
                        writeableDef.declaredInputs = maybeUnwrapEmpty(definition.declaredInputs);
                        writeableDef.outputs = maybeUnwrapEmpty(definition.outputs);
                        const superHostBindings = superDef.hostBindings;
                        superHostBindings && inheritHostBindings(definition, superHostBindings);
                        const superViewQuery = superDef.viewQuery;
                        const superContentQueries = superDef.contentQueries;
                        superViewQuery && inheritViewQuery(definition, superViewQuery);
                        superContentQueries && inheritContentQueries(definition, superContentQueries);
                        fillProperties(definition.inputs, superDef.inputs);
                        fillProperties(definition.declaredInputs, superDef.declaredInputs);
                        fillProperties(definition.outputs, superDef.outputs);
                        if (isComponentDef(superDef) && superDef.data.animation) {
                            const defData = definition.data;
                            defData.animation = (defData.animation || []).concat(superDef.data.animation);
                        }
                    }
                    const features = superDef.features;
                    if (features) {
                        for (let i = 0; i < features.length; i++) {
                            const feature = features[i];
                            if (feature && feature.ngInherit) {
                                feature(definition);
                            }
                            if (feature === InheritDefinitionFeature) {
                                shouldInheritFields = false;
                            }
                        }
                    }
                }
                superType = Object.getPrototypeOf(superType);
            }
            mergeHostAttrsAcrossInheritance(inheritanceChain);
        }
        function mergeHostAttrsAcrossInheritance(inheritanceChain) {
            let hostVars = 0;
            let hostAttrs = null;
            for (let i = inheritanceChain.length - 1; i >= 0; i--) {
                const def = inheritanceChain[i];
                def.hostVars = hostVars += def.hostVars;
                def.hostAttrs = mergeHostAttrs(def.hostAttrs, hostAttrs = mergeHostAttrs(hostAttrs, def.hostAttrs));
            }
        }
        function maybeUnwrapEmpty(value) {
            if (value === EMPTY_OBJ) {
                return {};
            } else if (value === EMPTY_ARRAY) {
                return [];
            } else {
                return value;
            }
        }
        function inheritViewQuery(definition, superViewQuery) {
            const prevViewQuery = definition.viewQuery;
            if (prevViewQuery) {
                definition.viewQuery = (rf, ctx) => {
                    superViewQuery(rf, ctx);
                    prevViewQuery(rf, ctx);
                };
            } else {
                definition.viewQuery = superViewQuery;
            }
        }
        function inheritContentQueries(definition, superContentQueries) {
            const prevContentQueries = definition.contentQueries;
            if (prevContentQueries) {
                definition.contentQueries = (rf, ctx, directiveIndex) => {
                    superContentQueries(rf, ctx, directiveIndex);
                    prevContentQueries(rf, ctx, directiveIndex);
                };
            } else {
                definition.contentQueries = superContentQueries;
            }
        }
        function inheritHostBindings(definition, superHostBindings) {
            const prevHostBindings = definition.hostBindings;
            if (prevHostBindings) {
                definition.hostBindings = (rf, ctx) => {
                    superHostBindings(rf, ctx);
                    prevHostBindings(rf, ctx);
                };
            } else {
                definition.hostBindings = superHostBindings;
            }
        }
        const COPY_DIRECTIVE_FIELDS = [ "providersResolver" ];
        const COPY_COMPONENT_FIELDS = [ "template", "decls", "consts", "vars", "onPush", "ngContentSelectors", "styles", "encapsulation", "schemas" ];
        function CopyDefinitionFeature(definition) {
            let superType = getSuperType(definition.type);
            let superDef = void 0;
            if (isComponentDef(definition)) {
                superDef = superType.cmp;
            } else {
                superDef = superType.dir;
            }
            const defAny = definition;
            for (const field of COPY_DIRECTIVE_FIELDS) {
                defAny[field] = superDef[field];
            }
            if (isComponentDef(superDef)) {
                for (const field of COPY_COMPONENT_FIELDS) {
                    defAny[field] = superDef[field];
                }
            }
        }
        let _symbolIterator = null;
        function core_getSymbolIterator() {
            if (!_symbolIterator) {
                const Symbol2 = _global["Symbol"];
                if (Symbol2 && Symbol2.iterator) {
                    _symbolIterator = Symbol2.iterator;
                } else {
                    const keys = Object.getOwnPropertyNames(Map.prototype);
                    for (let i = 0; i < keys.length; ++i) {
                        const key = keys[i];
                        if (key !== "entries" && key !== "size" && Map.prototype[key] === Map.prototype["entries"]) {
                            _symbolIterator = key;
                        }
                    }
                }
            }
            return _symbolIterator;
        }
        function core_isIterable(obj) {
            return obj !== null && typeof obj === "object" && obj[core_getSymbolIterator()] !== void 0;
        }
        function isListLikeIterable(obj) {
            if (!isJsObject(obj)) {
                return false;
            }
            return Array.isArray(obj) || !(obj instanceof Map) && core_getSymbolIterator() in obj;
        }
        function areIterablesEqual(a, b, comparator) {
            const iterator1 = a[core_getSymbolIterator()]();
            const iterator2 = b[core_getSymbolIterator()]();
            while (true) {
                const item1 = iterator1.next();
                const item2 = iterator2.next();
                if (item1.done && item2.done) {
                    return true;
                }
                if (item1.done || item2.done) {
                    return false;
                }
                if (!comparator(item1.value, item2.value)) {
                    return false;
                }
            }
        }
        function iterateListLike(obj, fn) {
            if (Array.isArray(obj)) {
                for (let i = 0; i < obj.length; i++) {
                    fn(obj[i]);
                }
            } else {
                const iterator = obj[core_getSymbolIterator()]();
                let item;
                while (!(item = iterator.next()).done) {
                    fn(item.value);
                }
            }
        }
        function isJsObject(o) {
            return o !== null && (typeof o === "function" || typeof o === "object");
        }
        function devModeEqual(a, b) {
            const isListLikeIterableA = isListLikeIterable(a);
            const isListLikeIterableB = isListLikeIterable(b);
            if (isListLikeIterableA && isListLikeIterableB) {
                return areIterablesEqual(a, b, devModeEqual);
            } else {
                const isAObject = a && (typeof a === "object" || typeof a === "function");
                const isBObject = b && (typeof b === "object" || typeof b === "function");
                if (!isListLikeIterableA && isAObject && !isListLikeIterableB && isBObject) {
                    return true;
                } else {
                    return Object.is(a, b);
                }
            }
        }
        function updateBinding(lView, bindingIndex, value) {
            return lView[bindingIndex] = value;
        }
        function getBinding(lView, bindingIndex) {
            return lView[bindingIndex];
        }
        function bindingUpdated(lView, bindingIndex, value) {
            const oldValue = lView[bindingIndex];
            if (Object.is(oldValue, value)) {
                return false;
            } else {
                if (false) {
                    const oldValueToCompare = oldValue !== NO_CHANGE ? oldValue : void 0;
                    if (!devModeEqual(oldValueToCompare, value)) {
                        const details = getExpressionChangedErrorDetails(lView, bindingIndex, oldValueToCompare, value);
                        throwErrorIfNoChangesMode(oldValue === NO_CHANGE, details.oldValue, details.newValue, details.propName);
                    }
                    return false;
                }
                lView[bindingIndex] = value;
                return true;
            }
        }
        function bindingUpdated2(lView, bindingIndex, exp1, exp2) {
            const different = bindingUpdated(lView, bindingIndex, exp1);
            return bindingUpdated(lView, bindingIndex + 1, exp2) || different;
        }
        function bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) {
            const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);
            return bindingUpdated(lView, bindingIndex + 2, exp3) || different;
        }
        function bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) {
            const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);
            return bindingUpdated2(lView, bindingIndex + 2, exp3, exp4) || different;
        }
        function attribute(name, value, sanitizer, namespace) {
            const lView = getLView();
            const bindingIndex = nextBindingIndex();
            if (bindingUpdated(lView, bindingIndex, value)) {
                const tView = getTView();
                const tNode = getSelectedTNode();
                elementAttributeInternal(tNode, lView, name, value, sanitizer, namespace);
            }
            return attribute;
        }
        function interpolationV(lView, values) {
            let isBindingUpdated = false;
            let bindingIndex = getBindingIndex();
            for (let i = 1; i < values.length; i += 2) {
                isBindingUpdated = bindingUpdated(lView, bindingIndex++, values[i]) || isBindingUpdated;
            }
            setBindingIndex(bindingIndex);
            if (!isBindingUpdated) {
                return NO_CHANGE;
            }
            let content = values[0];
            for (let i = 1; i < values.length; i += 2) {
                content += renderStringify(values[i]) + values[i + 1];
            }
            return content;
        }
        function interpolation1(lView, prefix, v0, suffix) {
            const different = bindingUpdated(lView, nextBindingIndex(), v0);
            return different ? prefix + renderStringify(v0) + suffix : NO_CHANGE;
        }
        function interpolation2(lView, prefix, v0, i02, v1, suffix) {
            const bindingIndex = getBindingIndex();
            const different = bindingUpdated2(lView, bindingIndex, v0, v1);
            incrementBindingIndex(2);
            return different ? prefix + renderStringify(v0) + i02 + renderStringify(v1) + suffix : NO_CHANGE;
        }
        function interpolation3(lView, prefix, v0, i02, v1, i1, v2, suffix) {
            const bindingIndex = getBindingIndex();
            const different = bindingUpdated3(lView, bindingIndex, v0, v1, v2);
            incrementBindingIndex(3);
            return different ? prefix + renderStringify(v0) + i02 + renderStringify(v1) + i1 + renderStringify(v2) + suffix : NO_CHANGE;
        }
        function interpolation4(lView, prefix, v0, i02, v1, i1, v2, i2, v3, suffix) {
            const bindingIndex = getBindingIndex();
            const different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
            incrementBindingIndex(4);
            return different ? prefix + renderStringify(v0) + i02 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + suffix : NO_CHANGE;
        }
        function interpolation5(lView, prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, suffix) {
            const bindingIndex = getBindingIndex();
            let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
            different = bindingUpdated(lView, bindingIndex + 4, v4) || different;
            incrementBindingIndex(5);
            return different ? prefix + renderStringify(v0) + i02 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + suffix : NO_CHANGE;
        }
        function interpolation6(lView, prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {
            const bindingIndex = getBindingIndex();
            let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
            different = bindingUpdated2(lView, bindingIndex + 4, v4, v5) || different;
            incrementBindingIndex(6);
            return different ? prefix + renderStringify(v0) + i02 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + suffix : NO_CHANGE;
        }
        function interpolation7(lView, prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {
            const bindingIndex = getBindingIndex();
            let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
            different = bindingUpdated3(lView, bindingIndex + 4, v4, v5, v6) || different;
            incrementBindingIndex(7);
            return different ? prefix + renderStringify(v0) + i02 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + i5 + renderStringify(v6) + suffix : NO_CHANGE;
        }
        function interpolation8(lView, prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {
            const bindingIndex = getBindingIndex();
            let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
            different = bindingUpdated4(lView, bindingIndex + 4, v4, v5, v6, v7) || different;
            incrementBindingIndex(8);
            return different ? prefix + renderStringify(v0) + i02 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + i5 + renderStringify(v6) + i6 + renderStringify(v7) + suffix : NO_CHANGE;
        }
        function attributeInterpolate1(attrName, prefix, v0, suffix, sanitizer, namespace) {
            const lView = getLView();
            const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
            if (interpolatedValue !== NO_CHANGE) {
                const tNode = getSelectedTNode();
                elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
            }
            return attributeInterpolate1;
        }
        function attributeInterpolate2(attrName, prefix, v0, i02, v1, suffix, sanitizer, namespace) {
            const lView = getLView();
            const interpolatedValue = interpolation2(lView, prefix, v0, i02, v1, suffix);
            if (interpolatedValue !== NO_CHANGE) {
                const tNode = getSelectedTNode();
                elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
            }
            return attributeInterpolate2;
        }
        function attributeInterpolate3(attrName, prefix, v0, i02, v1, i1, v2, suffix, sanitizer, namespace) {
            const lView = getLView();
            const interpolatedValue = interpolation3(lView, prefix, v0, i02, v1, i1, v2, suffix);
            if (interpolatedValue !== NO_CHANGE) {
                const tNode = getSelectedTNode();
                elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
            }
            return attributeInterpolate3;
        }
        function attributeInterpolate4(attrName, prefix, v0, i02, v1, i1, v2, i2, v3, suffix, sanitizer, namespace) {
            const lView = getLView();
            const interpolatedValue = interpolation4(lView, prefix, v0, i02, v1, i1, v2, i2, v3, suffix);
            if (interpolatedValue !== NO_CHANGE) {
                const tNode = getSelectedTNode();
                elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
            }
            return attributeInterpolate4;
        }
        function attributeInterpolate5(attrName, prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, suffix, sanitizer, namespace) {
            const lView = getLView();
            const interpolatedValue = interpolation5(lView, prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, suffix);
            if (interpolatedValue !== NO_CHANGE) {
                const tNode = getSelectedTNode();
                elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
            }
            return attributeInterpolate5;
        }
        function attributeInterpolate6(attrName, prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, sanitizer, namespace) {
            const lView = getLView();
            const interpolatedValue = interpolation6(lView, prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
            if (interpolatedValue !== NO_CHANGE) {
                const tNode = getSelectedTNode();
                elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
            }
            return attributeInterpolate6;
        }
        function attributeInterpolate7(attrName, prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, sanitizer, namespace) {
            const lView = getLView();
            const interpolatedValue = interpolation7(lView, prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
            if (interpolatedValue !== NO_CHANGE) {
                const tNode = getSelectedTNode();
                elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
            }
            return attributeInterpolate7;
        }
        function attributeInterpolate8(attrName, prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, sanitizer, namespace) {
            const lView = getLView();
            const interpolatedValue = interpolation8(lView, prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
            if (interpolatedValue !== NO_CHANGE) {
                const tNode = getSelectedTNode();
                elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
            }
            return attributeInterpolate8;
        }
        function attributeInterpolateV(attrName, values, sanitizer, namespace) {
            const lView = getLView();
            const interpolated = interpolationV(lView, values);
            if (interpolated !== NO_CHANGE) {
                const tNode = getSelectedTNode();
                elementAttributeInternal(tNode, lView, attrName, interpolated, sanitizer, namespace);
                if (false) {
                    const interpolationInBetween = [ values[0] ];
                    for (let i = 2; i < values.length; i += 2) {
                        interpolationInBetween.push(values[i]);
                    }
                    storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - interpolationInBetween.length + 1, ...interpolationInBetween);
                }
            }
            return attributeInterpolateV;
        }
        function detectChanges(component) {
            const view = getComponentViewByInstance(component);
            detectChangesInternal(view[TVIEW], view, component);
        }
        function templateFirstCreatePass(index, tView, lView, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex) {
            const tViewConsts = tView.consts;
            const tNode = getOrCreateTNode(tView, index, 4, tagName || null, getConstant(tViewConsts, attrsIndex));
            resolveDirectives(tView, lView, tNode, getConstant(tViewConsts, localRefsIndex));
            registerPostOrderHooks(tView, tNode);
            const embeddedTView = tNode.tViews = createTView(2, tNode, templateFn, decls, vars, tView.directiveRegistry, tView.pipeRegistry, null, tView.schemas, tViewConsts);
            if (tView.queries !== null) {
                tView.queries.template(tView, tNode);
                embeddedTView.queries = tView.queries.embeddedTView(tNode);
            }
            return tNode;
        }
        function template(index, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex, localRefExtractor) {
            const lView = getLView();
            const tView = getTView();
            const adjustedIndex = index + HEADER_OFFSET;
            const tNode = tView.firstCreatePass ? templateFirstCreatePass(adjustedIndex, tView, lView, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex) : tView.data[adjustedIndex];
            setCurrentTNode(tNode, false);
            const comment = lView[RENDERER].createComment(false ? "container" : "");
            appendChild(tView, lView, comment, tNode);
            attachPatchData(comment, lView);
            addToViewTree(lView, lView[adjustedIndex] = createLContainer(comment, lView, comment, tNode));
            if (isDirectiveHost(tNode)) {
                createDirectivesInstances(tView, lView, tNode);
            }
            if (localRefsIndex != null) {
                saveResolvedLocalsInData(lView, tNode, localRefExtractor);
            }
        }
        function store(tView, lView, index, value) {
            if (index >= tView.data.length) {
                tView.data[index] = null;
                tView.blueprint[index] = null;
            }
            lView[index] = value;
        }
        function reference(index) {
            const contextLView = getContextLView();
            return load(contextLView, HEADER_OFFSET + index);
        }
        function property(propName, value, sanitizer) {
            const lView = getLView();
            const bindingIndex = nextBindingIndex();
            if (bindingUpdated(lView, bindingIndex, value)) {
                const tView = getTView();
                const tNode = getSelectedTNode();
                elementPropertyInternal(tView, tNode, lView, propName, value, lView[RENDERER], sanitizer, false);
            }
            return property;
        }
        function setDirectiveInputsWhichShadowsStyling(tView, tNode, lView, value, isClassBased) {
            const inputs = tNode.inputs;
            const property = isClassBased ? "class" : "style";
            setInputsForProperty(tView, lView, inputs[property], property, value);
        }
        function elementStartFirstCreatePass(index, tView, lView, native, name, attrsIndex, localRefsIndex) {
            const tViewConsts = tView.consts;
            const attrs = getConstant(tViewConsts, attrsIndex);
            const tNode = getOrCreateTNode(tView, index, 2, name, attrs);
            const hasDirectives = resolveDirectives(tView, lView, tNode, getConstant(tViewConsts, localRefsIndex));
            if (false) {
                validateElementIsKnown(native, lView, tNode.value, tView.schemas, hasDirectives);
            }
            if (tNode.attrs !== null) {
                computeStaticStyling(tNode, tNode.attrs, false);
            }
            if (tNode.mergedAttrs !== null) {
                computeStaticStyling(tNode, tNode.mergedAttrs, true);
            }
            if (tView.queries !== null) {
                tView.queries.elementStart(tView, tNode);
            }
            return tNode;
        }
        function elementStart(index, name, attrsIndex, localRefsIndex) {
            const lView = getLView();
            const tView = getTView();
            const adjustedIndex = HEADER_OFFSET + index;
            const renderer = lView[RENDERER];
            const native = lView[adjustedIndex] = createElementNode(renderer, name, getNamespace$1());
            const tNode = tView.firstCreatePass ? elementStartFirstCreatePass(adjustedIndex, tView, lView, native, name, attrsIndex, localRefsIndex) : tView.data[adjustedIndex];
            setCurrentTNode(tNode, true);
            const mergedAttrs = tNode.mergedAttrs;
            if (mergedAttrs !== null) {
                setUpAttributes(renderer, native, mergedAttrs);
            }
            const classes = tNode.classes;
            if (classes !== null) {
                writeDirectClass(renderer, native, classes);
            }
            const styles = tNode.styles;
            if (styles !== null) {
                writeDirectStyle(renderer, native, styles);
            }
            if ((tNode.flags & 64) !== 64) {
                appendChild(tView, lView, native, tNode);
            }
            if (getElementDepthCount() === 0) {
                attachPatchData(native, lView);
            }
            increaseElementDepthCount();
            if (isDirectiveHost(tNode)) {
                createDirectivesInstances(tView, lView, tNode);
                executeContentQueries(tView, tNode, lView);
            }
            if (localRefsIndex !== null) {
                saveResolvedLocalsInData(lView, tNode);
            }
            return elementStart;
        }
        function elementEnd() {
            let currentTNode = getCurrentTNode();
            if (isCurrentTNodeParent()) {
                setCurrentTNodeAsNotParent();
            } else {
                currentTNode = currentTNode.parent;
                setCurrentTNode(currentTNode, false);
            }
            const tNode = currentTNode;
            decreaseElementDepthCount();
            const tView = getTView();
            if (tView.firstCreatePass) {
                registerPostOrderHooks(tView, currentTNode);
                if (isContentQueryHost(currentTNode)) {
                    tView.queries.elementEnd(currentTNode);
                }
            }
            if (tNode.classesWithoutHost != null && hasClassInput(tNode)) {
                setDirectiveInputsWhichShadowsStyling(tView, tNode, getLView(), tNode.classesWithoutHost, true);
            }
            if (tNode.stylesWithoutHost != null && hasStyleInput(tNode)) {
                setDirectiveInputsWhichShadowsStyling(tView, tNode, getLView(), tNode.stylesWithoutHost, false);
            }
            return elementEnd;
        }
        function element(index, name, attrsIndex, localRefsIndex) {
            elementStart(index, name, attrsIndex, localRefsIndex);
            elementEnd();
            return element;
        }
        function elementContainerStartFirstCreatePass(index, tView, lView, attrsIndex, localRefsIndex) {
            const tViewConsts = tView.consts;
            const attrs = getConstant(tViewConsts, attrsIndex);
            const tNode = getOrCreateTNode(tView, index, 8, "ng-container", attrs);
            if (attrs !== null) {
                computeStaticStyling(tNode, attrs, true);
            }
            const localRefs = getConstant(tViewConsts, localRefsIndex);
            resolveDirectives(tView, lView, tNode, localRefs);
            if (tView.queries !== null) {
                tView.queries.elementStart(tView, tNode);
            }
            return tNode;
        }
        function elementContainerStart(index, attrsIndex, localRefsIndex) {
            const lView = getLView();
            const tView = getTView();
            const adjustedIndex = index + HEADER_OFFSET;
            const tNode = tView.firstCreatePass ? elementContainerStartFirstCreatePass(adjustedIndex, tView, lView, attrsIndex, localRefsIndex) : tView.data[adjustedIndex];
            setCurrentTNode(tNode, true);
            const native = lView[adjustedIndex] = lView[RENDERER].createComment(false ? "ng-container" : "");
            appendChild(tView, lView, native, tNode);
            attachPatchData(native, lView);
            if (isDirectiveHost(tNode)) {
                createDirectivesInstances(tView, lView, tNode);
                executeContentQueries(tView, tNode, lView);
            }
            if (localRefsIndex != null) {
                saveResolvedLocalsInData(lView, tNode);
            }
            return elementContainerStart;
        }
        function elementContainerEnd() {
            let currentTNode = getCurrentTNode();
            const tView = getTView();
            if (isCurrentTNodeParent()) {
                setCurrentTNodeAsNotParent();
            } else {
                currentTNode = currentTNode.parent;
                setCurrentTNode(currentTNode, false);
            }
            if (tView.firstCreatePass) {
                registerPostOrderHooks(tView, currentTNode);
                if (isContentQueryHost(currentTNode)) {
                    tView.queries.elementEnd(currentTNode);
                }
            }
            return elementContainerEnd;
        }
        function elementContainer(index, attrsIndex, localRefsIndex) {
            elementContainerStart(index, attrsIndex, localRefsIndex);
            elementContainerEnd();
            return elementContainer;
        }
        function getCurrentView() {
            return getLView();
        }
        function core_isPromise(obj) {
            return !!obj && typeof obj.then === "function";
        }
        function isSubscribable(obj) {
            return !!obj && typeof obj.subscribe === "function";
        }
        const isObservable = isSubscribable;
        function listener(eventName, listenerFn, useCapture, eventTargetResolver) {
            const lView = getLView();
            const tView = getTView();
            const tNode = getCurrentTNode();
            listenerInternal(tView, lView, lView[RENDERER], tNode, eventName, listenerFn, !!useCapture, eventTargetResolver);
            return listener;
        }
        function syntheticHostListener(eventName, listenerFn) {
            const tNode = getCurrentTNode();
            const lView = getLView();
            const tView = getTView();
            const currentDef = getCurrentDirectiveDef(tView.data);
            const renderer = loadComponentRenderer(currentDef, tNode, lView);
            listenerInternal(tView, lView, renderer, tNode, eventName, listenerFn, false);
            return syntheticHostListener;
        }
        function findExistingListener(tView, lView, eventName, tNodeIdx) {
            const tCleanup = tView.cleanup;
            if (tCleanup != null) {
                for (let i = 0; i < tCleanup.length - 1; i += 2) {
                    const cleanupEventName = tCleanup[i];
                    if (cleanupEventName === eventName && tCleanup[i + 1] === tNodeIdx) {
                        const lCleanup = lView[CLEANUP];
                        const listenerIdxInLCleanup = tCleanup[i + 2];
                        return lCleanup.length > listenerIdxInLCleanup ? lCleanup[listenerIdxInLCleanup] : null;
                    }
                    if (typeof cleanupEventName === "string") {
                        i += 2;
                    }
                }
            }
            return null;
        }
        function listenerInternal(tView, lView, renderer, tNode, eventName, listenerFn, useCapture, eventTargetResolver) {
            const isTNodeDirectiveHost = isDirectiveHost(tNode);
            const firstCreatePass = tView.firstCreatePass;
            const tCleanup = firstCreatePass && getOrCreateTViewCleanup(tView);
            const context2 = lView[CONTEXT];
            const lCleanup = getOrCreateLViewCleanup(lView);
            let processOutputs = true;
            if (tNode.type & 3 || eventTargetResolver) {
                const native = getNativeByTNode(tNode, lView);
                const target = eventTargetResolver ? eventTargetResolver(native) : native;
                const lCleanupIndex = lCleanup.length;
                const idxOrTargetGetter = eventTargetResolver ? _lView => eventTargetResolver(unwrapRNode(_lView[tNode.index])) : tNode.index;
                let existingListener = null;
                if (!eventTargetResolver && isTNodeDirectiveHost) {
                    existingListener = findExistingListener(tView, lView, eventName, tNode.index);
                }
                if (existingListener !== null) {
                    const lastListenerFn = existingListener.__ngLastListenerFn__ || existingListener;
                    lastListenerFn.__ngNextListenerFn__ = listenerFn;
                    existingListener.__ngLastListenerFn__ = listenerFn;
                    processOutputs = false;
                } else {
                    listenerFn = wrapListener(tNode, lView, context2, listenerFn, false);
                    const cleanupFn = renderer.listen(target, eventName, listenerFn);
                    lCleanup.push(listenerFn, cleanupFn);
                    tCleanup && tCleanup.push(eventName, idxOrTargetGetter, lCleanupIndex, lCleanupIndex + 1);
                }
            } else {
                listenerFn = wrapListener(tNode, lView, context2, listenerFn, false);
            }
            const outputs = tNode.outputs;
            let props;
            if (processOutputs && outputs !== null && (props = outputs[eventName])) {
                const propsLength = props.length;
                if (propsLength) {
                    for (let i = 0; i < propsLength; i += 2) {
                        const index = props[i];
                        const minifiedName = props[i + 1];
                        const directiveInstance = lView[index];
                        const output = directiveInstance[minifiedName];
                        if (false) {
                            throw new Error(`@Output ${minifiedName} not initialized in '${directiveInstance.constructor.name}'.`);
                        }
                        const subscription = output.subscribe(listenerFn);
                        const idx = lCleanup.length;
                        lCleanup.push(listenerFn, subscription);
                        tCleanup && tCleanup.push(eventName, tNode.index, idx, -(idx + 1));
                    }
                }
            }
        }
        function executeListenerWithErrorHandling(lView, context2, listenerFn, e) {
            try {
                profiler(6, context2, listenerFn);
                return listenerFn(e) !== false;
            } catch (error) {
                handleError(lView, error);
                return false;
            } finally {
                profiler(7, context2, listenerFn);
            }
        }
        function wrapListener(tNode, lView, context2, listenerFn, wrapWithPreventDefault) {
            return function wrapListenerIn_markDirtyAndPreventDefault(e) {
                if (e === Function) {
                    return listenerFn;
                }
                const startView = tNode.flags & 2 ? getComponentLViewByIndex(tNode.index, lView) : lView;
                markViewDirty(startView);
                let result = executeListenerWithErrorHandling(lView, context2, listenerFn, e);
                let nextListenerFn = wrapListenerIn_markDirtyAndPreventDefault.__ngNextListenerFn__;
                while (nextListenerFn) {
                    result = executeListenerWithErrorHandling(lView, context2, nextListenerFn, e) && result;
                    nextListenerFn = nextListenerFn.__ngNextListenerFn__;
                }
                if (wrapWithPreventDefault && result === false) {
                    e.preventDefault();
                    e.returnValue = false;
                }
                return result;
            };
        }
        function nextContext(level = 1) {
            return nextContextImpl(level);
        }
        function matchingProjectionSlotIndex(tNode, projectionSlots) {
            let wildcardNgContentIndex = null;
            const ngProjectAsAttrVal = getProjectAsAttrValue(tNode);
            for (let i = 0; i < projectionSlots.length; i++) {
                const slotValue = projectionSlots[i];
                if (slotValue === "*") {
                    wildcardNgContentIndex = i;
                    continue;
                }
                if (ngProjectAsAttrVal === null ? isNodeMatchingSelectorList(tNode, slotValue, true) : isSelectorInSelectorList(ngProjectAsAttrVal, slotValue)) {
                    return i;
                }
            }
            return wildcardNgContentIndex;
        }
        function projectionDef(projectionSlots) {
            const componentNode = getLView()[DECLARATION_COMPONENT_VIEW][T_HOST];
            if (!componentNode.projection) {
                const numProjectionSlots = projectionSlots ? projectionSlots.length : 1;
                const projectionHeads = componentNode.projection = newArray(numProjectionSlots, null);
                const tails = projectionHeads.slice();
                let componentChild = componentNode.child;
                while (componentChild !== null) {
                    const slotIndex = projectionSlots ? matchingProjectionSlotIndex(componentChild, projectionSlots) : 0;
                    if (slotIndex !== null) {
                        if (tails[slotIndex]) {
                            tails[slotIndex].projectionNext = componentChild;
                        } else {
                            projectionHeads[slotIndex] = componentChild;
                        }
                        tails[slotIndex] = componentChild;
                    }
                    componentChild = componentChild.next;
                }
            }
        }
        function projection(nodeIndex, selectorIndex = 0, attrs) {
            const lView = getLView();
            const tView = getTView();
            const tProjectionNode = getOrCreateTNode(tView, HEADER_OFFSET + nodeIndex, 16, null, attrs || null);
            if (tProjectionNode.projection === null) {
                tProjectionNode.projection = selectorIndex;
            }
            setCurrentTNodeAsNotParent();
            if ((tProjectionNode.flags & 64) !== 64) {
                applyProjection(tView, lView, tProjectionNode);
            }
        }
        function propertyInterpolate(propName, v0, sanitizer) {
            propertyInterpolate1(propName, "", v0, "", sanitizer);
            return propertyInterpolate;
        }
        function propertyInterpolate1(propName, prefix, v0, suffix, sanitizer) {
            const lView = getLView();
            const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
            if (interpolatedValue !== NO_CHANGE) {
                const tView = getTView();
                const tNode = getSelectedTNode();
                elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
            }
            return propertyInterpolate1;
        }
        function propertyInterpolate2(propName, prefix, v0, i02, v1, suffix, sanitizer) {
            const lView = getLView();
            const interpolatedValue = interpolation2(lView, prefix, v0, i02, v1, suffix);
            if (interpolatedValue !== NO_CHANGE) {
                const tView = getTView();
                const tNode = getSelectedTNode();
                elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
            }
            return propertyInterpolate2;
        }
        function propertyInterpolate3(propName, prefix, v0, i02, v1, i1, v2, suffix, sanitizer) {
            const lView = getLView();
            const interpolatedValue = interpolation3(lView, prefix, v0, i02, v1, i1, v2, suffix);
            if (interpolatedValue !== NO_CHANGE) {
                const tView = getTView();
                const tNode = getSelectedTNode();
                elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
            }
            return propertyInterpolate3;
        }
        function propertyInterpolate4(propName, prefix, v0, i02, v1, i1, v2, i2, v3, suffix, sanitizer) {
            const lView = getLView();
            const interpolatedValue = interpolation4(lView, prefix, v0, i02, v1, i1, v2, i2, v3, suffix);
            if (interpolatedValue !== NO_CHANGE) {
                const tView = getTView();
                const tNode = getSelectedTNode();
                elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
            }
            return propertyInterpolate4;
        }
        function propertyInterpolate5(propName, prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, suffix, sanitizer) {
            const lView = getLView();
            const interpolatedValue = interpolation5(lView, prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, suffix);
            if (interpolatedValue !== NO_CHANGE) {
                const tView = getTView();
                const tNode = getSelectedTNode();
                elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
            }
            return propertyInterpolate5;
        }
        function propertyInterpolate6(propName, prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, sanitizer) {
            const lView = getLView();
            const interpolatedValue = interpolation6(lView, prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
            if (interpolatedValue !== NO_CHANGE) {
                const tView = getTView();
                const tNode = getSelectedTNode();
                elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
            }
            return propertyInterpolate6;
        }
        function propertyInterpolate7(propName, prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, sanitizer) {
            const lView = getLView();
            const interpolatedValue = interpolation7(lView, prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
            if (interpolatedValue !== NO_CHANGE) {
                const tView = getTView();
                const tNode = getSelectedTNode();
                elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
            }
            return propertyInterpolate7;
        }
        function propertyInterpolate8(propName, prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, sanitizer) {
            const lView = getLView();
            const interpolatedValue = interpolation8(lView, prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
            if (interpolatedValue !== NO_CHANGE) {
                const tView = getTView();
                const tNode = getSelectedTNode();
                elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
            }
            return propertyInterpolate8;
        }
        function propertyInterpolateV(propName, values, sanitizer) {
            const lView = getLView();
            const interpolatedValue = interpolationV(lView, values);
            if (interpolatedValue !== NO_CHANGE) {
                const tView = getTView();
                const tNode = getSelectedTNode();
                elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
                if (false) {
                    const interpolationInBetween = [ values[0] ];
                    for (let i = 2; i < values.length; i += 2) {
                        interpolationInBetween.push(values[i]);
                    }
                    storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - interpolationInBetween.length + 1, ...interpolationInBetween);
                }
            }
            return propertyInterpolateV;
        }
        let __unused_const_as_closure_does_not_like_standalone_comment_blocks__;
        function insertTStylingBinding(tData, tNode, tStylingKeyWithStatic, index, isHostBinding, isClassBinding) {
            let tBindings = isClassBinding ? tNode.classBindings : tNode.styleBindings;
            let tmplHead = getTStylingRangePrev(tBindings);
            let tmplTail = getTStylingRangeNext(tBindings);
            tData[index] = tStylingKeyWithStatic;
            let isKeyDuplicateOfStatic = false;
            let tStylingKey;
            if (Array.isArray(tStylingKeyWithStatic)) {
                const staticKeyValueArray = tStylingKeyWithStatic;
                tStylingKey = staticKeyValueArray[1];
                if (tStylingKey === null || keyValueArrayIndexOf(staticKeyValueArray, tStylingKey) > 0) {
                    isKeyDuplicateOfStatic = true;
                }
            } else {
                tStylingKey = tStylingKeyWithStatic;
            }
            if (isHostBinding) {
                const hasTemplateBindings = tmplTail !== 0;
                if (hasTemplateBindings) {
                    const previousNode = getTStylingRangePrev(tData[tmplHead + 1]);
                    tData[index + 1] = toTStylingRange(previousNode, tmplHead);
                    if (previousNode !== 0) {
                        tData[previousNode + 1] = setTStylingRangeNext(tData[previousNode + 1], index);
                    }
                    tData[tmplHead + 1] = setTStylingRangePrev(tData[tmplHead + 1], index);
                } else {
                    tData[index + 1] = toTStylingRange(tmplHead, 0);
                    if (tmplHead !== 0) {
                        tData[tmplHead + 1] = setTStylingRangeNext(tData[tmplHead + 1], index);
                    }
                    tmplHead = index;
                }
            } else {
                tData[index + 1] = toTStylingRange(tmplTail, 0);
                if (tmplHead === 0) {
                    tmplHead = index;
                } else {
                    tData[tmplTail + 1] = setTStylingRangeNext(tData[tmplTail + 1], index);
                }
                tmplTail = index;
            }
            if (isKeyDuplicateOfStatic) {
                tData[index + 1] = setTStylingRangePrevDuplicate(tData[index + 1]);
            }
            markDuplicates(tData, tStylingKey, index, true, isClassBinding);
            markDuplicates(tData, tStylingKey, index, false, isClassBinding);
            markDuplicateOfResidualStyling(tNode, tStylingKey, tData, index, isClassBinding);
            tBindings = toTStylingRange(tmplHead, tmplTail);
            if (isClassBinding) {
                tNode.classBindings = tBindings;
            } else {
                tNode.styleBindings = tBindings;
            }
        }
        function markDuplicateOfResidualStyling(tNode, tStylingKey, tData, index, isClassBinding) {
            const residual = isClassBinding ? tNode.residualClasses : tNode.residualStyles;
            if (residual != null && typeof tStylingKey == "string" && keyValueArrayIndexOf(residual, tStylingKey) >= 0) {
                tData[index + 1] = setTStylingRangeNextDuplicate(tData[index + 1]);
            }
        }
        function markDuplicates(tData, tStylingKey, index, isPrevDir, isClassBinding) {
            const tStylingAtIndex = tData[index + 1];
            const isMap = tStylingKey === null;
            let cursor = isPrevDir ? getTStylingRangePrev(tStylingAtIndex) : getTStylingRangeNext(tStylingAtIndex);
            let foundDuplicate = false;
            while (cursor !== 0 && (foundDuplicate === false || isMap)) {
                const tStylingValueAtCursor = tData[cursor];
                const tStyleRangeAtCursor = tData[cursor + 1];
                if (isStylingMatch(tStylingValueAtCursor, tStylingKey)) {
                    foundDuplicate = true;
                    tData[cursor + 1] = isPrevDir ? setTStylingRangeNextDuplicate(tStyleRangeAtCursor) : setTStylingRangePrevDuplicate(tStyleRangeAtCursor);
                }
                cursor = isPrevDir ? getTStylingRangePrev(tStyleRangeAtCursor) : getTStylingRangeNext(tStyleRangeAtCursor);
            }
            if (foundDuplicate) {
                tData[index + 1] = isPrevDir ? setTStylingRangePrevDuplicate(tStylingAtIndex) : setTStylingRangeNextDuplicate(tStylingAtIndex);
            }
        }
        function isStylingMatch(tStylingKeyCursor, tStylingKey) {
            if (tStylingKeyCursor === null || tStylingKey == null || (Array.isArray(tStylingKeyCursor) ? tStylingKeyCursor[1] : tStylingKeyCursor) === tStylingKey) {
                return true;
            } else if (Array.isArray(tStylingKeyCursor) && typeof tStylingKey === "string") {
                return keyValueArrayIndexOf(tStylingKeyCursor, tStylingKey) >= 0;
            }
            return false;
        }
        const parserState = {
            textEnd: 0,
            key: 0,
            keyEnd: 0,
            value: 0,
            valueEnd: 0
        };
        function getLastParsedKey(text) {
            return text.substring(parserState.key, parserState.keyEnd);
        }
        function getLastParsedValue(text) {
            return text.substring(parserState.value, parserState.valueEnd);
        }
        function parseClassName(text) {
            resetParserState(text);
            return parseClassNameNext(text, consumeWhitespace(text, 0, parserState.textEnd));
        }
        function parseClassNameNext(text, index) {
            const end = parserState.textEnd;
            if (end === index) {
                return -1;
            }
            index = parserState.keyEnd = consumeClassToken(text, parserState.key = index, end);
            return consumeWhitespace(text, index, end);
        }
        function parseStyle(text) {
            resetParserState(text);
            return parseStyleNext(text, consumeWhitespace(text, 0, parserState.textEnd));
        }
        function parseStyleNext(text, startIndex) {
            const end = parserState.textEnd;
            let index = parserState.key = consumeWhitespace(text, startIndex, end);
            if (end === index) {
                return -1;
            }
            index = parserState.keyEnd = consumeStyleKey(text, index, end);
            index = consumeSeparator(text, index, end, 58);
            index = parserState.value = consumeWhitespace(text, index, end);
            index = parserState.valueEnd = consumeStyleValue(text, index, end);
            return consumeSeparator(text, index, end, 59);
        }
        function resetParserState(text) {
            parserState.key = 0;
            parserState.keyEnd = 0;
            parserState.value = 0;
            parserState.valueEnd = 0;
            parserState.textEnd = text.length;
        }
        function consumeWhitespace(text, startIndex, endIndex) {
            while (startIndex < endIndex && text.charCodeAt(startIndex) <= 32) {
                startIndex++;
            }
            return startIndex;
        }
        function consumeClassToken(text, startIndex, endIndex) {
            while (startIndex < endIndex && text.charCodeAt(startIndex) > 32) {
                startIndex++;
            }
            return startIndex;
        }
        function consumeStyleKey(text, startIndex, endIndex) {
            let ch;
            while (startIndex < endIndex && ((ch = text.charCodeAt(startIndex)) === 45 || ch === 95 || (ch & -33) >= 65 && (ch & -33) <= 90 || ch >= 48 && ch <= 57)) {
                startIndex++;
            }
            return startIndex;
        }
        function consumeSeparator(text, startIndex, endIndex, separator) {
            startIndex = consumeWhitespace(text, startIndex, endIndex);
            if (startIndex < endIndex) {
                if (false) {
                    malformedStyleError(text, String.fromCharCode(separator), startIndex);
                }
                startIndex++;
            }
            return startIndex;
        }
        function consumeStyleValue(text, startIndex, endIndex) {
            let ch1 = -1;
            let ch2 = -1;
            let ch3 = -1;
            let i = startIndex;
            let lastChIndex = i;
            while (i < endIndex) {
                const ch = text.charCodeAt(i++);
                if (ch === 59) {
                    return lastChIndex;
                } else if (ch === 34 || ch === 39) {
                    lastChIndex = i = consumeQuotedText(text, ch, i, endIndex);
                } else if (startIndex === i - 4 && ch3 === 85 && ch2 === 82 && ch1 === 76 && ch === 40) {
                    lastChIndex = i = consumeQuotedText(text, 41, i, endIndex);
                } else if (ch > 32) {
                    lastChIndex = i;
                }
                ch3 = ch2;
                ch2 = ch1;
                ch1 = ch & -33;
            }
            return lastChIndex;
        }
        function consumeQuotedText(text, quoteCharCode, startIndex, endIndex) {
            let ch1 = -1;
            let index = startIndex;
            while (index < endIndex) {
                const ch = text.charCodeAt(index++);
                if (ch == quoteCharCode && ch1 !== 92) {
                    return index;
                }
                if (ch == 92 && ch1 === 92) {
                    ch1 = 0;
                } else {
                    ch1 = ch;
                }
            }
            throw false ? malformedStyleError(text, String.fromCharCode(quoteCharCode), endIndex) : new Error;
        }
        function malformedStyleError(text, expecting, index) {
            throw throwError(`Malformed style at location ${index} in string '` + text.substring(0, index) + "[>>" + text.substring(index, index + 1) + "<<]" + text.slice(index + 1) + `'. Expecting '${expecting}'.`);
        }
        function styleProp(prop, value, suffix) {
            checkStylingProperty(prop, value, suffix, false);
            return styleProp;
        }
        function classProp(className, value) {
            checkStylingProperty(className, value, null, true);
            return classProp;
        }
        function styleMap(styles) {
            checkStylingMap(styleKeyValueArraySet, styleStringParser, styles, false);
        }
        function styleStringParser(keyValueArray, text) {
            for (let i = parseStyle(text); i >= 0; i = parseStyleNext(text, i)) {
                styleKeyValueArraySet(keyValueArray, getLastParsedKey(text), getLastParsedValue(text));
            }
        }
        function classMap(classes) {
            checkStylingMap(keyValueArraySet, classStringParser, classes, true);
        }
        function classStringParser(keyValueArray, text) {
            for (let i = parseClassName(text); i >= 0; i = parseClassNameNext(text, i)) {
                keyValueArraySet(keyValueArray, getLastParsedKey(text), true);
            }
        }
        function checkStylingProperty(prop, value, suffix, isClassBased) {
            const lView = getLView();
            const tView = getTView();
            const bindingIndex = incrementBindingIndex(2);
            if (tView.firstUpdatePass) {
                stylingFirstUpdatePass(tView, prop, bindingIndex, isClassBased);
            }
            if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {
                const tNode = tView.data[getSelectedIndex()];
                updateStyling(tView, tNode, lView, lView[RENDERER], prop, lView[bindingIndex + 1] = normalizeSuffix(value, suffix), isClassBased, bindingIndex);
            }
        }
        function checkStylingMap(keyValueArraySet2, stringParser, value, isClassBased) {
            const tView = getTView();
            const bindingIndex = incrementBindingIndex(2);
            if (tView.firstUpdatePass) {
                stylingFirstUpdatePass(tView, null, bindingIndex, isClassBased);
            }
            const lView = getLView();
            if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {
                const tNode = tView.data[getSelectedIndex()];
                if (hasStylingInputShadow(tNode, isClassBased) && !isInHostBindings(tView, bindingIndex)) {
                    if (false) {
                        const tStylingKey = tView.data[bindingIndex];
                        assertEqual(Array.isArray(tStylingKey) ? tStylingKey[1] : tStylingKey, false, "Styling linked list shadow input should be marked as 'false'");
                    }
                    let staticPrefix = isClassBased ? tNode.classesWithoutHost : tNode.stylesWithoutHost;
                    if (staticPrefix !== null) {
                        value = concatStringsWithSpace(staticPrefix, value ? value : "");
                    }
                    setDirectiveInputsWhichShadowsStyling(tView, tNode, lView, value, isClassBased);
                } else {
                    updateStylingMap(tView, tNode, lView, lView[RENDERER], lView[bindingIndex + 1], lView[bindingIndex + 1] = toStylingKeyValueArray(keyValueArraySet2, stringParser, value), isClassBased, bindingIndex);
                }
            }
        }
        function isInHostBindings(tView, bindingIndex) {
            return bindingIndex >= tView.expandoStartIndex;
        }
        function stylingFirstUpdatePass(tView, tStylingKey, bindingIndex, isClassBased) {
            const tData = tView.data;
            if (tData[bindingIndex + 1] === null) {
                const tNode = tData[getSelectedIndex()];
                const isHostBindings = isInHostBindings(tView, bindingIndex);
                if (hasStylingInputShadow(tNode, isClassBased) && tStylingKey === null && !isHostBindings) {
                    tStylingKey = false;
                }
                tStylingKey = wrapInStaticStylingKey(tData, tNode, tStylingKey, isClassBased);
                insertTStylingBinding(tData, tNode, tStylingKey, bindingIndex, isHostBindings, isClassBased);
            }
        }
        function wrapInStaticStylingKey(tData, tNode, stylingKey, isClassBased) {
            const hostDirectiveDef = getCurrentDirectiveDef(tData);
            let residual = isClassBased ? tNode.residualClasses : tNode.residualStyles;
            if (hostDirectiveDef === null) {
                const isFirstStylingInstructionInTemplate = (isClassBased ? tNode.classBindings : tNode.styleBindings) === 0;
                if (isFirstStylingInstructionInTemplate) {
                    stylingKey = collectStylingFromDirectives(null, tData, tNode, stylingKey, isClassBased);
                    stylingKey = collectStylingFromTAttrs(stylingKey, tNode.attrs, isClassBased);
                    residual = null;
                }
            } else {
                const directiveStylingLast = tNode.directiveStylingLast;
                const isFirstStylingInstructionInHostBinding = directiveStylingLast === -1 || tData[directiveStylingLast] !== hostDirectiveDef;
                if (isFirstStylingInstructionInHostBinding) {
                    stylingKey = collectStylingFromDirectives(hostDirectiveDef, tData, tNode, stylingKey, isClassBased);
                    if (residual === null) {
                        let templateStylingKey = getTemplateHeadTStylingKey(tData, tNode, isClassBased);
                        if (templateStylingKey !== void 0 && Array.isArray(templateStylingKey)) {
                            templateStylingKey = collectStylingFromDirectives(null, tData, tNode, templateStylingKey[1], isClassBased);
                            templateStylingKey = collectStylingFromTAttrs(templateStylingKey, tNode.attrs, isClassBased);
                            setTemplateHeadTStylingKey(tData, tNode, isClassBased, templateStylingKey);
                        }
                    } else {
                        residual = collectResidual(tData, tNode, isClassBased);
                    }
                }
            }
            if (residual !== void 0) {
                isClassBased ? tNode.residualClasses = residual : tNode.residualStyles = residual;
            }
            return stylingKey;
        }
        function getTemplateHeadTStylingKey(tData, tNode, isClassBased) {
            const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;
            if (getTStylingRangeNext(bindings) === 0) {
                return void 0;
            }
            return tData[getTStylingRangePrev(bindings)];
        }
        function setTemplateHeadTStylingKey(tData, tNode, isClassBased, tStylingKey) {
            const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;
            tData[getTStylingRangePrev(bindings)] = tStylingKey;
        }
        function collectResidual(tData, tNode, isClassBased) {
            let residual = void 0;
            const directiveEnd = tNode.directiveEnd;
            for (let i = 1 + tNode.directiveStylingLast; i < directiveEnd; i++) {
                const attrs = tData[i].hostAttrs;
                residual = collectStylingFromTAttrs(residual, attrs, isClassBased);
            }
            return collectStylingFromTAttrs(residual, tNode.attrs, isClassBased);
        }
        function collectStylingFromDirectives(hostDirectiveDef, tData, tNode, stylingKey, isClassBased) {
            let currentDirective = null;
            const directiveEnd = tNode.directiveEnd;
            let directiveStylingLast = tNode.directiveStylingLast;
            if (directiveStylingLast === -1) {
                directiveStylingLast = tNode.directiveStart;
            } else {
                directiveStylingLast++;
            }
            while (directiveStylingLast < directiveEnd) {
                currentDirective = tData[directiveStylingLast];
                stylingKey = collectStylingFromTAttrs(stylingKey, currentDirective.hostAttrs, isClassBased);
                if (currentDirective === hostDirectiveDef) {
                    break;
                }
                directiveStylingLast++;
            }
            if (hostDirectiveDef !== null) {
                tNode.directiveStylingLast = directiveStylingLast;
            }
            return stylingKey;
        }
        function collectStylingFromTAttrs(stylingKey, attrs, isClassBased) {
            const desiredMarker = isClassBased ? 1 : 2;
            let currentMarker = -1;
            if (attrs !== null) {
                for (let i = 0; i < attrs.length; i++) {
                    const item = attrs[i];
                    if (typeof item === "number") {
                        currentMarker = item;
                    } else {
                        if (currentMarker === desiredMarker) {
                            if (!Array.isArray(stylingKey)) {
                                stylingKey = stylingKey === void 0 ? [] : [ "", stylingKey ];
                            }
                            keyValueArraySet(stylingKey, item, isClassBased ? true : attrs[++i]);
                        }
                    }
                }
            }
            return stylingKey === void 0 ? null : stylingKey;
        }
        function toStylingKeyValueArray(keyValueArraySet2, stringParser, value) {
            if (value == null || value === "") {
                return EMPTY_ARRAY;
            }
            const styleKeyValueArray = [];
            const unwrappedValue = unwrapSafeValue(value);
            if (Array.isArray(unwrappedValue)) {
                for (let i = 0; i < unwrappedValue.length; i++) {
                    keyValueArraySet2(styleKeyValueArray, unwrappedValue[i], true);
                }
            } else if (typeof unwrappedValue === "object") {
                for (const key in unwrappedValue) {
                    if (unwrappedValue.hasOwnProperty(key)) {
                        keyValueArraySet2(styleKeyValueArray, key, unwrappedValue[key]);
                    }
                }
            } else if (typeof unwrappedValue === "string") {
                stringParser(styleKeyValueArray, unwrappedValue);
            } else {}
            return styleKeyValueArray;
        }
        function styleKeyValueArraySet(keyValueArray, key, value) {
            keyValueArraySet(keyValueArray, key, unwrapSafeValue(value));
        }
        function updateStylingMap(tView, tNode, lView, renderer, oldKeyValueArray, newKeyValueArray, isClassBased, bindingIndex) {
            if (oldKeyValueArray === NO_CHANGE) {
                oldKeyValueArray = EMPTY_ARRAY;
            }
            let oldIndex = 0;
            let newIndex = 0;
            let oldKey = 0 < oldKeyValueArray.length ? oldKeyValueArray[0] : null;
            let newKey = 0 < newKeyValueArray.length ? newKeyValueArray[0] : null;
            while (oldKey !== null || newKey !== null) {
                const oldValue = oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex + 1] : void 0;
                const newValue = newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex + 1] : void 0;
                let setKey = null;
                let setValue = void 0;
                if (oldKey === newKey) {
                    oldIndex += 2;
                    newIndex += 2;
                    if (oldValue !== newValue) {
                        setKey = newKey;
                        setValue = newValue;
                    }
                } else if (newKey === null || oldKey !== null && oldKey < newKey) {
                    oldIndex += 2;
                    setKey = oldKey;
                } else {
                    newIndex += 2;
                    setKey = newKey;
                    setValue = newValue;
                }
                if (setKey !== null) {
                    updateStyling(tView, tNode, lView, renderer, setKey, setValue, isClassBased, bindingIndex);
                }
                oldKey = oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex] : null;
                newKey = newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex] : null;
            }
        }
        function updateStyling(tView, tNode, lView, renderer, prop, value, isClassBased, bindingIndex) {
            if (!(tNode.type & 3)) {
                return;
            }
            const tData = tView.data;
            const tRange = tData[bindingIndex + 1];
            const higherPriorityValue = getTStylingRangeNextDuplicate(tRange) ? findStylingValue(tData, tNode, lView, prop, getTStylingRangeNext(tRange), isClassBased) : void 0;
            if (!isStylingValuePresent(higherPriorityValue)) {
                if (!isStylingValuePresent(value)) {
                    if (getTStylingRangePrevDuplicate(tRange)) {
                        value = findStylingValue(tData, null, lView, prop, bindingIndex, isClassBased);
                    }
                }
                const rNode = getNativeByIndex(getSelectedIndex(), lView);
                applyStyling(renderer, isClassBased, rNode, prop, value);
            }
        }
        function findStylingValue(tData, tNode, lView, prop, index, isClassBased) {
            const isPrevDirection = tNode === null;
            let value = void 0;
            while (index > 0) {
                const rawKey = tData[index];
                const containsStatics = Array.isArray(rawKey);
                const key = containsStatics ? rawKey[1] : rawKey;
                const isStylingMap = key === null;
                let valueAtLViewIndex = lView[index + 1];
                if (valueAtLViewIndex === NO_CHANGE) {
                    valueAtLViewIndex = isStylingMap ? EMPTY_ARRAY : void 0;
                }
                let currentValue = isStylingMap ? keyValueArrayGet(valueAtLViewIndex, prop) : key === prop ? valueAtLViewIndex : void 0;
                if (containsStatics && !isStylingValuePresent(currentValue)) {
                    currentValue = keyValueArrayGet(rawKey, prop);
                }
                if (isStylingValuePresent(currentValue)) {
                    value = currentValue;
                    if (isPrevDirection) {
                        return value;
                    }
                }
                const tRange = tData[index + 1];
                index = isPrevDirection ? getTStylingRangePrev(tRange) : getTStylingRangeNext(tRange);
            }
            if (tNode !== null) {
                let residual = isClassBased ? tNode.residualClasses : tNode.residualStyles;
                if (residual != null) {
                    value = keyValueArrayGet(residual, prop);
                }
            }
            return value;
        }
        function isStylingValuePresent(value) {
            return value !== void 0;
        }
        function normalizeSuffix(value, suffix) {
            if (value == null) {} else if (typeof suffix === "string") {
                value = value + suffix;
            } else if (typeof value === "object") {
                value = stringify(unwrapSafeValue(value));
            }
            return value;
        }
        function hasStylingInputShadow(tNode, isClassBased) {
            return (tNode.flags & (isClassBased ? 16 : 32)) !== 0;
        }
        function text(index, value = "") {
            const lView = getLView();
            const tView = getTView();
            const adjustedIndex = index + HEADER_OFFSET;
            const tNode = tView.firstCreatePass ? getOrCreateTNode(tView, adjustedIndex, 1, value, null) : tView.data[adjustedIndex];
            const textNative = lView[adjustedIndex] = createTextNode(lView[RENDERER], value);
            appendChild(tView, lView, textNative, tNode);
            setCurrentTNode(tNode, false);
        }
        function textInterpolate(v0) {
            textInterpolate1("", v0, "");
            return textInterpolate;
        }
        function textInterpolate1(prefix, v0, suffix) {
            const lView = getLView();
            const interpolated = interpolation1(lView, prefix, v0, suffix);
            if (interpolated !== NO_CHANGE) {
                textBindingInternal(lView, getSelectedIndex(), interpolated);
            }
            return textInterpolate1;
        }
        function textInterpolate2(prefix, v0, i02, v1, suffix) {
            const lView = getLView();
            const interpolated = interpolation2(lView, prefix, v0, i02, v1, suffix);
            if (interpolated !== NO_CHANGE) {
                textBindingInternal(lView, getSelectedIndex(), interpolated);
            }
            return textInterpolate2;
        }
        function textInterpolate3(prefix, v0, i02, v1, i1, v2, suffix) {
            const lView = getLView();
            const interpolated = interpolation3(lView, prefix, v0, i02, v1, i1, v2, suffix);
            if (interpolated !== NO_CHANGE) {
                textBindingInternal(lView, getSelectedIndex(), interpolated);
            }
            return textInterpolate3;
        }
        function textInterpolate4(prefix, v0, i02, v1, i1, v2, i2, v3, suffix) {
            const lView = getLView();
            const interpolated = interpolation4(lView, prefix, v0, i02, v1, i1, v2, i2, v3, suffix);
            if (interpolated !== NO_CHANGE) {
                textBindingInternal(lView, getSelectedIndex(), interpolated);
            }
            return textInterpolate4;
        }
        function textInterpolate5(prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, suffix) {
            const lView = getLView();
            const interpolated = interpolation5(lView, prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, suffix);
            if (interpolated !== NO_CHANGE) {
                textBindingInternal(lView, getSelectedIndex(), interpolated);
            }
            return textInterpolate5;
        }
        function textInterpolate6(prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {
            const lView = getLView();
            const interpolated = interpolation6(lView, prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
            if (interpolated !== NO_CHANGE) {
                textBindingInternal(lView, getSelectedIndex(), interpolated);
            }
            return textInterpolate6;
        }
        function textInterpolate7(prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {
            const lView = getLView();
            const interpolated = interpolation7(lView, prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
            if (interpolated !== NO_CHANGE) {
                textBindingInternal(lView, getSelectedIndex(), interpolated);
            }
            return textInterpolate7;
        }
        function textInterpolate8(prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {
            const lView = getLView();
            const interpolated = interpolation8(lView, prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
            if (interpolated !== NO_CHANGE) {
                textBindingInternal(lView, getSelectedIndex(), interpolated);
            }
            return textInterpolate8;
        }
        function textInterpolateV(values) {
            const lView = getLView();
            const interpolated = interpolationV(lView, values);
            if (interpolated !== NO_CHANGE) {
                textBindingInternal(lView, getSelectedIndex(), interpolated);
            }
            return textInterpolateV;
        }
        function classMapInterpolate1(prefix, v0, suffix) {
            const lView = getLView();
            const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
            checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
        }
        function classMapInterpolate2(prefix, v0, i02, v1, suffix) {
            const lView = getLView();
            const interpolatedValue = interpolation2(lView, prefix, v0, i02, v1, suffix);
            checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
        }
        function classMapInterpolate3(prefix, v0, i02, v1, i1, v2, suffix) {
            const lView = getLView();
            const interpolatedValue = interpolation3(lView, prefix, v0, i02, v1, i1, v2, suffix);
            checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
        }
        function classMapInterpolate4(prefix, v0, i02, v1, i1, v2, i2, v3, suffix) {
            const lView = getLView();
            const interpolatedValue = interpolation4(lView, prefix, v0, i02, v1, i1, v2, i2, v3, suffix);
            checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
        }
        function classMapInterpolate5(prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, suffix) {
            const lView = getLView();
            const interpolatedValue = interpolation5(lView, prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, suffix);
            checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
        }
        function classMapInterpolate6(prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {
            const lView = getLView();
            const interpolatedValue = interpolation6(lView, prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
            checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
        }
        function classMapInterpolate7(prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {
            const lView = getLView();
            const interpolatedValue = interpolation7(lView, prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
            checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
        }
        function classMapInterpolate8(prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {
            const lView = getLView();
            const interpolatedValue = interpolation8(lView, prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
            checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
        }
        function classMapInterpolateV(values) {
            const lView = getLView();
            const interpolatedValue = interpolationV(lView, values);
            checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
        }
        function styleMapInterpolate1(prefix, v0, suffix) {
            const lView = getLView();
            const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
            styleMap(interpolatedValue);
        }
        function styleMapInterpolate2(prefix, v0, i02, v1, suffix) {
            const lView = getLView();
            const interpolatedValue = interpolation2(lView, prefix, v0, i02, v1, suffix);
            styleMap(interpolatedValue);
        }
        function styleMapInterpolate3(prefix, v0, i02, v1, i1, v2, suffix) {
            const lView = getLView();
            const interpolatedValue = interpolation3(lView, prefix, v0, i02, v1, i1, v2, suffix);
            styleMap(interpolatedValue);
        }
        function styleMapInterpolate4(prefix, v0, i02, v1, i1, v2, i2, v3, suffix) {
            const lView = getLView();
            const interpolatedValue = interpolation4(lView, prefix, v0, i02, v1, i1, v2, i2, v3, suffix);
            styleMap(interpolatedValue);
        }
        function styleMapInterpolate5(prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, suffix) {
            const lView = getLView();
            const interpolatedValue = interpolation5(lView, prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, suffix);
            styleMap(interpolatedValue);
        }
        function styleMapInterpolate6(prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {
            const lView = getLView();
            const interpolatedValue = interpolation6(lView, prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
            styleMap(interpolatedValue);
        }
        function styleMapInterpolate7(prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {
            const lView = getLView();
            const interpolatedValue = interpolation7(lView, prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
            styleMap(interpolatedValue);
        }
        function styleMapInterpolate8(prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {
            const lView = getLView();
            const interpolatedValue = interpolation8(lView, prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
            styleMap(interpolatedValue);
        }
        function styleMapInterpolateV(values) {
            const lView = getLView();
            const interpolatedValue = interpolationV(lView, values);
            styleMap(interpolatedValue);
        }
        function stylePropInterpolate1(prop, prefix, v0, suffix, valueSuffix) {
            const lView = getLView();
            const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
            checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
            return stylePropInterpolate1;
        }
        function stylePropInterpolate2(prop, prefix, v0, i02, v1, suffix, valueSuffix) {
            const lView = getLView();
            const interpolatedValue = interpolation2(lView, prefix, v0, i02, v1, suffix);
            checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
            return stylePropInterpolate2;
        }
        function stylePropInterpolate3(prop, prefix, v0, i02, v1, i1, v2, suffix, valueSuffix) {
            const lView = getLView();
            const interpolatedValue = interpolation3(lView, prefix, v0, i02, v1, i1, v2, suffix);
            checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
            return stylePropInterpolate3;
        }
        function stylePropInterpolate4(prop, prefix, v0, i02, v1, i1, v2, i2, v3, suffix, valueSuffix) {
            const lView = getLView();
            const interpolatedValue = interpolation4(lView, prefix, v0, i02, v1, i1, v2, i2, v3, suffix);
            checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
            return stylePropInterpolate4;
        }
        function stylePropInterpolate5(prop, prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, suffix, valueSuffix) {
            const lView = getLView();
            const interpolatedValue = interpolation5(lView, prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, suffix);
            checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
            return stylePropInterpolate5;
        }
        function stylePropInterpolate6(prop, prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, valueSuffix) {
            const lView = getLView();
            const interpolatedValue = interpolation6(lView, prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
            checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
            return stylePropInterpolate6;
        }
        function stylePropInterpolate7(prop, prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, valueSuffix) {
            const lView = getLView();
            const interpolatedValue = interpolation7(lView, prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
            checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
            return stylePropInterpolate7;
        }
        function stylePropInterpolate8(prop, prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, valueSuffix) {
            const lView = getLView();
            const interpolatedValue = interpolation8(lView, prefix, v0, i02, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
            checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
            return stylePropInterpolate8;
        }
        function stylePropInterpolateV(prop, values, valueSuffix) {
            const lView = getLView();
            const interpolatedValue = interpolationV(lView, values);
            checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
            return stylePropInterpolateV;
        }
        function hostProperty(propName, value, sanitizer) {
            const lView = getLView();
            const bindingIndex = nextBindingIndex();
            if (bindingUpdated(lView, bindingIndex, value)) {
                const tView = getTView();
                const tNode = getSelectedTNode();
                elementPropertyInternal(tView, tNode, lView, propName, value, lView[RENDERER], sanitizer, true);
            }
            return hostProperty;
        }
        function syntheticHostProperty(propName, value, sanitizer) {
            const lView = getLView();
            const bindingIndex = nextBindingIndex();
            if (bindingUpdated(lView, bindingIndex, value)) {
                const tView = getTView();
                const tNode = getSelectedTNode();
                const currentDef = getCurrentDirectiveDef(tView.data);
                const renderer = loadComponentRenderer(currentDef, tNode, lView);
                elementPropertyInternal(tView, tNode, lView, propName, value, renderer, sanitizer, true);
            }
            return syntheticHostProperty;
        }
        if (false) {
            (function() {
                _global["ngI18nClosureMode"] = typeof goog !== "undefined" && typeof goog.getMsg === "function";
            })();
        }
        const u = void 0;
        function plural(val) {
            const n = val, i = Math.floor(Math.abs(val)), v = val.toString().replace(/^[^.]*\.?/, "").length;
            if (i === 1 && v === 0) {
                return 1;
            }
            return 5;
        }
        var localeEn = [ "en", [ [ "a", "p" ], [ "AM", "PM" ], u ], [ [ "AM", "PM" ], u, u ], [ [ "S", "M", "T", "W", "T", "F", "S" ], [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ], [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ], [ "Su", "Mo", "Tu", "We", "Th", "Fr", "Sa" ] ], u, [ [ "J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D" ], [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ], [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ] ], u, [ [ "B", "A" ], [ "BC", "AD" ], [ "Before Christ", "Anno Domini" ] ], 0, [ 6, 0 ], [ "M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y" ], [ "h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz" ], [ "{1}, {0}", u, "{1} 'at' {0}", u ], [ ".", ",", ";", "%", "+", "-", "E", "", "", "", "NaN", ":" ], [ "#,##0.###", "#,##0%", "#,##0.00", "#E0" ], "USD", "$", "US Dollar", {}, "ltr", plural ];
        let LOCALE_DATA = {};
        function registerLocaleData(data, localeId, extraData) {
            if (typeof localeId !== "string") {
                extraData = localeId;
                localeId = data[LocaleDataIndex.LocaleId];
            }
            localeId = localeId.toLowerCase().replace(/_/g, "-");
            LOCALE_DATA[localeId] = data;
            if (extraData) {
                LOCALE_DATA[localeId][LocaleDataIndex.ExtraData] = extraData;
            }
        }
        function findLocaleData(locale) {
            const normalizedLocale = normalizeLocale(locale);
            let match2 = getLocaleData(normalizedLocale);
            if (match2) {
                return match2;
            }
            const parentLocale = normalizedLocale.split("-")[0];
            match2 = getLocaleData(parentLocale);
            if (match2) {
                return match2;
            }
            if (parentLocale === "en") {
                return localeEn;
            }
            throw new RuntimeError(701, false);
        }
        function getLocaleCurrencyCode(locale) {
            const data = findLocaleData(locale);
            return data[LocaleDataIndex.CurrencyCode] || null;
        }
        function getLocalePluralCase(locale) {
            const data = findLocaleData(locale);
            return data[LocaleDataIndex.PluralCase];
        }
        function getLocaleData(normalizedLocale) {
            if (!(normalizedLocale in LOCALE_DATA)) {
                LOCALE_DATA[normalizedLocale] = _global.ng && _global.ng.common && _global.ng.common.locales && _global.ng.common.locales[normalizedLocale];
            }
            return LOCALE_DATA[normalizedLocale];
        }
        function unregisterAllLocaleData() {
            LOCALE_DATA = {};
        }
        var LocaleDataIndex = (() => {
            LocaleDataIndex = LocaleDataIndex || {};
            LocaleDataIndex[LocaleDataIndex["LocaleId"] = 0] = "LocaleId";
            LocaleDataIndex[LocaleDataIndex["DayPeriodsFormat"] = 1] = "DayPeriodsFormat";
            LocaleDataIndex[LocaleDataIndex["DayPeriodsStandalone"] = 2] = "DayPeriodsStandalone";
            LocaleDataIndex[LocaleDataIndex["DaysFormat"] = 3] = "DaysFormat";
            LocaleDataIndex[LocaleDataIndex["DaysStandalone"] = 4] = "DaysStandalone";
            LocaleDataIndex[LocaleDataIndex["MonthsFormat"] = 5] = "MonthsFormat";
            LocaleDataIndex[LocaleDataIndex["MonthsStandalone"] = 6] = "MonthsStandalone";
            LocaleDataIndex[LocaleDataIndex["Eras"] = 7] = "Eras";
            LocaleDataIndex[LocaleDataIndex["FirstDayOfWeek"] = 8] = "FirstDayOfWeek";
            LocaleDataIndex[LocaleDataIndex["WeekendRange"] = 9] = "WeekendRange";
            LocaleDataIndex[LocaleDataIndex["DateFormat"] = 10] = "DateFormat";
            LocaleDataIndex[LocaleDataIndex["TimeFormat"] = 11] = "TimeFormat";
            LocaleDataIndex[LocaleDataIndex["DateTimeFormat"] = 12] = "DateTimeFormat";
            LocaleDataIndex[LocaleDataIndex["NumberSymbols"] = 13] = "NumberSymbols";
            LocaleDataIndex[LocaleDataIndex["NumberFormats"] = 14] = "NumberFormats";
            LocaleDataIndex[LocaleDataIndex["CurrencyCode"] = 15] = "CurrencyCode";
            LocaleDataIndex[LocaleDataIndex["CurrencySymbol"] = 16] = "CurrencySymbol";
            LocaleDataIndex[LocaleDataIndex["CurrencyName"] = 17] = "CurrencyName";
            LocaleDataIndex[LocaleDataIndex["Currencies"] = 18] = "Currencies";
            LocaleDataIndex[LocaleDataIndex["Directionality"] = 19] = "Directionality";
            LocaleDataIndex[LocaleDataIndex["PluralCase"] = 20] = "PluralCase";
            LocaleDataIndex[LocaleDataIndex["ExtraData"] = 21] = "ExtraData";
            return LocaleDataIndex;
        })();
        function normalizeLocale(locale) {
            return locale.toLowerCase().replace(/_/g, "-");
        }
        const pluralMapping = [ "zero", "one", "two", "few", "many" ];
        function getPluralCase(value, locale) {
            const plural2 = getLocalePluralCase(locale)(parseInt(value, 10));
            const result = pluralMapping[plural2];
            return result !== void 0 ? result : "other";
        }
        const DEFAULT_LOCALE_ID = "en-US";
        const USD_CURRENCY_CODE = "USD";
        const ELEMENT_MARKER = {
            marker: "element"
        };
        const ICU_MARKER = {
            marker: "ICU"
        };
        var I18nCreateOpCode = (() => {
            I18nCreateOpCode = I18nCreateOpCode || {};
            I18nCreateOpCode[I18nCreateOpCode["SHIFT"] = 2] = "SHIFT";
            I18nCreateOpCode[I18nCreateOpCode["APPEND_EAGERLY"] = 1] = "APPEND_EAGERLY";
            I18nCreateOpCode[I18nCreateOpCode["COMMENT"] = 2] = "COMMENT";
            return I18nCreateOpCode;
        })();
        const unusedValueExportToPlacateAjd$2 = 1;
        let LOCALE_ID$1 = DEFAULT_LOCALE_ID;
        function setLocaleId(localeId) {
            assertDefined(localeId, `Expected localeId to be defined`);
            if (typeof localeId === "string") {
                LOCALE_ID$1 = localeId.toLowerCase().replace(/_/g, "-");
            }
        }
        function getLocaleId() {
            return LOCALE_ID$1;
        }
        function getInsertInFrontOfRNodeWithI18n(parentTNode, currentTNode, lView) {
            const tNodeInsertBeforeIndex = currentTNode.insertBeforeIndex;
            const insertBeforeIndex = Array.isArray(tNodeInsertBeforeIndex) ? tNodeInsertBeforeIndex[0] : tNodeInsertBeforeIndex;
            if (insertBeforeIndex === null) {
                return getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView);
            } else {
                return unwrapRNode(lView[insertBeforeIndex]);
            }
        }
        function processI18nInsertBefore(renderer, childTNode, lView, childRNode, parentRElement) {
            const tNodeInsertBeforeIndex = childTNode.insertBeforeIndex;
            if (Array.isArray(tNodeInsertBeforeIndex)) {
                let i18nParent = childRNode;
                let anchorRNode = null;
                if (!(childTNode.type & 3)) {
                    anchorRNode = i18nParent;
                    i18nParent = parentRElement;
                }
                if (i18nParent !== null && (childTNode.flags & 2) === 0) {
                    for (let i = 1; i < tNodeInsertBeforeIndex.length; i++) {
                        const i18nChild = lView[tNodeInsertBeforeIndex[i]];
                        nativeInsertBefore(renderer, i18nParent, i18nChild, anchorRNode, false);
                    }
                }
            }
        }
        function addTNodeAndUpdateInsertBeforeIndex(previousTNodes, newTNode) {
            previousTNodes.push(newTNode);
            if (previousTNodes.length > 1) {
                for (let i = previousTNodes.length - 2; i >= 0; i--) {
                    const existingTNode = previousTNodes[i];
                    if (!isI18nText(existingTNode)) {
                        if (isNewTNodeCreatedBefore(existingTNode, newTNode) && getInsertBeforeIndex(existingTNode) === null) {
                            setInsertBeforeIndex(existingTNode, newTNode.index);
                        }
                    }
                }
            }
        }
        function isI18nText(tNode) {
            return !(tNode.type & 64);
        }
        function isNewTNodeCreatedBefore(existingTNode, newTNode) {
            return isI18nText(newTNode) || existingTNode.index > newTNode.index;
        }
        function getInsertBeforeIndex(tNode) {
            const index = tNode.insertBeforeIndex;
            return Array.isArray(index) ? index[0] : index;
        }
        function setInsertBeforeIndex(tNode, value) {
            const index = tNode.insertBeforeIndex;
            if (Array.isArray(index)) {
                index[0] = value;
            } else {
                setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);
                tNode.insertBeforeIndex = value;
            }
        }
        function getTIcu(tView, index) {
            const value = tView.data[index];
            if (value === null || typeof value === "string") {
                return null;
            }
            if (false) {
                throwError("We expect to get 'null'|'TIcu'|'TIcuContainer', but got: " + value);
            }
            const tIcu = value.hasOwnProperty("currentCaseLViewIndex") ? value : value.value;
            return tIcu;
        }
        function setTIcu(tView, index, tIcu) {
            const tNode = tView.data[index];
            if (tNode === null) {
                tView.data[index] = tIcu;
            } else {
                tNode.value = tIcu;
            }
        }
        function setTNodeInsertBeforeIndex(tNode, index) {
            let insertBeforeIndex = tNode.insertBeforeIndex;
            if (insertBeforeIndex === null) {
                setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);
                insertBeforeIndex = tNode.insertBeforeIndex = [ null, index ];
            } else {
                assertEqual(Array.isArray(insertBeforeIndex), true, "Expecting array here");
                insertBeforeIndex.push(index);
            }
        }
        function createTNodePlaceholder(tView, previousTNodes, index) {
            const tNode = createTNodeAtIndex(tView, index, 64, null, null);
            addTNodeAndUpdateInsertBeforeIndex(previousTNodes, tNode);
            return tNode;
        }
        function getCurrentICUCaseIndex(tIcu, lView) {
            const currentCase = lView[tIcu.currentCaseLViewIndex];
            return currentCase === null ? currentCase : currentCase < 0 ? ~currentCase : currentCase;
        }
        function getParentFromIcuCreateOpCode(mergedCode) {
            return mergedCode >>> 17;
        }
        function getRefFromIcuCreateOpCode(mergedCode) {
            return (mergedCode & 131070) >>> 1;
        }
        function getInstructionFromIcuCreateOpCode(mergedCode) {
            return mergedCode & 1;
        }
        function icuCreateOpCode(opCode, parentIdx, refIdx) {
            return opCode | parentIdx << 17 | refIdx << 1;
        }
        let changeMask = 0;
        let changeMaskCounter = 0;
        function setMaskBit(hasChange) {
            if (hasChange) {
                changeMask = changeMask | 1 << Math.min(changeMaskCounter, 31);
            }
            changeMaskCounter++;
        }
        function applyI18n(tView, lView, index) {
            if (changeMaskCounter > 0) {
                const tI18n = tView.data[index];
                const updateOpCodes = Array.isArray(tI18n) ? tI18n : tI18n.update;
                const bindingsStartIndex = getBindingIndex() - changeMaskCounter - 1;
                applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask);
            }
            changeMask = 0;
            changeMaskCounter = 0;
        }
        function applyCreateOpCodes(lView, createOpCodes, parentRNode, insertInFrontOf) {
            const renderer = lView[RENDERER];
            for (let i = 0; i < createOpCodes.length; i++) {
                const opCode = createOpCodes[i++];
                const text = createOpCodes[i];
                const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;
                const appendNow = (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;
                const index = opCode >>> I18nCreateOpCode.SHIFT;
                let rNode = lView[index];
                if (rNode === null) {
                    rNode = lView[index] = isComment ? renderer.createComment(text) : createTextNode(renderer, text);
                }
                if (appendNow && parentRNode !== null) {
                    nativeInsertBefore(renderer, parentRNode, rNode, insertInFrontOf, false);
                }
            }
        }
        function applyMutableOpCodes(tView, mutableOpCodes, lView, anchorRNode) {
            const renderer = lView[RENDERER];
            let rootIdx = null;
            let rootRNode;
            for (let i = 0; i < mutableOpCodes.length; i++) {
                const opCode = mutableOpCodes[i];
                if (typeof opCode == "string") {
                    const textNodeIndex = mutableOpCodes[++i];
                    if (lView[textNodeIndex] === null) {
                        lView[textNodeIndex] = createTextNode(renderer, opCode);
                    }
                } else if (typeof opCode == "number") {
                    switch (opCode & 1) {
                      case 0:
                        const parentIdx = getParentFromIcuCreateOpCode(opCode);
                        if (rootIdx === null) {
                            rootIdx = parentIdx;
                            rootRNode = nativeParentNode(renderer, anchorRNode);
                        }
                        let insertInFrontOf;
                        let parentRNode;
                        if (parentIdx === rootIdx) {
                            insertInFrontOf = anchorRNode;
                            parentRNode = rootRNode;
                        } else {
                            insertInFrontOf = null;
                            parentRNode = unwrapRNode(lView[parentIdx]);
                        }
                        if (parentRNode !== null) {
                            const refIdx = getRefFromIcuCreateOpCode(opCode);
                            const child = lView[refIdx];
                            nativeInsertBefore(renderer, parentRNode, child, insertInFrontOf, false);
                            const tIcu = getTIcu(tView, refIdx);
                            if (tIcu !== null && typeof tIcu === "object") {
                                const caseIndex = getCurrentICUCaseIndex(tIcu, lView);
                                if (caseIndex !== null) {
                                    applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, lView[tIcu.anchorIdx]);
                                }
                            }
                        }
                        break;

                      case 1:
                        const elementNodeIndex = opCode >>> 1;
                        const attrName = mutableOpCodes[++i];
                        const attrValue = mutableOpCodes[++i];
                        setElementAttribute(renderer, getNativeByIndex(elementNodeIndex, lView), null, null, attrName, attrValue, null);
                        break;

                      default:
                        if (false) {
                            throw new RuntimeError(700, `Unable to determine the type of mutate operation for "${opCode}"`);
                        }
                    }
                } else {
                    switch (opCode) {
                      case ICU_MARKER:
                        const commentValue = mutableOpCodes[++i];
                        const commentNodeIndex = mutableOpCodes[++i];
                        if (lView[commentNodeIndex] === null) {
                            const commentRNode = lView[commentNodeIndex] = createCommentNode(renderer, commentValue);
                            attachPatchData(commentRNode, lView);
                        }
                        break;

                      case ELEMENT_MARKER:
                        const tagName = mutableOpCodes[++i];
                        const elementNodeIndex = mutableOpCodes[++i];
                        if (lView[elementNodeIndex] === null) {
                            const elementRNode = lView[elementNodeIndex] = createElementNode(renderer, tagName, null);
                            attachPatchData(elementRNode, lView);
                        }
                        break;

                      default:
                    }
                }
            }
        }
        function applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask2) {
            for (let i = 0; i < updateOpCodes.length; i++) {
                const checkBit = updateOpCodes[i];
                const skipCodes = updateOpCodes[++i];
                if (checkBit & changeMask2) {
                    let value = "";
                    for (let j = i + 1; j <= i + skipCodes; j++) {
                        const opCode = updateOpCodes[j];
                        if (typeof opCode == "string") {
                            value += opCode;
                        } else if (typeof opCode == "number") {
                            if (opCode < 0) {
                                value += renderStringify(lView[bindingsStartIndex - opCode]);
                            } else {
                                const nodeIndex = opCode >>> 2;
                                switch (opCode & 3) {
                                  case 1:
                                    const propName = updateOpCodes[++j];
                                    const sanitizeFn = updateOpCodes[++j];
                                    const tNodeOrTagName = tView.data[nodeIndex];
                                    if (typeof tNodeOrTagName === "string") {
                                        setElementAttribute(lView[RENDERER], lView[nodeIndex], null, tNodeOrTagName, propName, value, sanitizeFn);
                                    } else {
                                        elementPropertyInternal(tView, tNodeOrTagName, lView, propName, value, lView[RENDERER], sanitizeFn, false);
                                    }
                                    break;

                                  case 0:
                                    const rText = lView[nodeIndex];
                                    rText !== null && updateTextNode(lView[RENDERER], rText, value);
                                    break;

                                  case 2:
                                    applyIcuSwitchCase(tView, getTIcu(tView, nodeIndex), lView, value);
                                    break;

                                  case 3:
                                    applyIcuUpdateCase(tView, getTIcu(tView, nodeIndex), bindingsStartIndex, lView);
                                    break;
                                }
                            }
                        }
                    }
                } else {
                    const opCode = updateOpCodes[i + 1];
                    if (opCode > 0 && (opCode & 3) === 3) {
                        const nodeIndex = opCode >>> 2;
                        const tIcu = getTIcu(tView, nodeIndex);
                        const currentIndex = lView[tIcu.currentCaseLViewIndex];
                        if (currentIndex < 0) {
                            applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView);
                        }
                    }
                }
                i += skipCodes;
            }
        }
        function applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView) {
            let activeCaseIndex = lView[tIcu.currentCaseLViewIndex];
            if (activeCaseIndex !== null) {
                let mask = changeMask;
                if (activeCaseIndex < 0) {
                    activeCaseIndex = lView[tIcu.currentCaseLViewIndex] = ~activeCaseIndex;
                    mask = -1;
                }
                applyUpdateOpCodes(tView, lView, tIcu.update[activeCaseIndex], bindingsStartIndex, mask);
            }
        }
        function applyIcuSwitchCase(tView, tIcu, lView, value) {
            const caseIndex = getCaseIndex(tIcu, value);
            let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);
            if (activeCaseIndex !== caseIndex) {
                applyIcuSwitchCaseRemove(tView, tIcu, lView);
                lView[tIcu.currentCaseLViewIndex] = caseIndex === null ? null : ~caseIndex;
                if (caseIndex !== null) {
                    const anchorRNode = lView[tIcu.anchorIdx];
                    if (anchorRNode) {
                        applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, anchorRNode);
                    }
                }
            }
        }
        function applyIcuSwitchCaseRemove(tView, tIcu, lView) {
            let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);
            if (activeCaseIndex !== null) {
                const removeCodes = tIcu.remove[activeCaseIndex];
                for (let i = 0; i < removeCodes.length; i++) {
                    const nodeOrIcuIndex = removeCodes[i];
                    if (nodeOrIcuIndex > 0) {
                        const rNode = getNativeByIndex(nodeOrIcuIndex, lView);
                        rNode !== null && nativeRemoveNode(lView[RENDERER], rNode);
                    } else {
                        applyIcuSwitchCaseRemove(tView, getTIcu(tView, ~nodeOrIcuIndex), lView);
                    }
                }
            }
        }
        function getCaseIndex(icuExpression, bindingValue) {
            let index = icuExpression.cases.indexOf(bindingValue);
            if (index === -1) {
                switch (icuExpression.type) {
                  case 1:
                    {
                        const resolvedCase = getPluralCase(bindingValue, getLocaleId());
                        index = icuExpression.cases.indexOf(resolvedCase);
                        if (index === -1 && resolvedCase !== "other") {
                            index = icuExpression.cases.indexOf("other");
                        }
                        break;
                    }

                  case 0:
                    {
                        index = icuExpression.cases.indexOf("other");
                        break;
                    }
                }
            }
            return index === -1 ? null : index;
        }
        function loadIcuContainerVisitor() {
            const _stack = [];
            let _index = -1;
            let _lView;
            let _removes;
            function icuContainerIteratorStart(tIcuContainerNode, lView) {
                _lView = lView;
                while (_stack.length) {
                    _stack.pop();
                }
                enterIcu(tIcuContainerNode.value, lView);
                return icuContainerIteratorNext;
            }
            function enterIcu(tIcu, lView) {
                _index = 0;
                const currentCase = getCurrentICUCaseIndex(tIcu, lView);
                if (currentCase !== null) {
                    _removes = tIcu.remove[currentCase];
                } else {
                    _removes = EMPTY_ARRAY;
                }
            }
            function icuContainerIteratorNext() {
                if (_index < _removes.length) {
                    const removeOpCode = _removes[_index++];
                    if (removeOpCode > 0) {
                        const rNode = _lView[removeOpCode];
                        return rNode;
                    } else {
                        _stack.push(_index, _removes);
                        const tIcuIndex = ~removeOpCode;
                        const tIcu = _lView[TVIEW].data[tIcuIndex];
                        enterIcu(tIcu, _lView);
                        return icuContainerIteratorNext();
                    }
                } else {
                    if (_stack.length === 0) {
                        return null;
                    } else {
                        _removes = _stack.pop();
                        _index = _stack.pop();
                        return icuContainerIteratorNext();
                    }
                }
            }
            return icuContainerIteratorStart;
        }
        function i18nCreateOpCodesToString(opcodes) {
            const createOpCodes = opcodes || (Array.isArray(this) ? this : []);
            let lines = [];
            for (let i = 0; i < createOpCodes.length; i++) {
                const opCode = createOpCodes[i++];
                const text = createOpCodes[i];
                const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;
                const appendNow = (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;
                const index = opCode >>> I18nCreateOpCode.SHIFT;
                lines.push(`lView[${index}] = document.${isComment ? "createComment" : "createText"}(${JSON.stringify(text)});`);
                if (appendNow) {
                    lines.push(`parent.appendChild(lView[${index}]);`);
                }
            }
            return lines;
        }
        function i18nUpdateOpCodesToString(opcodes) {
            const parser = new OpCodeParser(opcodes || (Array.isArray(this) ? this : []));
            let lines = [];
            function consumeOpCode(value) {
                const ref = value >>> 2;
                const opCode = value & 3;
                switch (opCode) {
                  case 0:
                    return `(lView[${ref}] as Text).textContent = $$$`;

                  case 1:
                    const attrName = parser.consumeString();
                    const sanitizationFn = parser.consumeFunction();
                    const value2 = sanitizationFn ? `(${sanitizationFn})($$$)` : "$$$";
                    return `(lView[${ref}] as Element).setAttribute('${attrName}', ${value2})`;

                  case 2:
                    return `icuSwitchCase(${ref}, $$$)`;

                  case 3:
                    return `icuUpdateCase(${ref})`;
                }
                throw new Error("unexpected OpCode");
            }
            while (parser.hasMore()) {
                let mask = parser.consumeNumber();
                let size = parser.consumeNumber();
                const end = parser.i + size;
                const statements = [];
                let statement = "";
                while (parser.i < end) {
                    let value = parser.consumeNumberOrString();
                    if (typeof value === "string") {
                        statement += value;
                    } else if (value < 0) {
                        statement += "${lView[i" + value + "]}";
                    } else {
                        const opCodeText = consumeOpCode(value);
                        statements.push(opCodeText.replace("$$$", "`" + statement + "`") + ";");
                        statement = "";
                    }
                }
                lines.push(`if (mask & 0b${mask.toString(2)}) { ${statements.join(" ")} }`);
            }
            return lines;
        }
        function icuCreateOpCodesToString(opcodes) {
            const parser = new OpCodeParser(opcodes || (Array.isArray(this) ? this : []));
            let lines = [];
            function consumeOpCode(opCode) {
                const parent = getParentFromIcuCreateOpCode(opCode);
                const ref = getRefFromIcuCreateOpCode(opCode);
                switch (getInstructionFromIcuCreateOpCode(opCode)) {
                  case 0:
                    return `(lView[${parent}] as Element).appendChild(lView[${lastRef}])`;

                  case 1:
                    return `(lView[${ref}] as Element).setAttribute("${parser.consumeString()}", "${parser.consumeString()}")`;
                }
                throw new Error("Unexpected OpCode: " + getInstructionFromIcuCreateOpCode(opCode));
            }
            let lastRef = -1;
            while (parser.hasMore()) {
                let value = parser.consumeNumberStringOrMarker();
                if (value === ICU_MARKER) {
                    const text = parser.consumeString();
                    lastRef = parser.consumeNumber();
                    lines.push(`lView[${lastRef}] = document.createComment("${text}")`);
                } else if (value === ELEMENT_MARKER) {
                    const text = parser.consumeString();
                    lastRef = parser.consumeNumber();
                    lines.push(`lView[${lastRef}] = document.createElement("${text}")`);
                } else if (typeof value === "string") {
                    lastRef = parser.consumeNumber();
                    lines.push(`lView[${lastRef}] = document.createTextNode("${value}")`);
                } else if (typeof value === "number") {
                    const line = consumeOpCode(value);
                    line && lines.push(line);
                } else {
                    throw new Error("Unexpected value");
                }
            }
            return lines;
        }
        function i18nRemoveOpCodesToString(opcodes) {
            const removeCodes = opcodes || (Array.isArray(this) ? this : []);
            let lines = [];
            for (let i = 0; i < removeCodes.length; i++) {
                const nodeOrIcuIndex = removeCodes[i];
                if (nodeOrIcuIndex > 0) {
                    lines.push(`remove(lView[${nodeOrIcuIndex}])`);
                } else {
                    lines.push(`removeNestedICU(${~nodeOrIcuIndex})`);
                }
            }
            return lines;
        }
        class OpCodeParser {
            constructor(codes) {
                this.i = 0;
                this.codes = codes;
            }
            hasMore() {
                return this.i < this.codes.length;
            }
            consumeNumber() {
                let value = this.codes[this.i++];
                assertNumber(value, "expecting number in OpCode");
                return value;
            }
            consumeString() {
                let value = this.codes[this.i++];
                assertString(value, "expecting string in OpCode");
                return value;
            }
            consumeFunction() {
                let value = this.codes[this.i++];
                if (value === null || typeof value === "function") {
                    return value;
                }
                throw new Error("expecting function in OpCode");
            }
            consumeNumberOrString() {
                let value = this.codes[this.i++];
                if (typeof value === "string") {
                    return value;
                }
                assertNumber(value, "expecting number or string in OpCode");
                return value;
            }
            consumeNumberStringOrMarker() {
                let value = this.codes[this.i++];
                if (typeof value === "string" || typeof value === "number" || value == ICU_MARKER || value == ELEMENT_MARKER) {
                    return value;
                }
                assertNumber(value, "expecting number, string, ICU_MARKER or ELEMENT_MARKER in OpCode");
                return value;
            }
        }
        const BINDING_REGEXP = /(\d+):?\d*/gi;
        const ICU_REGEXP = /({\s*\d+:?\d*\s*,\s*\S{6}\s*,[\s\S]*})/gi;
        const NESTED_ICU = /(\d+)/;
        const ICU_BLOCK_REGEXP = /^\s*(\d+:?\d*)\s*,\s*(select|plural)\s*,/;
        const MARKER = ``;
        const SUBTEMPLATE_REGEXP = /\/?\*(\d+:\d+)/gi;
        const PH_REGEXP = /(\/?[#*]\d+):?\d*/gi;
        const NGSP_UNICODE_REGEXP = /\uE500/g;
        function replaceNgsp(value) {
            return value.replace(NGSP_UNICODE_REGEXP, " ");
        }
        function i18nStartFirstCreatePass(tView, parentTNodeIndex, lView, index, message, subTemplateIndex) {
            const rootTNode = getCurrentParentTNode();
            const createOpCodes = [];
            const updateOpCodes = [];
            const existingTNodeStack = [ [] ];
            if (false) {
                attachDebugGetter(createOpCodes, i18nCreateOpCodesToString);
                attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);
            }
            message = getTranslationForTemplate(message, subTemplateIndex);
            const msgParts = replaceNgsp(message).split(PH_REGEXP);
            for (let i = 0; i < msgParts.length; i++) {
                let value = msgParts[i];
                if ((i & 1) === 0) {
                    const parts = i18nParseTextIntoPartsAndICU(value);
                    for (let j = 0; j < parts.length; j++) {
                        let part = parts[j];
                        if ((j & 1) === 0) {
                            const text = part;
                            if (text !== "") {
                                i18nStartFirstCreatePassProcessTextNode(tView, rootTNode, existingTNodeStack[0], createOpCodes, updateOpCodes, lView, text);
                            }
                        } else {
                            const icuExpression = part;
                            if (typeof icuExpression !== "object") {
                                throw new Error(`Unable to parse ICU expression in "${message}" message.`);
                            }
                            const icuContainerTNode = createTNodeAndAddOpCode(tView, rootTNode, existingTNodeStack[0], lView, createOpCodes, false ? `ICU ${index}:${icuExpression.mainBinding}` : "", true);
                            const icuNodeIndex = icuContainerTNode.index;
                            icuStart(tView, lView, updateOpCodes, parentTNodeIndex, icuExpression, icuNodeIndex);
                        }
                    }
                } else {
                    const isClosing = value.charCodeAt(0) === 47;
                    const type = value.charCodeAt(isClosing ? 1 : 0);
                    const index2 = HEADER_OFFSET + Number.parseInt(value.substring(isClosing ? 2 : 1));
                    if (isClosing) {
                        existingTNodeStack.shift();
                        setCurrentTNode(getCurrentParentTNode(), false);
                    } else {
                        const tNode = createTNodePlaceholder(tView, existingTNodeStack[0], index2);
                        existingTNodeStack.unshift([]);
                        setCurrentTNode(tNode, true);
                    }
                }
            }
            tView.data[index] = {
                create: createOpCodes,
                update: updateOpCodes
            };
        }
        function createTNodeAndAddOpCode(tView, rootTNode, existingTNodes, lView, createOpCodes, text, isICU) {
            const i18nNodeIdx = allocExpando(tView, lView, 1, null);
            let opCode = i18nNodeIdx << I18nCreateOpCode.SHIFT;
            let parentTNode = getCurrentParentTNode();
            if (rootTNode === parentTNode) {
                parentTNode = null;
            }
            if (parentTNode === null) {
                opCode |= I18nCreateOpCode.APPEND_EAGERLY;
            }
            if (isICU) {
                opCode |= I18nCreateOpCode.COMMENT;
                ensureIcuContainerVisitorLoaded(loadIcuContainerVisitor);
            }
            createOpCodes.push(opCode, text === null ? "" : text);
            const tNode = createTNodeAtIndex(tView, i18nNodeIdx, isICU ? 32 : 1, text === null ? false ? "{{?}}" : "" : text, null);
            addTNodeAndUpdateInsertBeforeIndex(existingTNodes, tNode);
            const tNodeIdx = tNode.index;
            setCurrentTNode(tNode, false);
            if (parentTNode !== null && rootTNode !== parentTNode) {
                setTNodeInsertBeforeIndex(parentTNode, tNodeIdx);
            }
            return tNode;
        }
        function i18nStartFirstCreatePassProcessTextNode(tView, rootTNode, existingTNodes, createOpCodes, updateOpCodes, lView, text) {
            const hasBinding = text.match(BINDING_REGEXP);
            const tNode = createTNodeAndAddOpCode(tView, rootTNode, existingTNodes, lView, createOpCodes, hasBinding ? null : text, false);
            if (hasBinding) {
                generateBindingUpdateOpCodes(updateOpCodes, text, tNode.index, null, 0, null);
            }
        }
        function i18nAttributesFirstPass(tView, index, values) {
            const previousElement = getCurrentTNode();
            const previousElementIndex = previousElement.index;
            const updateOpCodes = [];
            if (false) {
                attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);
            }
            if (tView.firstCreatePass && tView.data[index] === null) {
                for (let i = 0; i < values.length; i += 2) {
                    const attrName = values[i];
                    const message = values[i + 1];
                    if (message !== "") {
                        if (ICU_REGEXP.test(message)) {
                            throw new Error(`ICU expressions are not supported in attributes. Message: "${message}".`);
                        }
                        generateBindingUpdateOpCodes(updateOpCodes, message, previousElementIndex, attrName, countBindings(updateOpCodes), null);
                    }
                }
                tView.data[index] = updateOpCodes;
            }
        }
        function generateBindingUpdateOpCodes(updateOpCodes, str, destinationNode, attrName, bindingStart, sanitizeFn) {
            const maskIndex = updateOpCodes.length;
            const sizeIndex = maskIndex + 1;
            updateOpCodes.push(null, null);
            const startIndex = maskIndex + 2;
            if (false) {
                attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);
            }
            const textParts = str.split(BINDING_REGEXP);
            let mask = 0;
            for (let j = 0; j < textParts.length; j++) {
                const textValue = textParts[j];
                if (j & 1) {
                    const bindingIndex = bindingStart + parseInt(textValue, 10);
                    updateOpCodes.push(-1 - bindingIndex);
                    mask = mask | toMaskBit(bindingIndex);
                } else if (textValue !== "") {
                    updateOpCodes.push(textValue);
                }
            }
            updateOpCodes.push(destinationNode << 2 | (attrName ? 1 : 0));
            if (attrName) {
                updateOpCodes.push(attrName, sanitizeFn);
            }
            updateOpCodes[maskIndex] = mask;
            updateOpCodes[sizeIndex] = updateOpCodes.length - startIndex;
            return mask;
        }
        function countBindings(opCodes) {
            let count = 0;
            for (let i = 0; i < opCodes.length; i++) {
                const opCode = opCodes[i];
                if (typeof opCode === "number" && opCode < 0) {
                    count++;
                }
            }
            return count;
        }
        function toMaskBit(bindingIndex) {
            return 1 << Math.min(bindingIndex, 31);
        }
        function isRootTemplateMessage(subTemplateIndex) {
            return subTemplateIndex === -1;
        }
        function removeInnerTemplateTranslation(message) {
            let match2;
            let res = "";
            let index = 0;
            let inTemplate = false;
            let tagMatched;
            while ((match2 = SUBTEMPLATE_REGEXP.exec(message)) !== null) {
                if (!inTemplate) {
                    res += message.substring(index, match2.index + match2[0].length);
                    tagMatched = match2[1];
                    inTemplate = true;
                } else {
                    if (match2[0] === `${MARKER}/*${tagMatched}${MARKER}`) {
                        index = match2.index;
                        inTemplate = false;
                    }
                }
            }
            res += message.slice(index);
            return res;
        }
        function getTranslationForTemplate(message, subTemplateIndex) {
            if (isRootTemplateMessage(subTemplateIndex)) {
                return removeInnerTemplateTranslation(message);
            } else {
                const start = message.indexOf(`:${subTemplateIndex}${MARKER}`) + 2 + subTemplateIndex.toString().length;
                const end = message.search(new RegExp(`${MARKER}\\/\\*\\d+:${subTemplateIndex}${MARKER}`));
                return removeInnerTemplateTranslation(message.substring(start, end));
            }
        }
        function icuStart(tView, lView, updateOpCodes, parentIdx, icuExpression, anchorIdx) {
            let bindingMask = 0;
            const tIcu = {
                type: icuExpression.type,
                currentCaseLViewIndex: allocExpando(tView, lView, 1, null),
                anchorIdx,
                cases: [],
                create: [],
                remove: [],
                update: []
            };
            addUpdateIcuSwitch(updateOpCodes, icuExpression, anchorIdx);
            setTIcu(tView, anchorIdx, tIcu);
            const values = icuExpression.values;
            for (let i = 0; i < values.length; i++) {
                const valueArr = values[i];
                const nestedIcus = [];
                for (let j = 0; j < valueArr.length; j++) {
                    const value = valueArr[j];
                    if (typeof value !== "string") {
                        const icuIndex = nestedIcus.push(value) - 1;
                        valueArr[j] = `\x3c!--${icuIndex}--\x3e`;
                    }
                }
                bindingMask = parseIcuCase(tView, tIcu, lView, updateOpCodes, parentIdx, icuExpression.cases[i], valueArr.join(""), nestedIcus) | bindingMask;
            }
            if (bindingMask) {
                addUpdateIcuUpdate(updateOpCodes, bindingMask, anchorIdx);
            }
        }
        function parseICUBlock(pattern) {
            const cases = [];
            const values = [];
            let icuType = 1;
            let mainBinding = 0;
            pattern = pattern.replace(ICU_BLOCK_REGEXP, function(str, binding, type) {
                if (type === "select") {
                    icuType = 0;
                } else {
                    icuType = 1;
                }
                mainBinding = parseInt(binding.slice(1), 10);
                return "";
            });
            const parts = i18nParseTextIntoPartsAndICU(pattern);
            for (let pos = 0; pos < parts.length; ) {
                let key = parts[pos++].trim();
                if (icuType === 1) {
                    key = key.replace(/\s*(?:=)?(\w+)\s*/, "$1");
                }
                if (key.length) {
                    cases.push(key);
                }
                const blocks = i18nParseTextIntoPartsAndICU(parts[pos++]);
                if (cases.length > values.length) {
                    values.push(blocks);
                }
            }
            return {
                type: icuType,
                mainBinding,
                cases,
                values
            };
        }
        function i18nParseTextIntoPartsAndICU(pattern) {
            if (!pattern) {
                return [];
            }
            let prevPos = 0;
            const braceStack = [];
            const results = [];
            const braces = /[{}]/g;
            braces.lastIndex = 0;
            let match2;
            while (match2 = braces.exec(pattern)) {
                const pos = match2.index;
                if (match2[0] == "}") {
                    braceStack.pop();
                    if (braceStack.length == 0) {
                        const block = pattern.substring(prevPos, pos);
                        if (ICU_BLOCK_REGEXP.test(block)) {
                            results.push(parseICUBlock(block));
                        } else {
                            results.push(block);
                        }
                        prevPos = pos + 1;
                    }
                } else {
                    if (braceStack.length == 0) {
                        const substring2 = pattern.substring(prevPos, pos);
                        results.push(substring2);
                        prevPos = pos + 1;
                    }
                    braceStack.push("{");
                }
            }
            const substring = pattern.substring(prevPos);
            results.push(substring);
            return results;
        }
        function parseIcuCase(tView, tIcu, lView, updateOpCodes, parentIdx, caseName, unsafeCaseHtml, nestedIcus) {
            const create = [];
            const remove2 = [];
            const update = [];
            if (false) {
                attachDebugGetter(create, icuCreateOpCodesToString);
                attachDebugGetter(remove2, i18nRemoveOpCodesToString);
                attachDebugGetter(update, i18nUpdateOpCodesToString);
            }
            tIcu.cases.push(caseName);
            tIcu.create.push(create);
            tIcu.remove.push(remove2);
            tIcu.update.push(update);
            const inertBodyHelper2 = getInertBodyHelper(getDocument());
            const inertBodyElement = inertBodyHelper2.getInertBodyElement(unsafeCaseHtml);
            const inertRootNode = getTemplateContent(inertBodyElement) || inertBodyElement;
            if (inertRootNode) {
                return walkIcuTree(tView, tIcu, lView, updateOpCodes, create, remove2, update, inertRootNode, parentIdx, nestedIcus, 0);
            } else {
                return 0;
            }
        }
        function walkIcuTree(tView, tIcu, lView, sharedUpdateOpCodes, create, remove2, update, parentNode, parentIdx, nestedIcus, depth) {
            let bindingMask = 0;
            let currentNode = parentNode.firstChild;
            while (currentNode) {
                const newIndex = allocExpando(tView, lView, 1, null);
                switch (currentNode.nodeType) {
                  case Node.ELEMENT_NODE:
                    const element = currentNode;
                    const tagName = element.tagName.toLowerCase();
                    if (VALID_ELEMENTS.hasOwnProperty(tagName)) {
                        addCreateNodeAndAppend(create, ELEMENT_MARKER, tagName, parentIdx, newIndex);
                        tView.data[newIndex] = tagName;
                        const elAttrs = element.attributes;
                        for (let i = 0; i < elAttrs.length; i++) {
                            const attr = elAttrs.item(i);
                            const lowerAttrName = attr.name.toLowerCase();
                            const hasBinding2 = !!attr.value.match(BINDING_REGEXP);
                            if (hasBinding2) {
                                if (VALID_ATTRS.hasOwnProperty(lowerAttrName)) {
                                    if (URI_ATTRS[lowerAttrName]) {
                                        generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, _sanitizeUrl);
                                    } else {
                                        generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, null);
                                    }
                                } else {}
                            } else {
                                addCreateAttribute(create, newIndex, attr);
                            }
                        }
                        bindingMask = walkIcuTree(tView, tIcu, lView, sharedUpdateOpCodes, create, remove2, update, currentNode, newIndex, nestedIcus, depth + 1) | bindingMask;
                        addRemoveNode(remove2, newIndex, depth);
                    }
                    break;

                  case Node.TEXT_NODE:
                    const value = currentNode.textContent || "";
                    const hasBinding = value.match(BINDING_REGEXP);
                    addCreateNodeAndAppend(create, null, hasBinding ? "" : value, parentIdx, newIndex);
                    addRemoveNode(remove2, newIndex, depth);
                    if (hasBinding) {
                        bindingMask = generateBindingUpdateOpCodes(update, value, newIndex, null, 0, null) | bindingMask;
                    }
                    break;

                  case Node.COMMENT_NODE:
                    const isNestedIcu = NESTED_ICU.exec(currentNode.textContent || "");
                    if (isNestedIcu) {
                        const nestedIcuIndex = parseInt(isNestedIcu[1], 10);
                        const icuExpression = nestedIcus[nestedIcuIndex];
                        addCreateNodeAndAppend(create, ICU_MARKER, false ? `nested ICU ${nestedIcuIndex}` : "", parentIdx, newIndex);
                        icuStart(tView, lView, sharedUpdateOpCodes, parentIdx, icuExpression, newIndex);
                        addRemoveNestedIcu(remove2, newIndex, depth);
                    }
                    break;
                }
                currentNode = currentNode.nextSibling;
            }
            return bindingMask;
        }
        function addRemoveNode(remove2, index, depth) {
            if (depth === 0) {
                remove2.push(index);
            }
        }
        function addRemoveNestedIcu(remove2, index, depth) {
            if (depth === 0) {
                remove2.push(~index);
                remove2.push(index);
            }
        }
        function addUpdateIcuSwitch(update, icuExpression, index) {
            update.push(toMaskBit(icuExpression.mainBinding), 2, -1 - icuExpression.mainBinding, index << 2 | 2);
        }
        function addUpdateIcuUpdate(update, bindingMask, index) {
            update.push(bindingMask, 1, index << 2 | 3);
        }
        function addCreateNodeAndAppend(create, marker, text, appendToParentIdx, createAtIdx) {
            if (marker !== null) {
                create.push(marker);
            }
            create.push(text, createAtIdx, icuCreateOpCode(0, appendToParentIdx, createAtIdx));
        }
        function addCreateAttribute(create, newIndex, attr) {
            create.push(newIndex << 1 | 1, attr.name, attr.value);
        }
        const ROOT_TEMPLATE_ID = 0;
        const PP_MULTI_VALUE_PLACEHOLDERS_REGEXP = /\[(.+??)\]/;
        const PP_PLACEHOLDERS_REGEXP = /\[(.+??)\]|(\/?\*\d+:\d+)/g;
        const PP_ICU_VARS_REGEXP = /({\s*)(VAR_(PLURAL|SELECT)(_\d+)?)(\s*,)/g;
        const PP_ICU_PLACEHOLDERS_REGEXP = /{([A-Z0-9_]+)}/g;
        const PP_ICUS_REGEXP = /I18N_EXP_(ICU(_\d+)?)/g;
        const PP_CLOSE_TEMPLATE_REGEXP = /\/\*/;
        const PP_TEMPLATE_ID_REGEXP = /\d+\:(\d+)/;
        function i18nPostprocess(message, replacements = {}) {
            let result = message;
            if (PP_MULTI_VALUE_PLACEHOLDERS_REGEXP.test(message)) {
                const matches = {};
                const templateIdsStack = [ ROOT_TEMPLATE_ID ];
                result = result.replace(PP_PLACEHOLDERS_REGEXP, (m, phs, tmpl) => {
                    const content = phs || tmpl;
                    const placeholders = matches[content] || [];
                    if (!placeholders.length) {
                        content.split("|").forEach(placeholder2 => {
                            const match2 = placeholder2.match(PP_TEMPLATE_ID_REGEXP);
                            const templateId2 = match2 ? parseInt(match2[1], 10) : ROOT_TEMPLATE_ID;
                            const isCloseTemplateTag2 = PP_CLOSE_TEMPLATE_REGEXP.test(placeholder2);
                            placeholders.push([ templateId2, isCloseTemplateTag2, placeholder2 ]);
                        });
                        matches[content] = placeholders;
                    }
                    if (!placeholders.length) {
                        throw new Error(`i18n postprocess: unmatched placeholder - ${content}`);
                    }
                    const currentTemplateId = templateIdsStack[templateIdsStack.length - 1];
                    let idx = 0;
                    for (let i = 0; i < placeholders.length; i++) {
                        if (placeholders[i][0] === currentTemplateId) {
                            idx = i;
                            break;
                        }
                    }
                    const [templateId, isCloseTemplateTag, placeholder] = placeholders[idx];
                    if (isCloseTemplateTag) {
                        templateIdsStack.pop();
                    } else if (currentTemplateId !== templateId) {
                        templateIdsStack.push(templateId);
                    }
                    placeholders.splice(idx, 1);
                    return placeholder;
                });
            }
            if (!Object.keys(replacements).length) {
                return result;
            }
            result = result.replace(PP_ICU_VARS_REGEXP, (match2, start, key, _type, _idx, end) => replacements.hasOwnProperty(key) ? `${start}${replacements[key]}${end}` : match2);
            result = result.replace(PP_ICU_PLACEHOLDERS_REGEXP, (match2, key) => replacements.hasOwnProperty(key) ? replacements[key] : match2);
            result = result.replace(PP_ICUS_REGEXP, (match2, key) => {
                if (replacements.hasOwnProperty(key)) {
                    const list = replacements[key];
                    if (!list.length) {
                        throw new Error(`i18n postprocess: unmatched ICU - ${match2} with key: ${key}`);
                    }
                    return list.shift();
                }
                return match2;
            });
            return result;
        }
        function i18nStart(index, messageIndex, subTemplateIndex = -1) {
            const tView = getTView();
            const lView = getLView();
            const adjustedIndex = HEADER_OFFSET + index;
            const message = getConstant(tView.consts, messageIndex);
            const parentTNode = getCurrentParentTNode();
            if (tView.firstCreatePass) {
                i18nStartFirstCreatePass(tView, parentTNode === null ? 0 : parentTNode.index, lView, adjustedIndex, message, subTemplateIndex);
            }
            const tI18n = tView.data[adjustedIndex];
            const sameViewParentTNode = parentTNode === lView[T_HOST] ? null : parentTNode;
            const parentRNode = getClosestRElement(tView, sameViewParentTNode, lView);
            const insertInFrontOf = parentTNode && parentTNode.type & 8 ? lView[parentTNode.index] : null;
            applyCreateOpCodes(lView, tI18n.create, parentRNode, insertInFrontOf);
            setInI18nBlock(true);
        }
        function i18nEnd() {
            setInI18nBlock(false);
        }
        function i18n(index, messageIndex, subTemplateIndex) {
            i18nStart(index, messageIndex, subTemplateIndex);
            i18nEnd();
        }
        function i18nAttributes(index, attrsIndex) {
            const tView = getTView();
            const attrs = getConstant(tView.consts, attrsIndex);
            i18nAttributesFirstPass(tView, index + HEADER_OFFSET, attrs);
        }
        function i18nExp(value) {
            const lView = getLView();
            setMaskBit(bindingUpdated(lView, nextBindingIndex(), value));
            return i18nExp;
        }
        function i18nApply(index) {
            applyI18n(getTView(), getLView(), index + HEADER_OFFSET);
        }
        function i18nPostprocess(message, replacements = {}) {
            return i18nPostprocess(message, replacements);
        }
        function providersResolver(def, providers, viewProviders) {
            const tView = getTView();
            if (tView.firstCreatePass) {
                const isComponent = isComponentDef(def);
                resolveProvider(viewProviders, tView.data, tView.blueprint, isComponent, true);
                resolveProvider(providers, tView.data, tView.blueprint, isComponent, false);
            }
        }
        function resolveProvider(provider, tInjectables, lInjectablesBlueprint, isComponent, isViewProvider) {
            provider = resolveForwardRef(provider);
            if (Array.isArray(provider)) {
                for (let i = 0; i < provider.length; i++) {
                    resolveProvider(provider[i], tInjectables, lInjectablesBlueprint, isComponent, isViewProvider);
                }
            } else {
                const tView = getTView();
                const lView = getLView();
                let token = isTypeProvider(provider) ? provider : resolveForwardRef(provider.provide);
                let providerFactory = providerToFactory(provider);
                const tNode = getCurrentTNode();
                const beginIndex = tNode.providerIndexes & 1048575;
                const endIndex = tNode.directiveStart;
                const cptViewProvidersCount = tNode.providerIndexes >> 20;
                if (isTypeProvider(provider) || !provider.multi) {
                    const factory = new NodeInjectorFactory(providerFactory, isViewProvider, directiveInject);
                    const existingFactoryIndex = indexOf(token, tInjectables, isViewProvider ? beginIndex : beginIndex + cptViewProvidersCount, endIndex);
                    if (existingFactoryIndex === -1) {
                        diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token);
                        registerDestroyHooksIfSupported(tView, provider, tInjectables.length);
                        tInjectables.push(token);
                        tNode.directiveStart++;
                        tNode.directiveEnd++;
                        if (isViewProvider) {
                            tNode.providerIndexes += 1048576;
                        }
                        lInjectablesBlueprint.push(factory);
                        lView.push(factory);
                    } else {
                        lInjectablesBlueprint[existingFactoryIndex] = factory;
                        lView[existingFactoryIndex] = factory;
                    }
                } else {
                    const existingProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex + cptViewProvidersCount, endIndex);
                    const existingViewProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex, beginIndex + cptViewProvidersCount);
                    const doesProvidersFactoryExist = existingProvidersFactoryIndex >= 0 && lInjectablesBlueprint[existingProvidersFactoryIndex];
                    const doesViewProvidersFactoryExist = existingViewProvidersFactoryIndex >= 0 && lInjectablesBlueprint[existingViewProvidersFactoryIndex];
                    if (isViewProvider && !doesViewProvidersFactoryExist || !isViewProvider && !doesProvidersFactoryExist) {
                        diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token);
                        const factory = multiFactory(isViewProvider ? multiViewProvidersFactoryResolver : multiProvidersFactoryResolver, lInjectablesBlueprint.length, isViewProvider, isComponent, providerFactory);
                        if (!isViewProvider && doesViewProvidersFactoryExist) {
                            lInjectablesBlueprint[existingViewProvidersFactoryIndex].providerFactory = factory;
                        }
                        registerDestroyHooksIfSupported(tView, provider, tInjectables.length, 0);
                        tInjectables.push(token);
                        tNode.directiveStart++;
                        tNode.directiveEnd++;
                        if (isViewProvider) {
                            tNode.providerIndexes += 1048576;
                        }
                        lInjectablesBlueprint.push(factory);
                        lView.push(factory);
                    } else {
                        const indexInFactory = multiFactoryAdd(lInjectablesBlueprint[isViewProvider ? existingViewProvidersFactoryIndex : existingProvidersFactoryIndex], providerFactory, !isViewProvider && isComponent);
                        registerDestroyHooksIfSupported(tView, provider, existingProvidersFactoryIndex > -1 ? existingProvidersFactoryIndex : existingViewProvidersFactoryIndex, indexInFactory);
                    }
                    if (!isViewProvider && isComponent && doesViewProvidersFactoryExist) {
                        lInjectablesBlueprint[existingViewProvidersFactoryIndex].componentProviders++;
                    }
                }
            }
        }
        function registerDestroyHooksIfSupported(tView, provider, contextIndex, indexInFactory) {
            const providerIsTypeProvider = isTypeProvider(provider);
            const providerIsClassProvider = isClassProvider(provider);
            if (providerIsTypeProvider || providerIsClassProvider) {
                const classToken = providerIsClassProvider ? resolveForwardRef(provider.useClass) : provider;
                const prototype = classToken.prototype;
                const ngOnDestroy = prototype.ngOnDestroy;
                if (ngOnDestroy) {
                    const hooks = tView.destroyHooks || (tView.destroyHooks = []);
                    if (!providerIsTypeProvider && provider.multi) {
                        const existingCallbacksIndex = hooks.indexOf(contextIndex);
                        if (existingCallbacksIndex === -1) {
                            hooks.push(contextIndex, [ indexInFactory, ngOnDestroy ]);
                        } else {
                            hooks[existingCallbacksIndex + 1].push(indexInFactory, ngOnDestroy);
                        }
                    } else {
                        hooks.push(contextIndex, ngOnDestroy);
                    }
                }
            }
        }
        function multiFactoryAdd(multiFactory2, factory, isComponentProvider) {
            if (isComponentProvider) {
                multiFactory2.componentProviders++;
            }
            return multiFactory2.multi.push(factory) - 1;
        }
        function indexOf(item, arr, begin, end) {
            for (let i = begin; i < end; i++) {
                if (arr[i] === item) {
                    return i;
                }
            }
            return -1;
        }
        function multiProvidersFactoryResolver(_, tData, lData, tNode) {
            return multiResolve(this.multi, []);
        }
        function multiViewProvidersFactoryResolver(_, tData, lView, tNode) {
            const factories = this.multi;
            let result;
            if (this.providerFactory) {
                const componentCount = this.providerFactory.componentProviders;
                const multiProviders = getNodeInjectable(lView, lView[TVIEW], this.providerFactory.index, tNode);
                result = multiProviders.slice(0, componentCount);
                multiResolve(factories, result);
                for (let i = componentCount; i < multiProviders.length; i++) {
                    result.push(multiProviders[i]);
                }
            } else {
                result = [];
                multiResolve(factories, result);
            }
            return result;
        }
        function multiResolve(factories, result) {
            for (let i = 0; i < factories.length; i++) {
                const factory = factories[i];
                result.push(factory());
            }
            return result;
        }
        function multiFactory(factoryFn, index, isViewProvider, isComponent, f) {
            const factory = new NodeInjectorFactory(factoryFn, isViewProvider, directiveInject);
            factory.multi = [];
            factory.index = index;
            factory.componentProviders = 0;
            multiFactoryAdd(factory, f, isComponent && !isViewProvider);
            return factory;
        }
        function ProvidersFeature(providers, viewProviders = []) {
            return definition => {
                definition.providersResolver = (def, processProvidersFn) => providersResolver(def, processProvidersFn ? processProvidersFn(providers) : providers, viewProviders);
            };
        }
        class NgModuleRef$1 {}
        class NgModuleFactory$1 {}
        function createNgModule(ngModule, parentInjector) {
            return new NgModuleRef(ngModule, parentInjector ?? null);
        }
        const createNgModuleRef = null;
        class NgModuleRef extends NgModuleRef$1 {
            constructor(ngModuleType, _parent) {
                super();
                this._parent = _parent;
                this._bootstrapComponents = [];
                this.destroyCbs = [];
                this.componentFactoryResolver = new ComponentFactoryResolver(this);
                const ngModuleDef = getNgModuleDef(ngModuleType);
                this._bootstrapComponents = maybeUnwrapFn(ngModuleDef.bootstrap);
                this._r3Injector = createInjectorWithoutInjectorInstances(ngModuleType, _parent, [ {
                    provide: NgModuleRef$1,
                    useValue: this
                }, {
                    provide: ComponentFactoryResolver$1,
                    useValue: this.componentFactoryResolver
                } ], stringify(ngModuleType), new Set([ "environment" ]));
                this._r3Injector.resolveInjectorInitializers();
                this.instance = this._r3Injector.get(ngModuleType);
            }
            get injector() {
                return this._r3Injector;
            }
            destroy() {
                const injector = this._r3Injector;
                !injector.destroyed && injector.destroy();
                this.destroyCbs.forEach(fn => fn());
                this.destroyCbs = null;
            }
            onDestroy(callback) {
                this.destroyCbs.push(callback);
            }
        }
        class NgModuleFactory extends NgModuleFactory$1 {
            constructor(moduleType) {
                super();
                this.moduleType = moduleType;
            }
            create(parentInjector) {
                return new NgModuleRef(this.moduleType, parentInjector);
            }
        }
        class EnvironmentNgModuleRefAdapter extends NgModuleRef$1 {
            constructor(providers, parent, source) {
                super();
                this.componentFactoryResolver = new ComponentFactoryResolver(this);
                this.instance = null;
                const injector = new R3Injector([ ...providers, {
                    provide: NgModuleRef$1,
                    useValue: this
                }, {
                    provide: ComponentFactoryResolver$1,
                    useValue: this.componentFactoryResolver
                } ], parent || getNullInjector(), source, new Set([ "environment" ]));
                this.injector = injector;
                injector.resolveInjectorInitializers();
            }
            destroy() {
                this.injector.destroy();
            }
            onDestroy(callback) {
                this.injector.onDestroy(callback);
            }
        }
        function createEnvironmentInjector(providers, parent, debugName = null) {
            const adapter = new EnvironmentNgModuleRefAdapter(providers, parent, debugName);
            return adapter.injector;
        }
        let StandaloneService = (() => {
            class StandaloneService2 {
                constructor(_injector) {
                    this._injector = _injector;
                    this.cachedInjectors = new Map;
                }
                getOrCreateStandaloneInjector(componentDef) {
                    if (!componentDef.standalone) {
                        return null;
                    }
                    if (!this.cachedInjectors.has(componentDef.id)) {
                        const providers = internalImportProvidersFrom(false, componentDef.type);
                        const standaloneInjector = providers.length > 0 ? createEnvironmentInjector([ providers ], this._injector, `Standalone[${componentDef.type.name}]`) : null;
                        this.cachedInjectors.set(componentDef.id, standaloneInjector);
                    }
                    return this.cachedInjectors.get(componentDef.id);
                }
                ngOnDestroy() {
                    try {
                        for (const injector of this.cachedInjectors.values()) {
                            if (injector !== null) {
                                injector.destroy();
                            }
                        }
                    } finally {
                        this.cachedInjectors.clear();
                    }
                }
            }
            StandaloneService2.prov = defineInjectable({
                token: StandaloneService2,
                providedIn: "environment",
                factory: () => new StandaloneService2(core_inject(EnvironmentInjector))
            });
            return StandaloneService2;
        })();
        function StandaloneFeature(definition) {
            definition.getStandaloneInjector = parentInjector => parentInjector.get(StandaloneService).getOrCreateStandaloneInjector(definition);
        }
        function getComponent(element) {
            const context2 = getLContext(element);
            if (context2 === null) {
                return null;
            }
            if (context2.component === void 0) {
                const lView = context2.lView;
                if (lView === null) {
                    return null;
                }
                context2.component = getComponentAtNodeIndex(context2.nodeIndex, lView);
            }
            return context2.component;
        }
        function getContext(element) {
            assertDomElement(element);
            const context2 = getLContext(element);
            const lView = context2 ? context2.lView : null;
            return lView === null ? null : lView[CONTEXT];
        }
        function getOwningComponent(elementOrDir) {
            const context2 = getLContext(elementOrDir);
            let lView = context2 ? context2.lView : null;
            if (lView === null) {
                return null;
            }
            let parent;
            while (lView[TVIEW].type === 2 && (parent = getLViewParent(lView))) {
                lView = parent;
            }
            return lView[FLAGS] & 256 ? null : lView[CONTEXT];
        }
        function getRootComponents(elementOrDir) {
            const lView = readPatchedLView(elementOrDir);
            return lView !== null ? [ getRootContext(lView) ] : [];
        }
        function getInjector(elementOrDir) {
            const context2 = getLContext(elementOrDir);
            const lView = context2 ? context2.lView : null;
            if (lView === null) {
                return core_Injector.NULL;
            }
            const tNode = lView[TVIEW].data[context2.nodeIndex];
            return new NodeInjector(tNode, lView);
        }
        function getInjectionTokens(element) {
            const context2 = getLContext(element);
            const lView = context2 ? context2.lView : null;
            if (lView === null) {
                return [];
            }
            const tView = lView[TVIEW];
            const tNode = tView.data[context2.nodeIndex];
            const providerTokens = [];
            const startIndex = tNode.providerIndexes & 1048575;
            const endIndex = tNode.directiveEnd;
            for (let i = startIndex; i < endIndex; i++) {
                let value = tView.data[i];
                if (isDirectiveDefHack(value)) {
                    value = value.type;
                }
                providerTokens.push(value);
            }
            return providerTokens;
        }
        function getDirectives(node) {
            if (node instanceof Text) {
                return [];
            }
            const context2 = getLContext(node);
            const lView = context2 ? context2.lView : null;
            if (lView === null) {
                return [];
            }
            const tView = lView[TVIEW];
            const nodeIndex = context2.nodeIndex;
            if (!tView?.data[nodeIndex]) {
                return [];
            }
            if (context2.directives === void 0) {
                context2.directives = getDirectivesAtNodeIndex(nodeIndex, lView, false);
            }
            return context2.directives === null ? [] : [ ...context2.directives ];
        }
        function getDirectiveMetadata$1(directiveOrComponentInstance) {
            const {constructor} = directiveOrComponentInstance;
            if (!constructor) {
                throw new Error("Unable to find the instance constructor");
            }
            const componentDef = getComponentDef(constructor);
            if (componentDef) {
                return {
                    inputs: componentDef.inputs,
                    outputs: componentDef.outputs,
                    encapsulation: componentDef.encapsulation,
                    changeDetection: componentDef.onPush ? ChangeDetectionStrategy.OnPush : ChangeDetectionStrategy.Default
                };
            }
            const directiveDef = getDirectiveDef(constructor);
            if (directiveDef) {
                return {
                    inputs: directiveDef.inputs,
                    outputs: directiveDef.outputs
                };
            }
            return null;
        }
        function getLocalRefs(target) {
            const context2 = getLContext(target);
            if (context2 === null) {
                return {};
            }
            if (context2.localRefs === void 0) {
                const lView = context2.lView;
                if (lView === null) {
                    return {};
                }
                context2.localRefs = discoverLocalRefs(lView, context2.nodeIndex);
            }
            return context2.localRefs || {};
        }
        function getHostElement(componentOrDirective) {
            return getLContext(componentOrDirective).native;
        }
        function getRenderedText(component) {
            const hostElement = getHostElement(component);
            return hostElement.textContent || "";
        }
        function getListeners(element) {
            const lContext = getLContext(element);
            const lView = lContext === null ? null : lContext.lView;
            if (lView === null) {
                return [];
            }
            const tView = lView[TVIEW];
            const lCleanup = lView[CLEANUP];
            const tCleanup = tView.cleanup;
            const listeners = [];
            if (tCleanup && lCleanup) {
                for (let i = 0; i < tCleanup.length; ) {
                    const firstParam = tCleanup[i++];
                    const secondParam = tCleanup[i++];
                    if (typeof firstParam === "string") {
                        const name = firstParam;
                        const listenerElement = unwrapRNode(lView[secondParam]);
                        const callback = lCleanup[tCleanup[i++]];
                        const useCaptureOrIndx = tCleanup[i++];
                        const type = typeof useCaptureOrIndx === "boolean" || useCaptureOrIndx >= 0 ? "dom" : "output";
                        const useCapture = typeof useCaptureOrIndx === "boolean" ? useCaptureOrIndx : false;
                        if (element == listenerElement) {
                            listeners.push({
                                element,
                                name,
                                callback,
                                useCapture,
                                type
                            });
                        }
                    }
                }
            }
            listeners.sort(sortListeners);
            return listeners;
        }
        function sortListeners(a, b) {
            if (a.name == b.name) {
                return 0;
            }
            return a.name < b.name ? -1 : 1;
        }
        function isDirectiveDefHack(obj) {
            return obj.type !== void 0 && obj.template !== void 0 && obj.declaredInputs !== void 0;
        }
        function getDebugNode$1(element) {
            if (false) {
                throw new Error("Expecting instance of DOM Element");
            }
            const lContext = getLContext(element);
            const lView = lContext ? lContext.lView : null;
            if (lView === null) {
                return null;
            }
            const nodeIndex = lContext.nodeIndex;
            if (nodeIndex !== -1) {
                const valueInLView = lView[nodeIndex];
                const tNode = isLView(valueInLView) ? valueInLView[T_HOST] : getTNode(lView[TVIEW], nodeIndex);
                return buildDebugNode(tNode, lView);
            }
            return null;
        }
        function getComponentLView(target) {
            const lContext = getLContext(target);
            const nodeIndx = lContext.nodeIndex;
            const lView = lContext.lView;
            const componentLView = lView[nodeIndx];
            return componentLView;
        }
        function assertDomElement(value) {
            if (typeof Element !== "undefined" && !(value instanceof Element)) {
                throw new Error("Expecting instance of DOM Element");
            }
        }
        function setClassMetadata(type, decorators, ctorParameters, propDecorators) {
            return noSideEffects(() => {
                const clazz = type;
                if (decorators !== null) {
                    if (clazz.hasOwnProperty("decorators") && clazz.decorators !== void 0) {
                        clazz.decorators.push(...decorators);
                    } else {
                        clazz.decorators = decorators;
                    }
                }
                if (ctorParameters !== null) {
                    clazz.ctorParameters = ctorParameters;
                }
                if (propDecorators !== null) {
                    if (clazz.hasOwnProperty("propDecorators") && clazz.propDecorators !== void 0) {
                        clazz.propDecorators = {
                            ...clazz.propDecorators,
                            ...propDecorators
                        };
                    } else {
                        clazz.propDecorators = propDecorators;
                    }
                }
            });
        }
        function pureFunction0(slotOffset, pureFn, thisArg) {
            const bindingIndex = getBindingRoot() + slotOffset;
            const lView = getLView();
            return lView[bindingIndex] === NO_CHANGE ? updateBinding(lView, bindingIndex, thisArg ? pureFn.call(thisArg) : pureFn()) : getBinding(lView, bindingIndex);
        }
        function pureFunction1(slotOffset, pureFn, exp, thisArg) {
            return pureFunction1Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp, thisArg);
        }
        function pureFunction2(slotOffset, pureFn, exp1, exp2, thisArg) {
            return pureFunction2Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, thisArg);
        }
        function pureFunction3(slotOffset, pureFn, exp1, exp2, exp3, thisArg) {
            return pureFunction3Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, exp3, thisArg);
        }
        function pureFunction4(slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg) {
            return pureFunction4Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg);
        }
        function pureFunction5(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, thisArg) {
            const bindingIndex = getBindingRoot() + slotOffset;
            const lView = getLView();
            const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
            return bindingUpdated(lView, bindingIndex + 4, exp5) || different ? updateBinding(lView, bindingIndex + 5, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5) : pureFn(exp1, exp2, exp3, exp4, exp5)) : getBinding(lView, bindingIndex + 5);
        }
        function pureFunction6(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, thisArg) {
            const bindingIndex = getBindingRoot() + slotOffset;
            const lView = getLView();
            const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
            return bindingUpdated2(lView, bindingIndex + 4, exp5, exp6) || different ? updateBinding(lView, bindingIndex + 6, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6)) : getBinding(lView, bindingIndex + 6);
        }
        function pureFunction7(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, thisArg) {
            const bindingIndex = getBindingRoot() + slotOffset;
            const lView = getLView();
            let different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
            return bindingUpdated3(lView, bindingIndex + 4, exp5, exp6, exp7) || different ? updateBinding(lView, bindingIndex + 7, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7)) : getBinding(lView, bindingIndex + 7);
        }
        function pureFunction8(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8, thisArg) {
            const bindingIndex = getBindingRoot() + slotOffset;
            const lView = getLView();
            const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
            return bindingUpdated4(lView, bindingIndex + 4, exp5, exp6, exp7, exp8) || different ? updateBinding(lView, bindingIndex + 8, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8)) : getBinding(lView, bindingIndex + 8);
        }
        function pureFunctionV(slotOffset, pureFn, exps, thisArg) {
            return pureFunctionVInternal(getLView(), getBindingRoot(), slotOffset, pureFn, exps, thisArg);
        }
        function getPureFunctionReturnValue(lView, returnValueIndex) {
            const lastReturnValue = lView[returnValueIndex];
            return lastReturnValue === NO_CHANGE ? void 0 : lastReturnValue;
        }
        function pureFunction1Internal(lView, bindingRoot, slotOffset, pureFn, exp, thisArg) {
            const bindingIndex = bindingRoot + slotOffset;
            return bindingUpdated(lView, bindingIndex, exp) ? updateBinding(lView, bindingIndex + 1, thisArg ? pureFn.call(thisArg, exp) : pureFn(exp)) : getPureFunctionReturnValue(lView, bindingIndex + 1);
        }
        function pureFunction2Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, thisArg) {
            const bindingIndex = bindingRoot + slotOffset;
            return bindingUpdated2(lView, bindingIndex, exp1, exp2) ? updateBinding(lView, bindingIndex + 2, thisArg ? pureFn.call(thisArg, exp1, exp2) : pureFn(exp1, exp2)) : getPureFunctionReturnValue(lView, bindingIndex + 2);
        }
        function pureFunction3Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, exp3, thisArg) {
            const bindingIndex = bindingRoot + slotOffset;
            return bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) ? updateBinding(lView, bindingIndex + 3, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3) : pureFn(exp1, exp2, exp3)) : getPureFunctionReturnValue(lView, bindingIndex + 3);
        }
        function pureFunction4Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg) {
            const bindingIndex = bindingRoot + slotOffset;
            return bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) ? updateBinding(lView, bindingIndex + 4, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4) : pureFn(exp1, exp2, exp3, exp4)) : getPureFunctionReturnValue(lView, bindingIndex + 4);
        }
        function pureFunctionVInternal(lView, bindingRoot, slotOffset, pureFn, exps, thisArg) {
            let bindingIndex = bindingRoot + slotOffset;
            let different = false;
            for (let i = 0; i < exps.length; i++) {
                bindingUpdated(lView, bindingIndex++, exps[i]) && (different = true);
            }
            return different ? updateBinding(lView, bindingIndex, pureFn.apply(thisArg, exps)) : getPureFunctionReturnValue(lView, bindingIndex);
        }
        function pipe(index, pipeName) {
            const tView = getTView();
            let pipeDef;
            const adjustedIndex = index + HEADER_OFFSET;
            if (tView.firstCreatePass) {
                pipeDef = getPipeDef(pipeName, tView.pipeRegistry);
                tView.data[adjustedIndex] = pipeDef;
                if (pipeDef.onDestroy) {
                    (tView.destroyHooks || (tView.destroyHooks = [])).push(adjustedIndex, pipeDef.onDestroy);
                }
            } else {
                pipeDef = tView.data[adjustedIndex];
            }
            const pipeFactory = pipeDef.factory || (pipeDef.factory = getFactoryDef(pipeDef.type, true));
            const previousInjectImplementation = setInjectImplementation(directiveInject);
            try {
                const previousIncludeViewProviders = setIncludeViewProviders(false);
                const pipeInstance = pipeFactory();
                setIncludeViewProviders(previousIncludeViewProviders);
                store(tView, getLView(), adjustedIndex, pipeInstance);
                return pipeInstance;
            } finally {
                setInjectImplementation(previousInjectImplementation);
            }
        }
        function getPipeDef(name, registry) {
            if (registry) {
                for (let i = registry.length - 1; i >= 0; i--) {
                    const pipeDef = registry[i];
                    if (name === pipeDef.name) {
                        return pipeDef;
                    }
                }
            }
            if (false) {
                throw new RuntimeError(-302, getPipeNotFoundErrorMessage(name));
            }
        }
        function getPipeNotFoundErrorMessage(name) {
            const lView = getLView();
            const declarationLView = lView[DECLARATION_COMPONENT_VIEW];
            const context2 = declarationLView[CONTEXT];
            const hostIsStandalone = isHostComponentStandalone(lView);
            const componentInfoMessage = context2 ? ` in the '${context2.constructor.name}' component` : "";
            const verifyMessage = `Verify that it is ${hostIsStandalone ? "included in the '@Component.imports' of this component" : "declared or imported in this module"}`;
            const errorMessage = `The pipe '${name}' could not be found${componentInfoMessage}. ${verifyMessage}`;
            return errorMessage;
        }
        function pipeBind1(index, slotOffset, v1) {
            const adjustedIndex = index + HEADER_OFFSET;
            const lView = getLView();
            const pipeInstance = load(lView, adjustedIndex);
            return isPure(lView, adjustedIndex) ? pureFunction1Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, pipeInstance) : pipeInstance.transform(v1);
        }
        function pipeBind2(index, slotOffset, v1, v2) {
            const adjustedIndex = index + HEADER_OFFSET;
            const lView = getLView();
            const pipeInstance = load(lView, adjustedIndex);
            return isPure(lView, adjustedIndex) ? pureFunction2Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, pipeInstance) : pipeInstance.transform(v1, v2);
        }
        function pipeBind3(index, slotOffset, v1, v2, v3) {
            const adjustedIndex = index + HEADER_OFFSET;
            const lView = getLView();
            const pipeInstance = load(lView, adjustedIndex);
            return isPure(lView, adjustedIndex) ? pureFunction3Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, v3, pipeInstance) : pipeInstance.transform(v1, v2, v3);
        }
        function pipeBind4(index, slotOffset, v1, v2, v3, v4) {
            const adjustedIndex = index + HEADER_OFFSET;
            const lView = getLView();
            const pipeInstance = load(lView, adjustedIndex);
            return isPure(lView, adjustedIndex) ? pureFunction4Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, v3, v4, pipeInstance) : pipeInstance.transform(v1, v2, v3, v4);
        }
        function pipeBindV(index, slotOffset, values) {
            const adjustedIndex = index + HEADER_OFFSET;
            const lView = getLView();
            const pipeInstance = load(lView, adjustedIndex);
            return isPure(lView, adjustedIndex) ? pureFunctionVInternal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, values, pipeInstance) : pipeInstance.transform.apply(pipeInstance, values);
        }
        function isPure(lView, index) {
            return lView[TVIEW].data[index].pure;
        }
        class EventEmitter_ extends Subject {
            constructor(isAsync = false) {
                super();
                this.__isAsync = isAsync;
            }
            emit(value) {
                super.next(value);
            }
            subscribe(observerOrNext, error, complete) {
                let nextFn = observerOrNext;
                let errorFn = error || (() => null);
                let completeFn = complete;
                if (observerOrNext && typeof observerOrNext === "object") {
                    const observer = observerOrNext;
                    nextFn = observer.next?.bind(observer);
                    errorFn = observer.error?.bind(observer);
                    completeFn = observer.complete?.bind(observer);
                }
                if (this.__isAsync) {
                    errorFn = _wrapInTimeout(errorFn);
                    if (nextFn) {
                        nextFn = _wrapInTimeout(nextFn);
                    }
                    if (completeFn) {
                        completeFn = _wrapInTimeout(completeFn);
                    }
                }
                const sink = super.subscribe({
                    next: nextFn,
                    error: errorFn,
                    complete: completeFn
                });
                if (observerOrNext instanceof Subscription) {
                    observerOrNext.add(sink);
                }
                return sink;
            }
        }
        function _wrapInTimeout(fn) {
            return value => {
                setTimeout(fn, void 0, value);
            };
        }
        const EventEmitter = EventEmitter_;
        function symbolIterator() {
            return this._results[core_getSymbolIterator()]();
        }
        class QueryList {
            constructor(_emitDistinctChangesOnly = false) {
                this._emitDistinctChangesOnly = _emitDistinctChangesOnly;
                this.dirty = true;
                this._results = [];
                this._changesDetected = false;
                this._changes = null;
                this.length = 0;
                this.first = void 0;
                this.last = void 0;
                const symbol = core_getSymbolIterator();
                const proto = QueryList.prototype;
                if (!proto[symbol]) {
                    proto[symbol] = symbolIterator;
                }
            }
            get changes() {
                return this._changes || (this._changes = new EventEmitter);
            }
            get(index) {
                return this._results[index];
            }
            map(fn) {
                return this._results.map(fn);
            }
            filter(fn) {
                return this._results.filter(fn);
            }
            find(fn) {
                return this._results.find(fn);
            }
            reduce(fn, init) {
                return this._results.reduce(fn, init);
            }
            forEach(fn) {
                this._results.forEach(fn);
            }
            some(fn) {
                return this._results.some(fn);
            }
            toArray() {
                return this._results.slice();
            }
            toString() {
                return this._results.toString();
            }
            reset(resultsTree, identityAccessor) {
                const self2 = this;
                self2.dirty = false;
                const newResultFlat = flatten(resultsTree);
                if (this._changesDetected = !arrayEquals(self2._results, newResultFlat, identityAccessor)) {
                    self2._results = newResultFlat;
                    self2.length = newResultFlat.length;
                    self2.last = newResultFlat[this.length - 1];
                    self2.first = newResultFlat[0];
                }
            }
            notifyOnChanges() {
                if (this._changes && (this._changesDetected || !this._emitDistinctChangesOnly)) {
                    this._changes.emit(this);
                }
            }
            setDirty() {
                this.dirty = true;
            }
            destroy() {
                this.changes.complete();
                this.changes.unsubscribe();
            }
        }
        Symbol.iterator;
        let TemplateRef = (() => {
            class TemplateRef2 {}
            TemplateRef2.__NG_ELEMENT_ID__ = injectTemplateRef;
            return TemplateRef2;
        })();
        const ViewEngineTemplateRef = TemplateRef;
        const R3TemplateRef = class TemplateRef extends ViewEngineTemplateRef {
            constructor(_declarationLView, _declarationTContainer, elementRef) {
                super();
                this._declarationLView = _declarationLView;
                this._declarationTContainer = _declarationTContainer;
                this.elementRef = elementRef;
            }
            createEmbeddedView(context2, injector) {
                const embeddedTView = this._declarationTContainer.tViews;
                const embeddedLView = createLView(this._declarationLView, embeddedTView, context2, 16, null, embeddedTView.declTNode, null, null, null, null, injector || null);
                const declarationLContainer = this._declarationLView[this._declarationTContainer.index];
                embeddedLView[DECLARATION_LCONTAINER] = declarationLContainer;
                const declarationViewLQueries = this._declarationLView[QUERIES];
                if (declarationViewLQueries !== null) {
                    embeddedLView[QUERIES] = declarationViewLQueries.createEmbeddedView(embeddedTView);
                }
                renderView(embeddedTView, embeddedLView, context2);
                return new ViewRef$1(embeddedLView);
            }
        };
        function injectTemplateRef() {
            return createTemplateRef(getCurrentTNode(), getLView());
        }
        function createTemplateRef(hostTNode, hostLView) {
            if (hostTNode.type & 4) {
                return new R3TemplateRef(hostLView, hostTNode, createElementRef(hostTNode, hostLView));
            }
            return null;
        }
        let ViewContainerRef = (() => {
            class ViewContainerRef2 {}
            ViewContainerRef2.__NG_ELEMENT_ID__ = injectViewContainerRef;
            return ViewContainerRef2;
        })();
        function injectViewContainerRef() {
            const previousTNode = getCurrentTNode();
            return createContainerRef(previousTNode, getLView());
        }
        const VE_ViewContainerRef = ViewContainerRef;
        const R3ViewContainerRef = class ViewContainerRef extends VE_ViewContainerRef {
            constructor(_lContainer, _hostTNode, _hostLView) {
                super();
                this._lContainer = _lContainer;
                this._hostTNode = _hostTNode;
                this._hostLView = _hostLView;
            }
            get element() {
                return createElementRef(this._hostTNode, this._hostLView);
            }
            get injector() {
                return new NodeInjector(this._hostTNode, this._hostLView);
            }
            get parentInjector() {
                const parentLocation = getParentInjectorLocation(this._hostTNode, this._hostLView);
                if (hasParentInjector(parentLocation)) {
                    const parentView = getParentInjectorView(parentLocation, this._hostLView);
                    const injectorIndex = getParentInjectorIndex(parentLocation);
                    const parentTNode = parentView[TVIEW].data[injectorIndex + 8];
                    return new NodeInjector(parentTNode, parentView);
                } else {
                    return new NodeInjector(null, this._hostLView);
                }
            }
            clear() {
                while (this.length > 0) {
                    this.remove(this.length - 1);
                }
            }
            get(index) {
                const viewRefs = getViewRefs(this._lContainer);
                return viewRefs !== null && viewRefs[index] || null;
            }
            get length() {
                return this._lContainer.length - CONTAINER_HEADER_OFFSET;
            }
            createEmbeddedView(templateRef, context2, indexOrOptions) {
                let index;
                let injector;
                if (typeof indexOrOptions === "number") {
                    index = indexOrOptions;
                } else if (indexOrOptions != null) {
                    index = indexOrOptions.index;
                    injector = indexOrOptions.injector;
                }
                const viewRef = templateRef.createEmbeddedView(context2 || {}, injector);
                this.insert(viewRef, index);
                return viewRef;
            }
            createComponent(componentFactoryOrType, indexOrOptions, injector, projectableNodes, environmentInjector) {
                const isComponentFactory = componentFactoryOrType && !isType(componentFactoryOrType);
                let index;
                if (isComponentFactory) {
                    if (false) {
                        assertEqual(typeof indexOrOptions !== "object", true, "It looks like Component factory was provided as the first argument and an options object as the second argument. This combination of arguments is incompatible. You can either change the first argument to provide Component type or change the second argument to be a number (representing an index at which to insert the new component's host view into this container)");
                    }
                    index = indexOrOptions;
                } else {
                    if (false) {
                        assertDefined(getComponentDef(componentFactoryOrType), `Provided Component class doesn't contain Component definition. Please check whether provided class has @Component decorator.`);
                        assertEqual(typeof indexOrOptions !== "number", true, "It looks like Component type was provided as the first argument and a number (representing an index at which to insert the new component's host view into this container as the second argument. This combination of arguments is incompatible. Please use an object as the second argument instead.");
                    }
                    const options = indexOrOptions || {};
                    if (false) {
                        throwError(`Cannot pass both environmentInjector and ngModuleRef options to createComponent().`);
                    }
                    index = options.index;
                    injector = options.injector;
                    projectableNodes = options.projectableNodes;
                    environmentInjector = options.environmentInjector || options.ngModuleRef;
                }
                const componentFactory = isComponentFactory ? componentFactoryOrType : new ComponentFactory(getComponentDef(componentFactoryOrType));
                const contextInjector = injector || this.parentInjector;
                if (!environmentInjector && componentFactory.ngModule == null) {
                    const _injector = isComponentFactory ? contextInjector : this.parentInjector;
                    const result = _injector.get(EnvironmentInjector, null);
                    if (result) {
                        environmentInjector = result;
                    }
                }
                const componentRef = componentFactory.create(contextInjector, projectableNodes, void 0, environmentInjector);
                this.insert(componentRef.hostView, index);
                return componentRef;
            }
            insert(viewRef, index) {
                const lView = viewRef._lView;
                const tView = lView[TVIEW];
                if (false) {
                    throw new Error("Cannot insert a destroyed View in a ViewContainer!");
                }
                if (viewAttachedToContainer(lView)) {
                    const prevIdx = this.indexOf(viewRef);
                    if (prevIdx !== -1) {
                        this.detach(prevIdx);
                    } else {
                        const prevLContainer = lView[PARENT];
                        const prevVCRef = new R3ViewContainerRef(prevLContainer, prevLContainer[T_HOST], prevLContainer[PARENT]);
                        prevVCRef.detach(prevVCRef.indexOf(viewRef));
                    }
                }
                const adjustedIdx = this._adjustIndex(index);
                const lContainer = this._lContainer;
                insertView(tView, lView, lContainer, adjustedIdx);
                const beforeNode = getBeforeNodeForView(adjustedIdx, lContainer);
                const renderer = lView[RENDERER];
                const parentRNode = nativeParentNode(renderer, lContainer[NATIVE]);
                if (parentRNode !== null) {
                    addViewToContainer(tView, lContainer[T_HOST], renderer, lView, parentRNode, beforeNode);
                }
                viewRef.attachToViewContainerRef();
                addToArray(getOrCreateViewRefs(lContainer), adjustedIdx, viewRef);
                return viewRef;
            }
            move(viewRef, newIndex) {
                if (false) {
                    throw new Error("Cannot move a destroyed View in a ViewContainer!");
                }
                return this.insert(viewRef, newIndex);
            }
            indexOf(viewRef) {
                const viewRefsArr = getViewRefs(this._lContainer);
                return viewRefsArr !== null ? viewRefsArr.indexOf(viewRef) : -1;
            }
            remove(index) {
                const adjustedIdx = this._adjustIndex(index, -1);
                const detachedView = detachView(this._lContainer, adjustedIdx);
                if (detachedView) {
                    removeFromArray(getOrCreateViewRefs(this._lContainer), adjustedIdx);
                    destroyLView(detachedView[TVIEW], detachedView);
                }
            }
            detach(index) {
                const adjustedIdx = this._adjustIndex(index, -1);
                const view = detachView(this._lContainer, adjustedIdx);
                const wasDetached = view && removeFromArray(getOrCreateViewRefs(this._lContainer), adjustedIdx) != null;
                return wasDetached ? new ViewRef$1(view) : null;
            }
            _adjustIndex(index, shift = 0) {
                if (index == null) {
                    return this.length + shift;
                }
                if (false) {
                    assertGreaterThan(index, -1, `ViewRef index must be positive, got ${index}`);
                    assertLessThan(index, this.length + 1 + shift, "index");
                }
                return index;
            }
        };
        function getViewRefs(lContainer) {
            return lContainer[VIEW_REFS];
        }
        function getOrCreateViewRefs(lContainer) {
            return lContainer[VIEW_REFS] || (lContainer[VIEW_REFS] = []);
        }
        function createContainerRef(hostTNode, hostLView) {
            let lContainer;
            const slotValue = hostLView[hostTNode.index];
            if (isLContainer(slotValue)) {
                lContainer = slotValue;
            } else {
                let commentNode;
                if (hostTNode.type & 8) {
                    commentNode = unwrapRNode(slotValue);
                } else {
                    const renderer = hostLView[RENDERER];
                    commentNode = renderer.createComment(false ? "container" : "");
                    const hostNative = getNativeByTNode(hostTNode, hostLView);
                    const parentOfHostNative = nativeParentNode(renderer, hostNative);
                    nativeInsertBefore(renderer, parentOfHostNative, commentNode, nativeNextSibling(renderer, hostNative), false);
                }
                hostLView[hostTNode.index] = lContainer = createLContainer(slotValue, hostLView, commentNode, hostTNode);
                addToViewTree(hostLView, lContainer);
            }
            return new R3ViewContainerRef(lContainer, hostTNode, hostLView);
        }
        const unusedValueExportToPlacateAjd$1 = 1;
        const unusedValueExportToPlacateAjd = 1;
        const unusedValueToPlacateAjd = unusedValueExportToPlacateAjd$1 + unusedValueExportToPlacateAjd$6 + unusedValueExportToPlacateAjd$5 + unusedValueExportToPlacateAjd;
        class LQuery_ {
            constructor(queryList) {
                this.queryList = queryList;
                this.matches = null;
            }
            clone() {
                return new LQuery_(this.queryList);
            }
            setDirty() {
                this.queryList.setDirty();
            }
        }
        class LQueries_ {
            constructor(queries = []) {
                this.queries = queries;
            }
            createEmbeddedView(tView) {
                const tQueries = tView.queries;
                if (tQueries !== null) {
                    const noOfInheritedQueries = tView.contentQueries !== null ? tView.contentQueries[0] : tQueries.length;
                    const viewLQueries = [];
                    for (let i = 0; i < noOfInheritedQueries; i++) {
                        const tQuery = tQueries.getByIndex(i);
                        const parentLQuery = this.queries[tQuery.indexInDeclarationView];
                        viewLQueries.push(parentLQuery.clone());
                    }
                    return new LQueries_(viewLQueries);
                }
                return null;
            }
            insertView(tView) {
                this.dirtyQueriesWithMatches(tView);
            }
            detachView(tView) {
                this.dirtyQueriesWithMatches(tView);
            }
            dirtyQueriesWithMatches(tView) {
                for (let i = 0; i < this.queries.length; i++) {
                    if (getTQuery(tView, i).matches !== null) {
                        this.queries[i].setDirty();
                    }
                }
            }
        }
        class TQueryMetadata_ {
            constructor(predicate, flags, read = null) {
                this.predicate = predicate;
                this.flags = flags;
                this.read = read;
            }
        }
        class TQueries_ {
            constructor(queries = []) {
                this.queries = queries;
            }
            elementStart(tView, tNode) {
                for (let i = 0; i < this.queries.length; i++) {
                    this.queries[i].elementStart(tView, tNode);
                }
            }
            elementEnd(tNode) {
                for (let i = 0; i < this.queries.length; i++) {
                    this.queries[i].elementEnd(tNode);
                }
            }
            embeddedTView(tNode) {
                let queriesForTemplateRef = null;
                for (let i = 0; i < this.length; i++) {
                    const childQueryIndex = queriesForTemplateRef !== null ? queriesForTemplateRef.length : 0;
                    const tqueryClone = this.getByIndex(i).embeddedTView(tNode, childQueryIndex);
                    if (tqueryClone) {
                        tqueryClone.indexInDeclarationView = i;
                        if (queriesForTemplateRef !== null) {
                            queriesForTemplateRef.push(tqueryClone);
                        } else {
                            queriesForTemplateRef = [ tqueryClone ];
                        }
                    }
                }
                return queriesForTemplateRef !== null ? new TQueries_(queriesForTemplateRef) : null;
            }
            template(tView, tNode) {
                for (let i = 0; i < this.queries.length; i++) {
                    this.queries[i].template(tView, tNode);
                }
            }
            getByIndex(index) {
                return this.queries[index];
            }
            get length() {
                return this.queries.length;
            }
            track(tquery) {
                this.queries.push(tquery);
            }
        }
        class TQuery_ {
            constructor(metadata, nodeIndex = -1) {
                this.metadata = metadata;
                this.matches = null;
                this.indexInDeclarationView = -1;
                this.crossesNgTemplate = false;
                this._appliesToNextNode = true;
                this._declarationNodeIndex = nodeIndex;
            }
            elementStart(tView, tNode) {
                if (this.isApplyingToNode(tNode)) {
                    this.matchTNode(tView, tNode);
                }
            }
            elementEnd(tNode) {
                if (this._declarationNodeIndex === tNode.index) {
                    this._appliesToNextNode = false;
                }
            }
            template(tView, tNode) {
                this.elementStart(tView, tNode);
            }
            embeddedTView(tNode, childQueryIndex) {
                if (this.isApplyingToNode(tNode)) {
                    this.crossesNgTemplate = true;
                    this.addMatch(-tNode.index, childQueryIndex);
                    return new TQuery_(this.metadata);
                }
                return null;
            }
            isApplyingToNode(tNode) {
                if (this._appliesToNextNode && (this.metadata.flags & 1) !== 1) {
                    const declarationNodeIdx = this._declarationNodeIndex;
                    let parent = tNode.parent;
                    while (parent !== null && parent.type & 8 && parent.index !== declarationNodeIdx) {
                        parent = parent.parent;
                    }
                    return declarationNodeIdx === (parent !== null ? parent.index : -1);
                }
                return this._appliesToNextNode;
            }
            matchTNode(tView, tNode) {
                const predicate = this.metadata.predicate;
                if (Array.isArray(predicate)) {
                    for (let i = 0; i < predicate.length; i++) {
                        const name = predicate[i];
                        this.matchTNodeWithReadOption(tView, tNode, getIdxOfMatchingSelector(tNode, name));
                        this.matchTNodeWithReadOption(tView, tNode, locateDirectiveOrProvider(tNode, tView, name, false, false));
                    }
                } else {
                    if (predicate === TemplateRef) {
                        if (tNode.type & 4) {
                            this.matchTNodeWithReadOption(tView, tNode, -1);
                        }
                    } else {
                        this.matchTNodeWithReadOption(tView, tNode, locateDirectiveOrProvider(tNode, tView, predicate, false, false));
                    }
                }
            }
            matchTNodeWithReadOption(tView, tNode, nodeMatchIdx) {
                if (nodeMatchIdx !== null) {
                    const read = this.metadata.read;
                    if (read !== null) {
                        if (read === core_ElementRef || read === ViewContainerRef || read === TemplateRef && tNode.type & 4) {
                            this.addMatch(tNode.index, -2);
                        } else {
                            const directiveOrProviderIdx = locateDirectiveOrProvider(tNode, tView, read, false, false);
                            if (directiveOrProviderIdx !== null) {
                                this.addMatch(tNode.index, directiveOrProviderIdx);
                            }
                        }
                    } else {
                        this.addMatch(tNode.index, nodeMatchIdx);
                    }
                }
            }
            addMatch(tNodeIdx, matchIdx) {
                if (this.matches === null) {
                    this.matches = [ tNodeIdx, matchIdx ];
                } else {
                    this.matches.push(tNodeIdx, matchIdx);
                }
            }
        }
        function getIdxOfMatchingSelector(tNode, selector) {
            const localNames = tNode.localNames;
            if (localNames !== null) {
                for (let i = 0; i < localNames.length; i += 2) {
                    if (localNames[i] === selector) {
                        return localNames[i + 1];
                    }
                }
            }
            return null;
        }
        function createResultByTNodeType(tNode, currentView) {
            if (tNode.type & (3 | 8)) {
                return createElementRef(tNode, currentView);
            } else if (tNode.type & 4) {
                return createTemplateRef(tNode, currentView);
            }
            return null;
        }
        function createResultForNode(lView, tNode, matchingIdx, read) {
            if (matchingIdx === -1) {
                return createResultByTNodeType(tNode, lView);
            } else if (matchingIdx === -2) {
                return createSpecialToken(lView, tNode, read);
            } else {
                return getNodeInjectable(lView, lView[TVIEW], matchingIdx, tNode);
            }
        }
        function createSpecialToken(lView, tNode, read) {
            if (read === core_ElementRef) {
                return createElementRef(tNode, lView);
            } else if (read === TemplateRef) {
                return createTemplateRef(tNode, lView);
            } else if (read === ViewContainerRef) {
                return createContainerRef(tNode, lView);
            } else {}
        }
        function materializeViewResults(tView, lView, tQuery, queryIndex) {
            const lQuery = lView[QUERIES].queries[queryIndex];
            if (lQuery.matches === null) {
                const tViewData = tView.data;
                const tQueryMatches = tQuery.matches;
                const result = [];
                for (let i = 0; i < tQueryMatches.length; i += 2) {
                    const matchedNodeIdx = tQueryMatches[i];
                    if (matchedNodeIdx < 0) {
                        result.push(null);
                    } else {
                        const tNode = tViewData[matchedNodeIdx];
                        result.push(createResultForNode(lView, tNode, tQueryMatches[i + 1], tQuery.metadata.read));
                    }
                }
                lQuery.matches = result;
            }
            return lQuery.matches;
        }
        function collectQueryResults(tView, lView, queryIndex, result) {
            const tQuery = tView.queries.getByIndex(queryIndex);
            const tQueryMatches = tQuery.matches;
            if (tQueryMatches !== null) {
                const lViewResults = materializeViewResults(tView, lView, tQuery, queryIndex);
                for (let i = 0; i < tQueryMatches.length; i += 2) {
                    const tNodeIdx = tQueryMatches[i];
                    if (tNodeIdx > 0) {
                        result.push(lViewResults[i / 2]);
                    } else {
                        const childQueryIndex = tQueryMatches[i + 1];
                        const declarationLContainer = lView[-tNodeIdx];
                        for (let i2 = CONTAINER_HEADER_OFFSET; i2 < declarationLContainer.length; i2++) {
                            const embeddedLView = declarationLContainer[i2];
                            if (embeddedLView[DECLARATION_LCONTAINER] === embeddedLView[PARENT]) {
                                collectQueryResults(embeddedLView[TVIEW], embeddedLView, childQueryIndex, result);
                            }
                        }
                        if (declarationLContainer[MOVED_VIEWS] !== null) {
                            const embeddedLViews = declarationLContainer[MOVED_VIEWS];
                            for (let i2 = 0; i2 < embeddedLViews.length; i2++) {
                                const embeddedLView = embeddedLViews[i2];
                                collectQueryResults(embeddedLView[TVIEW], embeddedLView, childQueryIndex, result);
                            }
                        }
                    }
                }
            }
            return result;
        }
        function queryRefresh(queryList) {
            const lView = getLView();
            const tView = getTView();
            const queryIndex = getCurrentQueryIndex();
            setCurrentQueryIndex(queryIndex + 1);
            const tQuery = getTQuery(tView, queryIndex);
            if (queryList.dirty && isCreationMode(lView) === ((tQuery.metadata.flags & 2) === 2)) {
                if (tQuery.matches === null) {
                    queryList.reset([]);
                } else {
                    const result = tQuery.crossesNgTemplate ? collectQueryResults(tView, lView, queryIndex, []) : materializeViewResults(tView, lView, tQuery, queryIndex);
                    queryList.reset(result, unwrapElementRef);
                    queryList.notifyOnChanges();
                }
                return true;
            }
            return false;
        }
        function viewQuery(predicate, flags, read) {
            const tView = getTView();
            if (tView.firstCreatePass) {
                createTQuery(tView, new TQueryMetadata_(predicate, flags, read), -1);
                if ((flags & 2) === 2) {
                    tView.staticViewQueries = true;
                }
            }
            createLQuery(tView, getLView(), flags);
        }
        function contentQuery(directiveIndex, predicate, flags, read) {
            const tView = getTView();
            if (tView.firstCreatePass) {
                const tNode = getCurrentTNode();
                createTQuery(tView, new TQueryMetadata_(predicate, flags, read), tNode.index);
                saveContentQueryAndDirectiveIndex(tView, directiveIndex);
                if ((flags & 2) === 2) {
                    tView.staticContentQueries = true;
                }
            }
            createLQuery(tView, getLView(), flags);
        }
        function loadQuery() {
            return loadQueryInternal(getLView(), getCurrentQueryIndex());
        }
        function loadQueryInternal(lView, queryIndex) {
            return lView[QUERIES].queries[queryIndex].queryList;
        }
        function createLQuery(tView, lView, flags) {
            const queryList = new QueryList((flags & 4) === 4);
            storeCleanupWithContext(tView, lView, queryList, queryList.destroy);
            if (lView[QUERIES] === null) {
                lView[QUERIES] = new LQueries_;
            }
            lView[QUERIES].queries.push(new LQuery_(queryList));
        }
        function createTQuery(tView, metadata, nodeIndex) {
            if (tView.queries === null) {
                tView.queries = new TQueries_;
            }
            tView.queries.track(new TQuery_(metadata, nodeIndex));
        }
        function saveContentQueryAndDirectiveIndex(tView, directiveIndex) {
            const tViewContentQueries = tView.contentQueries || (tView.contentQueries = []);
            const lastSavedDirectiveIndex = tViewContentQueries.length ? tViewContentQueries[tViewContentQueries.length - 1] : -1;
            if (directiveIndex !== lastSavedDirectiveIndex) {
                tViewContentQueries.push(tView.queries.length - 1, directiveIndex);
            }
        }
        function getTQuery(tView, index) {
            return tView.queries.getByIndex(index);
        }
        function templateRefExtractor(tNode, lView) {
            return createTemplateRef(tNode, lView);
        }
        const angularCoreEnv = (() => ({
            attribute,
            attributeInterpolate1,
            attributeInterpolate2,
            attributeInterpolate3,
            attributeInterpolate4,
            attributeInterpolate5,
            attributeInterpolate6,
            attributeInterpolate7,
            attributeInterpolate8,
            attributeInterpolateV,
            defineComponent,
            defineDirective,
            defineInjectable,
            defineInjector,
            defineNgModule,
            definePipe,
            directiveInject,
            getInheritedFactory,
            inject: core_inject,
            injectAttribute,
            invalidFactory,
            invalidFactoryDep,
            templateRefExtractor,
            resetView,
            NgOnChangesFeature,
            ProvidersFeature,
            CopyDefinitionFeature,
            InheritDefinitionFeature,
            StandaloneFeature,
            nextContext,
            namespaceHTML,
            namespaceMathML,
            namespaceSVG,
            enableBindings,
            disableBindings,
            elementStart,
            elementEnd,
            element,
            elementContainerStart,
            elementContainerEnd,
            elementContainer,
            pureFunction0,
            pureFunction1,
            pureFunction2,
            pureFunction3,
            pureFunction4,
            pureFunction5,
            pureFunction6,
            pureFunction7,
            pureFunction8,
            pureFunctionV,
            getCurrentView,
            restoreView,
            listener,
            projection,
            syntheticHostProperty,
            syntheticHostListener,
            pipeBind1,
            pipeBind2,
            pipeBind3,
            pipeBind4,
            pipeBindV,
            projectionDef,
            hostProperty,
            property,
            propertyInterpolate,
            propertyInterpolate1,
            propertyInterpolate2,
            propertyInterpolate3,
            propertyInterpolate4,
            propertyInterpolate5,
            propertyInterpolate6,
            propertyInterpolate7,
            propertyInterpolate8,
            propertyInterpolateV,
            pipe,
            queryRefresh,
            viewQuery,
            loadQuery,
            contentQuery,
            reference,
            classMap,
            classMapInterpolate1,
            classMapInterpolate2,
            classMapInterpolate3,
            classMapInterpolate4,
            classMapInterpolate5,
            classMapInterpolate6,
            classMapInterpolate7,
            classMapInterpolate8,
            classMapInterpolateV,
            styleMap,
            styleMapInterpolate1,
            styleMapInterpolate2,
            styleMapInterpolate3,
            styleMapInterpolate4,
            styleMapInterpolate5,
            styleMapInterpolate6,
            styleMapInterpolate7,
            styleMapInterpolate8,
            styleMapInterpolateV,
            styleProp,
            stylePropInterpolate1,
            stylePropInterpolate2,
            stylePropInterpolate3,
            stylePropInterpolate4,
            stylePropInterpolate5,
            stylePropInterpolate6,
            stylePropInterpolate7,
            stylePropInterpolate8,
            stylePropInterpolateV,
            classProp,
            advance,
            template,
            text,
            textInterpolate,
            textInterpolate1,
            textInterpolate2,
            textInterpolate3,
            textInterpolate4,
            textInterpolate5,
            textInterpolate6,
            textInterpolate7,
            textInterpolate8,
            textInterpolateV,
            i18n,
            i18nAttributes,
            i18nExp,
            i18nStart,
            i18nEnd,
            i18nApply,
            i18nPostprocess,
            resolveWindow,
            resolveDocument,
            resolveBody,
            setComponentScope,
            setNgModuleScope,
            registerNgModuleType: registerNgModuleType,
            sanitizeHtml,
            sanitizeStyle,
            sanitizeResourceUrl,
            sanitizeScript,
            sanitizeUrl,
            sanitizeUrlOrResourceUrl,
            trustConstantHtml,
            trustConstantResourceUrl,
            validateIframeAttribute,
            forwardRef,
            resolveForwardRef
        }))();
        let jitOptions = null;
        function setJitOptions(options) {
            if (jitOptions !== null) {
                if (options.defaultEncapsulation !== jitOptions.defaultEncapsulation) {
                    return;
                }
                if (options.preserveWhitespaces !== jitOptions.preserveWhitespaces) {
                    return;
                }
            }
            jitOptions = options;
        }
        function getJitOptions() {
            return jitOptions;
        }
        function resetJitOptions() {
            jitOptions = null;
        }
        function patchModuleCompilation() {}
        function isModuleWithProviders(value) {
            return value.ngModule !== void 0;
        }
        function isNgModule(value) {
            return !!getNgModuleDef(value);
        }
        const moduleQueue = [];
        function enqueueModuleForDelayedScoping(moduleType, ngModule) {
            moduleQueue.push({
                moduleType,
                ngModule
            });
        }
        let flushingModuleQueue = false;
        function flushModuleScopingQueueAsMuchAsPossible() {
            if (!flushingModuleQueue) {
                flushingModuleQueue = true;
                try {
                    for (let i = moduleQueue.length - 1; i >= 0; i--) {
                        const {moduleType, ngModule} = moduleQueue[i];
                        if (ngModule.declarations && ngModule.declarations.every(isResolvedDeclaration)) {
                            moduleQueue.splice(i, 1);
                            setScopeOnDeclaredComponents(moduleType, ngModule);
                        }
                    }
                } finally {
                    flushingModuleQueue = false;
                }
            }
        }
        function isResolvedDeclaration(declaration) {
            if (Array.isArray(declaration)) {
                return declaration.every(isResolvedDeclaration);
            }
            return !!resolveForwardRef(declaration);
        }
        function compileNgModule(moduleType, ngModule = {}) {
            patchModuleCompilation();
            compileNgModuleDefs(moduleType, ngModule);
            if (ngModule.id !== void 0) {
                registerNgModuleType(moduleType, ngModule.id);
            }
            enqueueModuleForDelayedScoping(moduleType, ngModule);
        }
        function compileNgModuleDefs(moduleType, ngModule, allowDuplicateDeclarationsInRoot = false) {
            const declarations = flatten(ngModule.declarations || EMPTY_ARRAY);
            let ngModuleDef = null;
            Object.defineProperty(moduleType, NG_MOD_DEF, {
                configurable: true,
                get: () => {
                    if (ngModuleDef === null) {
                        if (false) {
                            throw new Error(`'${stringifyForError(moduleType)}' module can't import itself`);
                        }
                        const compiler = getCompilerFacade({
                            usage: 0,
                            kind: "NgModule",
                            type: moduleType
                        });
                        ngModuleDef = compiler.compileNgModule(angularCoreEnv, `ng:///${moduleType.name}/mod.js`, {
                            type: moduleType,
                            bootstrap: flatten(ngModule.bootstrap || EMPTY_ARRAY).map(resolveForwardRef),
                            declarations: declarations.map(resolveForwardRef),
                            imports: flatten(ngModule.imports || EMPTY_ARRAY).map(resolveForwardRef).map(expandModuleWithProviders),
                            exports: flatten(ngModule.exports || EMPTY_ARRAY).map(resolveForwardRef).map(expandModuleWithProviders),
                            schemas: ngModule.schemas ? flatten(ngModule.schemas) : null,
                            id: ngModule.id || null
                        });
                        if (!ngModuleDef.schemas) {
                            ngModuleDef.schemas = [];
                        }
                    }
                    return ngModuleDef;
                }
            });
            let ngFactoryDef = null;
            Object.defineProperty(moduleType, NG_FACTORY_DEF, {
                get: () => {
                    if (ngFactoryDef === null) {
                        const compiler = getCompilerFacade({
                            usage: 0,
                            kind: "NgModule",
                            type: moduleType
                        });
                        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${moduleType.name}/fac.js`, {
                            name: moduleType.name,
                            type: moduleType,
                            deps: reflectDependencies(moduleType),
                            target: compiler.FactoryTarget.NgModule,
                            typeArgumentCount: 0
                        });
                    }
                    return ngFactoryDef;
                },
                configurable: false
            });
            let ngInjectorDef = null;
            Object.defineProperty(moduleType, NG_INJ_DEF, {
                get: () => {
                    if (ngInjectorDef === null) {
                        const meta = {
                            name: moduleType.name,
                            type: moduleType,
                            providers: ngModule.providers || EMPTY_ARRAY,
                            imports: [ (ngModule.imports || EMPTY_ARRAY).map(resolveForwardRef), (ngModule.exports || EMPTY_ARRAY).map(resolveForwardRef) ]
                        };
                        const compiler = getCompilerFacade({
                            usage: 0,
                            kind: "NgModule",
                            type: moduleType
                        });
                        ngInjectorDef = compiler.compileInjector(angularCoreEnv, `ng:///${moduleType.name}/inj.js`, meta);
                    }
                    return ngInjectorDef;
                },
                configurable: false
            });
        }
        function generateStandaloneInDeclarationsError(type, location2) {
            const prefix = `Unexpected "${stringifyForError(type)}" found in the "declarations" array of the`;
            const suffix = `"${stringifyForError(type)}" is marked as standalone and can't be declared in any NgModule - did you intend to import it instead (by adding it to the "imports" array)?`;
            return `${prefix} ${location2}, ${suffix}`;
        }
        function verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot, importingModule) {
            if (verifiedNgModule.get(moduleType)) {
                return;
            }
            if (isStandalone(moduleType)) {
                return;
            }
            verifiedNgModule.set(moduleType, true);
            moduleType = resolveForwardRef(moduleType);
            let ngModuleDef;
            if (importingModule) {
                ngModuleDef = getNgModuleDef(moduleType);
                if (!ngModuleDef) {
                    throw new Error(`Unexpected value '${moduleType.name}' imported by the module '${importingModule.name}'. Please add an @NgModule annotation.`);
                }
            } else {
                ngModuleDef = getNgModuleDef(moduleType, true);
            }
            const errors = [];
            const declarations = maybeUnwrapFn(ngModuleDef.declarations);
            const imports = maybeUnwrapFn(ngModuleDef.imports);
            flatten(imports).map(unwrapModuleWithProvidersImports).forEach(modOrStandaloneCmpt => {
                verifySemanticsOfNgModuleImport(modOrStandaloneCmpt, moduleType);
                verifySemanticsOfNgModuleDef(modOrStandaloneCmpt, false, moduleType);
            });
            const exports = maybeUnwrapFn(ngModuleDef.exports);
            declarations.forEach(verifyDeclarationsHaveDefinitions);
            declarations.forEach(verifyDirectivesHaveSelector);
            declarations.forEach(declarationType => verifyNotStandalone(declarationType, moduleType));
            const combinedDeclarations = [ ...declarations.map(resolveForwardRef), ...flatten(imports.map(computeCombinedExports)).map(resolveForwardRef) ];
            exports.forEach(verifyExportsAreDeclaredOrReExported);
            declarations.forEach(decl => verifyDeclarationIsUnique(decl, allowDuplicateDeclarationsInRoot));
            declarations.forEach(verifyComponentEntryComponentsIsPartOfNgModule);
            const ngModule = getAnnotation(moduleType, "NgModule");
            if (ngModule) {
                ngModule.imports && flatten(ngModule.imports).map(unwrapModuleWithProvidersImports).forEach(mod => {
                    verifySemanticsOfNgModuleImport(mod, moduleType);
                    verifySemanticsOfNgModuleDef(mod, false, moduleType);
                });
                ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyCorrectBootstrapType);
                ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyComponentIsPartOfNgModule);
                ngModule.entryComponents && deepForEach(ngModule.entryComponents, verifyComponentIsPartOfNgModule);
            }
            if (errors.length) {
                throw new Error(errors.join("\n"));
            }
            function verifyDeclarationsHaveDefinitions(type) {
                type = resolveForwardRef(type);
                const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef$1(type);
                if (!def) {
                    errors.push(`Unexpected value '${stringifyForError(type)}' declared by the module '${stringifyForError(moduleType)}'. Please add a @Pipe/@Directive/@Component annotation.`);
                }
            }
            function verifyDirectivesHaveSelector(type) {
                type = resolveForwardRef(type);
                const def = getDirectiveDef(type);
                if (!getComponentDef(type) && def && def.selectors.length == 0) {
                    errors.push(`Directive ${stringifyForError(type)} has no selector, please add it!`);
                }
            }
            function verifyNotStandalone(type, moduleType2) {
                type = resolveForwardRef(type);
                const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef$1(type);
                if (def?.standalone) {
                    const location2 = `"${stringifyForError(moduleType2)}" NgModule`;
                    errors.push(generateStandaloneInDeclarationsError(type, location2));
                }
            }
            function verifyExportsAreDeclaredOrReExported(type) {
                type = resolveForwardRef(type);
                const kind = getComponentDef(type) && "component" || getDirectiveDef(type) && "directive" || getPipeDef$1(type) && "pipe";
                if (kind) {
                    if (combinedDeclarations.lastIndexOf(type) === -1) {
                        errors.push(`Can't export ${kind} ${stringifyForError(type)} from ${stringifyForError(moduleType)} as it was neither declared nor imported!`);
                    }
                }
            }
            function verifyDeclarationIsUnique(type, suppressErrors) {
                type = resolveForwardRef(type);
                const existingModule = ownerNgModule.get(type);
                if (existingModule && existingModule !== moduleType) {
                    if (!suppressErrors) {
                        const modules2 = [ existingModule, moduleType ].map(stringifyForError).sort();
                        errors.push(`Type ${stringifyForError(type)} is part of the declarations of 2 modules: ${modules2[0]} and ${modules2[1]}! Please consider moving ${stringifyForError(type)} to a higher module that imports ${modules2[0]} and ${modules2[1]}. You can also create a new NgModule that exports and includes ${stringifyForError(type)} then import that NgModule in ${modules2[0]} and ${modules2[1]}.`);
                    }
                } else {
                    ownerNgModule.set(type, moduleType);
                }
            }
            function verifyComponentIsPartOfNgModule(type) {
                type = resolveForwardRef(type);
                const existingModule = ownerNgModule.get(type);
                if (!existingModule && !isStandalone(type)) {
                    errors.push(`Component ${stringifyForError(type)} is not part of any NgModule or the module has not been imported into your module.`);
                }
            }
            function verifyCorrectBootstrapType(type) {
                type = resolveForwardRef(type);
                if (!getComponentDef(type)) {
                    errors.push(`${stringifyForError(type)} cannot be used as an entry component.`);
                }
                if (isStandalone(type)) {
                    errors.push(`The \`${stringifyForError(type)}\` class is a standalone component, which can not be used in the \`@NgModule.bootstrap\` array. Use the \`bootstrapApplication\` function for bootstrap instead.`);
                }
            }
            function verifyComponentEntryComponentsIsPartOfNgModule(type) {
                type = resolveForwardRef(type);
                if (getComponentDef(type)) {
                    const component = getAnnotation(type, "Component");
                    if (component && component.entryComponents) {
                        deepForEach(component.entryComponents, verifyComponentIsPartOfNgModule);
                    }
                }
            }
            function verifySemanticsOfNgModuleImport(type, importingModule2) {
                type = resolveForwardRef(type);
                const directiveDef = getComponentDef(type) || getDirectiveDef(type);
                if (directiveDef !== null && !directiveDef.standalone) {
                    throw new Error(`Unexpected directive '${type.name}' imported by the module '${importingModule2.name}'. Please add an @NgModule annotation.`);
                }
                const pipeDef = getPipeDef$1(type);
                if (pipeDef !== null && !pipeDef.standalone) {
                    throw new Error(`Unexpected pipe '${type.name}' imported by the module '${importingModule2.name}'. Please add an @NgModule annotation.`);
                }
            }
        }
        function unwrapModuleWithProvidersImports(typeOrWithProviders) {
            typeOrWithProviders = resolveForwardRef(typeOrWithProviders);
            return typeOrWithProviders.ngModule || typeOrWithProviders;
        }
        function getAnnotation(type, name) {
            let annotation = null;
            collect(type.__annotations__);
            collect(type.decorators);
            return annotation;
            function collect(annotations) {
                if (annotations) {
                    annotations.forEach(readAnnotation);
                }
            }
            function readAnnotation(decorator) {
                if (!annotation) {
                    const proto = Object.getPrototypeOf(decorator);
                    if (proto.ngMetadataName == name) {
                        annotation = decorator;
                    } else if (decorator.type) {
                        const proto2 = Object.getPrototypeOf(decorator.type);
                        if (proto2.ngMetadataName == name) {
                            annotation = decorator.args[0];
                        }
                    }
                }
            }
        }
        let ownerNgModule = new WeakMap;
        let verifiedNgModule = new WeakMap;
        function resetCompiledComponents() {
            ownerNgModule = new WeakMap;
            verifiedNgModule = new WeakMap;
            moduleQueue.length = 0;
        }
        function computeCombinedExports(type) {
            type = resolveForwardRef(type);
            const ngModuleDef = getNgModuleDef(type);
            if (ngModuleDef === null) {
                return [ type ];
            }
            return [ ...flatten(maybeUnwrapFn(ngModuleDef.exports).map(type2 => {
                const ngModuleDef2 = getNgModuleDef(type2);
                if (ngModuleDef2) {
                    verifySemanticsOfNgModuleDef(type2, false);
                    return computeCombinedExports(type2);
                } else {
                    return type2;
                }
            })) ];
        }
        function setScopeOnDeclaredComponents(moduleType, ngModule) {
            const declarations = flatten(ngModule.declarations || EMPTY_ARRAY);
            const transitiveScopes = transitiveScopesFor(moduleType);
            declarations.forEach(declaration => {
                declaration = resolveForwardRef(declaration);
                if (declaration.hasOwnProperty(NG_COMP_DEF)) {
                    const component = declaration;
                    const componentDef = getComponentDef(component);
                    patchComponentDefWithScope(componentDef, transitiveScopes);
                } else if (!declaration.hasOwnProperty(NG_DIR_DEF) && !declaration.hasOwnProperty(NG_PIPE_DEF)) {
                    declaration.ngSelectorScope = moduleType;
                }
            });
        }
        function patchComponentDefWithScope(componentDef, transitiveScopes) {
            componentDef.directiveDefs = () => Array.from(transitiveScopes.compilation.directives).map(dir => dir.hasOwnProperty(NG_COMP_DEF) ? getComponentDef(dir) : getDirectiveDef(dir)).filter(def => !!def);
            componentDef.pipeDefs = () => Array.from(transitiveScopes.compilation.pipes).map(pipe2 => getPipeDef$1(pipe2));
            componentDef.schemas = transitiveScopes.schemas;
            componentDef.tView = null;
        }
        function transitiveScopesFor(type) {
            if (isNgModule(type)) {
                return transitiveScopesForNgModule(type);
            } else if (isStandalone(type)) {
                const directiveDef = getComponentDef(type) || getDirectiveDef(type);
                if (directiveDef !== null) {
                    return {
                        schemas: null,
                        compilation: {
                            directives: new Set,
                            pipes: new Set
                        },
                        exported: {
                            directives: new Set([ type ]),
                            pipes: new Set
                        }
                    };
                }
                const pipeDef = getPipeDef$1(type);
                if (pipeDef !== null) {
                    return {
                        schemas: null,
                        compilation: {
                            directives: new Set,
                            pipes: new Set
                        },
                        exported: {
                            directives: new Set,
                            pipes: new Set([ type ])
                        }
                    };
                }
            }
            throw new Error(`${type.name} does not have a module def (mod property)`);
        }
        function transitiveScopesForNgModule(moduleType) {
            const def = getNgModuleDef(moduleType, true);
            if (def.transitiveCompileScopes !== null) {
                return def.transitiveCompileScopes;
            }
            const scopes = {
                schemas: def.schemas || null,
                compilation: {
                    directives: new Set,
                    pipes: new Set
                },
                exported: {
                    directives: new Set,
                    pipes: new Set
                }
            };
            maybeUnwrapFn(def.imports).forEach(imported => {
                const importedScope = transitiveScopesFor(imported);
                importedScope.exported.directives.forEach(entry => scopes.compilation.directives.add(entry));
                importedScope.exported.pipes.forEach(entry => scopes.compilation.pipes.add(entry));
            });
            maybeUnwrapFn(def.declarations).forEach(declared => {
                const declaredWithDefs = declared;
                if (getPipeDef$1(declaredWithDefs)) {
                    scopes.compilation.pipes.add(declared);
                } else {
                    scopes.compilation.directives.add(declared);
                }
            });
            maybeUnwrapFn(def.exports).forEach(exported => {
                const exportedType = exported;
                if (isNgModule(exportedType)) {
                    const exportedScope = transitiveScopesFor(exportedType);
                    exportedScope.exported.directives.forEach(entry => {
                        scopes.compilation.directives.add(entry);
                        scopes.exported.directives.add(entry);
                    });
                    exportedScope.exported.pipes.forEach(entry => {
                        scopes.compilation.pipes.add(entry);
                        scopes.exported.pipes.add(entry);
                    });
                } else if (getPipeDef$1(exportedType)) {
                    scopes.exported.pipes.add(exportedType);
                } else {
                    scopes.exported.directives.add(exportedType);
                }
            });
            def.transitiveCompileScopes = scopes;
            return scopes;
        }
        function expandModuleWithProviders(value) {
            if (isModuleWithProviders(value)) {
                return value.ngModule;
            }
            return value;
        }
        let compilationDepth = 0;
        function compileComponent(type, metadata) {
            let ngComponentDef = null;
            maybeQueueResolutionOfComponentResources(type, metadata);
            addDirectiveFactoryDef(type, metadata);
            Object.defineProperty(type, NG_COMP_DEF, {
                get: () => {
                    if (ngComponentDef === null) {
                        const compiler = getCompilerFacade({
                            usage: 0,
                            kind: "component",
                            type
                        });
                        if (componentNeedsResolution(metadata)) {
                            const error = [ `Component '${type.name}' is not resolved:` ];
                            if (metadata.templateUrl) {
                                error.push(` - templateUrl: ${metadata.templateUrl}`);
                            }
                            if (metadata.styleUrls && metadata.styleUrls.length) {
                                error.push(` - styleUrls: ${JSON.stringify(metadata.styleUrls)}`);
                            }
                            error.push(`Did you run and wait for 'resolveComponentResources()'?`);
                            throw new Error(error.join("\n"));
                        }
                        const options = getJitOptions();
                        let preserveWhitespaces = metadata.preserveWhitespaces;
                        if (preserveWhitespaces === void 0) {
                            if (options !== null && options.preserveWhitespaces !== void 0) {
                                preserveWhitespaces = options.preserveWhitespaces;
                            } else {
                                preserveWhitespaces = false;
                            }
                        }
                        let encapsulation = metadata.encapsulation;
                        if (encapsulation === void 0) {
                            if (options !== null && options.defaultEncapsulation !== void 0) {
                                encapsulation = options.defaultEncapsulation;
                            } else {
                                encapsulation = ViewEncapsulation$1.Emulated;
                            }
                        }
                        const templateUrl = metadata.templateUrl || `ng:///${type.name}/template.html`;
                        const meta = {
                            ...directiveMetadata(type, metadata),
                            typeSourceSpan: compiler.createParseSourceSpan("Component", type.name, templateUrl),
                            template: metadata.template || "",
                            preserveWhitespaces,
                            styles: metadata.styles || EMPTY_ARRAY,
                            animations: metadata.animations,
                            declarations: [],
                            changeDetection: metadata.changeDetection,
                            encapsulation,
                            interpolation: metadata.interpolation,
                            viewProviders: metadata.viewProviders || null,
                            isStandalone: !!metadata.standalone
                        };
                        compilationDepth++;
                        try {
                            if (meta.usesInheritance) {
                                addDirectiveDefToUndecoratedParents(type);
                            }
                            ngComponentDef = compiler.compileComponent(angularCoreEnv, templateUrl, meta);
                            if (metadata.standalone) {
                                const imports = flatten(metadata.imports || EMPTY_ARRAY);
                                const {directiveDefs, pipeDefs} = getStandaloneDefFunctions(type, imports);
                                ngComponentDef.directiveDefs = directiveDefs;
                                ngComponentDef.pipeDefs = pipeDefs;
                                ngComponentDef.dependencies = () => imports.map(resolveForwardRef);
                            }
                        } finally {
                            compilationDepth--;
                        }
                        if (compilationDepth === 0) {
                            flushModuleScopingQueueAsMuchAsPossible();
                        }
                        if (hasSelectorScope(type)) {
                            const scopes = transitiveScopesFor(type.ngSelectorScope);
                            patchComponentDefWithScope(ngComponentDef, scopes);
                        }
                        if (metadata.schemas) {
                            if (metadata.standalone) {
                                ngComponentDef.schemas = metadata.schemas;
                            } else {
                                throw new Error(`The 'schemas' was specified for the ${stringifyForError(type)} but is only valid on a component that is standalone.`);
                            }
                        } else if (metadata.standalone) {
                            ngComponentDef.schemas = [];
                        }
                    }
                    return ngComponentDef;
                },
                configurable: false
            });
        }
        function getDependencyTypeForError(type) {
            if (getComponentDef(type)) {
                return "component";
            }
            if (getDirectiveDef(type)) {
                return "directive";
            }
            if (getPipeDef$1(type)) {
                return "pipe";
            }
            return "type";
        }
        function verifyStandaloneImport(depType, importingType) {
            if (isForwardRef(depType)) {
                depType = resolveForwardRef(depType);
                if (!depType) {
                    throw new Error(`Expected forwardRef function, imported from "${stringifyForError(importingType)}", to return a standalone entity or NgModule but got "${stringifyForError(depType) || depType}".`);
                }
            }
            if (getNgModuleDef(depType) == null) {
                const def = getComponentDef(depType) || getDirectiveDef(depType) || getPipeDef$1(depType);
                if (def != null) {
                    if (!def.standalone) {
                        throw new Error(`The "${stringifyForError(depType)}" ${getDependencyTypeForError(depType)}, imported from "${stringifyForError(importingType)}", is not standalone. Did you forget to add the standalone: true flag?`);
                    }
                } else {
                    if (isModuleWithProviders(depType)) {
                        throw new Error(`A module with providers was imported from "${stringifyForError(importingType)}". Modules with providers are not supported in standalone components imports.`);
                    } else {
                        throw new Error(`The "${stringifyForError(depType)}" type, imported from "${stringifyForError(importingType)}", must be a standalone component / directive / pipe or an NgModule. Did you forget to add the required @Component / @Directive / @Pipe or @NgModule annotation?`);
                    }
                }
            }
        }
        function getStandaloneDefFunctions(type, imports) {
            let cachedDirectiveDefs = null;
            let cachedPipeDefs = null;
            const directiveDefs = () => {
                if (cachedDirectiveDefs === null) {
                    cachedDirectiveDefs = [ getComponentDef(type) ];
                    const seen = new Set;
                    for (const rawDep of imports) {
                        const dep = resolveForwardRef(rawDep);
                        if (seen.has(dep)) {
                            continue;
                        }
                        seen.add(dep);
                        if (!!getNgModuleDef(dep)) {
                            const scope = transitiveScopesFor(dep);
                            for (const dir of scope.exported.directives) {
                                const def = getComponentDef(dir) || getDirectiveDef(dir);
                                if (def && !seen.has(dir)) {
                                    seen.add(dir);
                                    cachedDirectiveDefs.push(def);
                                }
                            }
                        } else {
                            const def = getComponentDef(dep) || getDirectiveDef(dep);
                            if (def) {
                                cachedDirectiveDefs.push(def);
                            }
                        }
                    }
                }
                return cachedDirectiveDefs;
            };
            const pipeDefs = () => {
                if (cachedPipeDefs === null) {
                    cachedPipeDefs = [];
                    const seen = new Set;
                    for (const rawDep of imports) {
                        const dep = resolveForwardRef(rawDep);
                        if (seen.has(dep)) {
                            continue;
                        }
                        seen.add(dep);
                        if (!!getNgModuleDef(dep)) {
                            const scope = transitiveScopesFor(dep);
                            for (const pipe2 of scope.exported.pipes) {
                                const def = getPipeDef$1(pipe2);
                                if (def && !seen.has(pipe2)) {
                                    seen.add(pipe2);
                                    cachedPipeDefs.push(def);
                                }
                            }
                        } else {
                            const def = getPipeDef$1(dep);
                            if (def) {
                                cachedPipeDefs.push(def);
                            }
                        }
                    }
                }
                return cachedPipeDefs;
            };
            return {
                directiveDefs,
                pipeDefs
            };
        }
        function hasSelectorScope(component) {
            return component.ngSelectorScope !== void 0;
        }
        function compileDirective(type, directive) {
            let ngDirectiveDef = null;
            addDirectiveFactoryDef(type, directive || {});
            Object.defineProperty(type, NG_DIR_DEF, {
                get: () => {
                    if (ngDirectiveDef === null) {
                        const meta = getDirectiveMetadata(type, directive || {});
                        const compiler = getCompilerFacade({
                            usage: 0,
                            kind: "directive",
                            type
                        });
                        ngDirectiveDef = compiler.compileDirective(angularCoreEnv, meta.sourceMapUrl, meta.metadata);
                    }
                    return ngDirectiveDef;
                },
                configurable: false
            });
        }
        function getDirectiveMetadata(type, metadata) {
            const name = type && type.name;
            const sourceMapUrl = `ng:///${name}/dir.js`;
            const compiler = getCompilerFacade({
                usage: 0,
                kind: "directive",
                type
            });
            const facade = directiveMetadata(type, metadata);
            facade.typeSourceSpan = compiler.createParseSourceSpan("Directive", name, sourceMapUrl);
            if (facade.usesInheritance) {
                addDirectiveDefToUndecoratedParents(type);
            }
            return {
                metadata: facade,
                sourceMapUrl
            };
        }
        function addDirectiveFactoryDef(type, metadata) {
            let ngFactoryDef = null;
            Object.defineProperty(type, NG_FACTORY_DEF, {
                get: () => {
                    if (ngFactoryDef === null) {
                        const meta = getDirectiveMetadata(type, metadata);
                        const compiler = getCompilerFacade({
                            usage: 0,
                            kind: "directive",
                            type
                        });
                        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${type.name}/fac.js`, {
                            name: meta.metadata.name,
                            type: meta.metadata.type,
                            typeArgumentCount: 0,
                            deps: reflectDependencies(type),
                            target: compiler.FactoryTarget.Directive
                        });
                    }
                    return ngFactoryDef;
                },
                configurable: false
            });
        }
        function extendsDirectlyFromObject(type) {
            return Object.getPrototypeOf(type.prototype) === Object.prototype;
        }
        function directiveMetadata(type, metadata) {
            const reflect = getReflect();
            const propMetadata = reflect.ownPropMetadata(type);
            return {
                name: type.name,
                type,
                selector: metadata.selector !== void 0 ? metadata.selector : null,
                host: metadata.host || EMPTY_OBJ,
                propMetadata,
                inputs: metadata.inputs || EMPTY_ARRAY,
                outputs: metadata.outputs || EMPTY_ARRAY,
                queries: extractQueriesMetadata(type, propMetadata, isContentQuery),
                lifecycle: {
                    usesOnChanges: reflect.hasLifecycleHook(type, "ngOnChanges")
                },
                typeSourceSpan: null,
                usesInheritance: !extendsDirectlyFromObject(type),
                exportAs: extractExportAs(metadata.exportAs),
                providers: metadata.providers || null,
                viewQueries: extractQueriesMetadata(type, propMetadata, isViewQuery),
                isStandalone: !!metadata.standalone
            };
        }
        function addDirectiveDefToUndecoratedParents(type) {
            const objPrototype = Object.prototype;
            let parent = Object.getPrototypeOf(type.prototype).constructor;
            while (parent && parent !== objPrototype) {
                if (!getDirectiveDef(parent) && !getComponentDef(parent) && shouldAddAbstractDirective(parent)) {
                    compileDirective(parent, null);
                }
                parent = Object.getPrototypeOf(parent);
            }
        }
        function convertToR3QueryPredicate(selector) {
            return typeof selector === "string" ? splitByComma(selector) : resolveForwardRef(selector);
        }
        function convertToR3QueryMetadata(propertyName, ann) {
            return {
                propertyName,
                predicate: convertToR3QueryPredicate(ann.selector),
                descendants: ann.descendants,
                first: ann.first,
                read: ann.read ? ann.read : null,
                static: !!ann.static,
                emitDistinctChangesOnly: !!ann.emitDistinctChangesOnly
            };
        }
        function extractQueriesMetadata(type, propMetadata, isQueryAnn) {
            const queriesMeta = [];
            for (const field in propMetadata) {
                if (propMetadata.hasOwnProperty(field)) {
                    const annotations = propMetadata[field];
                    annotations.forEach(ann => {
                        if (isQueryAnn(ann)) {
                            if (!ann.selector) {
                                throw new Error(`Can't construct a query for the property "${field}" of "${stringifyForError(type)}" since the query selector wasn't defined.`);
                            }
                            if (annotations.some(isInputAnnotation)) {
                                throw new Error(`Cannot combine @Input decorators with query decorators`);
                            }
                            queriesMeta.push(convertToR3QueryMetadata(field, ann));
                        }
                    });
                }
            }
            return queriesMeta;
        }
        function extractExportAs(exportAs) {
            return exportAs === void 0 ? null : splitByComma(exportAs);
        }
        function isContentQuery(value) {
            const name = value.ngMetadataName;
            return name === "ContentChild" || name === "ContentChildren";
        }
        function isViewQuery(value) {
            const name = value.ngMetadataName;
            return name === "ViewChild" || name === "ViewChildren";
        }
        function isInputAnnotation(value) {
            return value.ngMetadataName === "Input";
        }
        function splitByComma(value) {
            return value.split(",").map(piece => piece.trim());
        }
        const LIFECYCLE_HOOKS = null;
        function shouldAddAbstractDirective(type) {
            const reflect = getReflect();
            if (LIFECYCLE_HOOKS.some(hookName => reflect.hasLifecycleHook(type, hookName))) {
                return true;
            }
            const propMetadata = reflect.propMetadata(type);
            for (const field in propMetadata) {
                const annotations = propMetadata[field];
                for (let i = 0; i < annotations.length; i++) {
                    const current = annotations[i];
                    const metadataName = current.ngMetadataName;
                    if (isInputAnnotation(current) || isContentQuery(current) || isViewQuery(current) || metadataName === "Output" || metadataName === "HostBinding" || metadataName === "HostListener") {
                        return true;
                    }
                }
            }
            return false;
        }
        function compilePipe(type, meta) {
            let ngPipeDef = null;
            let ngFactoryDef = null;
            Object.defineProperty(type, NG_FACTORY_DEF, {
                get: () => {
                    if (ngFactoryDef === null) {
                        const metadata = getPipeMetadata(type, meta);
                        const compiler = getCompilerFacade({
                            usage: 0,
                            kind: "pipe",
                            type: metadata.type
                        });
                        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${metadata.name}/fac.js`, {
                            name: metadata.name,
                            type: metadata.type,
                            typeArgumentCount: 0,
                            deps: reflectDependencies(type),
                            target: compiler.FactoryTarget.Pipe
                        });
                    }
                    return ngFactoryDef;
                },
                configurable: false
            });
            Object.defineProperty(type, NG_PIPE_DEF, {
                get: () => {
                    if (ngPipeDef === null) {
                        const metadata = getPipeMetadata(type, meta);
                        const compiler = getCompilerFacade({
                            usage: 0,
                            kind: "pipe",
                            type: metadata.type
                        });
                        ngPipeDef = compiler.compilePipe(angularCoreEnv, `ng:///${metadata.name}/pipe.js`, metadata);
                    }
                    return ngPipeDef;
                },
                configurable: false
            });
        }
        function getPipeMetadata(type, meta) {
            return {
                type,
                name: type.name,
                pipeName: meta.name,
                pure: meta.pure !== void 0 ? meta.pure : true,
                isStandalone: !!meta.standalone
            };
        }
        const Directive = null;
        const Component = null;
        const Pipe = null;
        const Input = null;
        const Output = null;
        const HostBinding = null;
        const HostListener = null;
        const NgModule = makeDecorator("NgModule", ngModule => ngModule, void 0, void 0, (type, meta) => compileNgModule(type, meta));
        function core_noop(...args) {}
        const ITS_JUST_ANGULAR = true;
        const APP_INITIALIZER = new InjectionToken("Application Initializer");
        let ApplicationInitStatus = (() => {
            class ApplicationInitStatus2 {
                constructor(appInits) {
                    this.appInits = appInits;
                    this.resolve = core_noop;
                    this.reject = core_noop;
                    this.initialized = false;
                    this.done = false;
                    this.donePromise = new Promise((res, rej) => {
                        this.resolve = res;
                        this.reject = rej;
                    });
                }
                runInitializers() {
                    if (this.initialized) {
                        return;
                    }
                    const asyncInitPromises = [];
                    const complete = () => {
                        this.done = true;
                        this.resolve();
                    };
                    if (this.appInits) {
                        for (let i = 0; i < this.appInits.length; i++) {
                            const initResult = this.appInits[i]();
                            if (core_isPromise(initResult)) {
                                asyncInitPromises.push(initResult);
                            } else if (isObservable(initResult)) {
                                const observableAsPromise = new Promise((resolve, reject) => {
                                    initResult.subscribe({
                                        complete: resolve,
                                        error: reject
                                    });
                                });
                                asyncInitPromises.push(observableAsPromise);
                            }
                        }
                    }
                    Promise.all(asyncInitPromises).then(() => {
                        complete();
                    }).catch(e => {
                        this.reject(e);
                    });
                    if (asyncInitPromises.length === 0) {
                        complete();
                    }
                    this.initialized = true;
                }
            }
            ApplicationInitStatus2.fac = function ApplicationInitStatus_Factory(t) {
                return new (t || ApplicationInitStatus2)(core_inject(APP_INITIALIZER, 8));
            };
            ApplicationInitStatus2.prov = defineInjectable({
                token: ApplicationInitStatus2,
                factory: ApplicationInitStatus2.fac,
                providedIn: "root"
            });
            return ApplicationInitStatus2;
        })();
        (function() {})();
        const core_APP_ID = new InjectionToken("AppId", {
            providedIn: "root",
            factory: _appIdRandomProviderFactory
        });
        function _appIdRandomProviderFactory() {
            return `${_randomChar()}${_randomChar()}${_randomChar()}`;
        }
        const APP_ID_RANDOM_PROVIDER = {
            provide: core_APP_ID,
            useFactory: _appIdRandomProviderFactory,
            deps: []
        };
        function _randomChar() {
            return String.fromCharCode(97 + Math.floor(Math.random() * 25));
        }
        const PLATFORM_INITIALIZER = new InjectionToken("Platform Initializer");
        const core_PLATFORM_ID = new InjectionToken("Platform ID", {
            providedIn: "platform",
            factory: () => "unknown"
        });
        const core_APP_BOOTSTRAP_LISTENER = new InjectionToken("appBootstrapListener");
        const PACKAGE_ROOT_URL = new InjectionToken("Application Packages Root URL");
        const ANIMATION_MODULE_TYPE = new InjectionToken("AnimationModuleType");
        let Console = (() => {
            class Console2 {
                log(message) {
                    console.log(message);
                }
                warn(message) {
                    console.warn(message);
                }
            }
            Console2.fac = function Console_Factory(t) {
                return new (t || Console2);
            };
            Console2.prov = defineInjectable({
                token: Console2,
                factory: Console2.fac,
                providedIn: "platform"
            });
            return Console2;
        })();
        (function() {})();
        function getGlobalLocale() {
            if (false) {
                return goog.LOCALE;
            } else {
                return typeof $localize !== "undefined" && $localize.locale || DEFAULT_LOCALE_ID;
            }
        }
        const LOCALE_ID = new InjectionToken("LocaleId", {
            providedIn: "root",
            factory: () => fesm2020_core_inject(LOCALE_ID, InjectFlags.Optional | InjectFlags.SkipSelf) || getGlobalLocale()
        });
        const DEFAULT_CURRENCY_CODE = new InjectionToken("DefaultCurrencyCode", {
            providedIn: "root",
            factory: () => USD_CURRENCY_CODE
        });
        const TRANSLATIONS = new InjectionToken("Translations");
        const TRANSLATIONS_FORMAT = new InjectionToken("TranslationsFormat");
        var MissingTranslationStrategy = null;
        class ModuleWithComponentFactories {
            constructor(ngModuleFactory, componentFactories) {
                this.ngModuleFactory = ngModuleFactory;
                this.componentFactories = componentFactories;
            }
        }
        let Compiler = (() => {
            class Compiler2 {
                compileModuleSync(moduleType) {
                    return new NgModuleFactory(moduleType);
                }
                compileModuleAsync(moduleType) {
                    return Promise.resolve(this.compileModuleSync(moduleType));
                }
                compileModuleAndAllComponentsSync(moduleType) {
                    const ngModuleFactory = this.compileModuleSync(moduleType);
                    const moduleDef = getNgModuleDef(moduleType);
                    const componentFactories = maybeUnwrapFn(moduleDef.declarations).reduce((factories, declaration) => {
                        const componentDef = getComponentDef(declaration);
                        componentDef && factories.push(new ComponentFactory(componentDef));
                        return factories;
                    }, []);
                    return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);
                }
                compileModuleAndAllComponentsAsync(moduleType) {
                    return Promise.resolve(this.compileModuleAndAllComponentsSync(moduleType));
                }
                clearCache() {}
                clearCacheFor(type) {}
                getModuleId(moduleType) {
                    return void 0;
                }
            }
            Compiler2.fac = function Compiler_Factory(t) {
                return new (t || Compiler2);
            };
            Compiler2.prov = defineInjectable({
                token: Compiler2,
                factory: Compiler2.fac,
                providedIn: "root"
            });
            return Compiler2;
        })();
        (function() {})();
        const COMPILER_OPTIONS = new InjectionToken("compilerOptions");
        class CompilerFactory {}
        function applyChanges(component) {
            markViewDirty(getComponentViewByInstance(component));
            getRootComponents(component).forEach(rootComponent => detectChanges(rootComponent));
        }
        const GLOBAL_PUBLISH_EXPANDO_KEY = "ng";
        let _published = false;
        function publishDefaultGlobalUtils$1() {
            if (!_published) {
                _published = true;
                publishGlobalUtil("setProfiler", setProfiler);
                publishGlobalUtil("getDirectiveMetadata", getDirectiveMetadata$1);
                publishGlobalUtil("getComponent", getComponent);
                publishGlobalUtil("getContext", getContext);
                publishGlobalUtil("getListeners", getListeners);
                publishGlobalUtil("getOwningComponent", getOwningComponent);
                publishGlobalUtil("getHostElement", getHostElement);
                publishGlobalUtil("getInjector", getInjector);
                publishGlobalUtil("getRootComponents", getRootComponents);
                publishGlobalUtil("getDirectives", getDirectives);
                publishGlobalUtil("applyChanges", applyChanges);
            }
        }
        function publishGlobalUtil(name, fn) {
            if (typeof COMPILED === "undefined" || !COMPILED) {
                const w = _global;
                if (w) {
                    let container = w[GLOBAL_PUBLISH_EXPANDO_KEY];
                    if (!container) {
                        container = w[GLOBAL_PUBLISH_EXPANDO_KEY] = {};
                    }
                    container[name] = fn;
                }
            }
        }
        const promise = (() => Promise.resolve(0))();
        function scheduleMicroTask(fn) {
            if (typeof Zone === "undefined") {
                promise.then(() => {
                    fn && fn.apply(null, null);
                });
            } else {
                Zone.current.scheduleMicroTask("scheduleMicrotask", fn);
            }
        }
        function getNativeRequestAnimationFrame() {
            let nativeRequestAnimationFrame = _global["requestAnimationFrame"];
            let nativeCancelAnimationFrame = _global["cancelAnimationFrame"];
            if (typeof Zone !== "undefined" && nativeRequestAnimationFrame && nativeCancelAnimationFrame) {
                const unpatchedRequestAnimationFrame = nativeRequestAnimationFrame[Zone.__symbol__("OriginalDelegate")];
                if (unpatchedRequestAnimationFrame) {
                    nativeRequestAnimationFrame = unpatchedRequestAnimationFrame;
                }
                const unpatchedCancelAnimationFrame = nativeCancelAnimationFrame[Zone.__symbol__("OriginalDelegate")];
                if (unpatchedCancelAnimationFrame) {
                    nativeCancelAnimationFrame = unpatchedCancelAnimationFrame;
                }
            }
            return {
                nativeRequestAnimationFrame,
                nativeCancelAnimationFrame
            };
        }
        class core_NgZone {
            constructor({enableLongStackTrace = false, shouldCoalesceEventChangeDetection = false, shouldCoalesceRunChangeDetection = false}) {
                this.hasPendingMacrotasks = false;
                this.hasPendingMicrotasks = false;
                this.isStable = true;
                this.onUnstable = new EventEmitter(false);
                this.onMicrotaskEmpty = new EventEmitter(false);
                this.onStable = new EventEmitter(false);
                this.onError = new EventEmitter(false);
                if (typeof Zone == "undefined") {
                    throw new RuntimeError(908, false);
                }
                Zone.assertZonePatched();
                const self2 = this;
                self2._nesting = 0;
                self2._outer = self2._inner = Zone.current;
                if (Zone["AsyncStackTaggingZoneSpec"]) {
                    const AsyncStackTaggingZoneSpec = Zone["AsyncStackTaggingZoneSpec"];
                    self2._inner = self2._inner.fork(new AsyncStackTaggingZoneSpec("Angular"));
                }
                if (Zone["TaskTrackingZoneSpec"]) {
                    self2._inner = self2._inner.fork(new Zone["TaskTrackingZoneSpec"]);
                }
                if (enableLongStackTrace && Zone["longStackTraceZoneSpec"]) {
                    self2._inner = self2._inner.fork(Zone["longStackTraceZoneSpec"]);
                }
                self2.shouldCoalesceEventChangeDetection = !shouldCoalesceRunChangeDetection && shouldCoalesceEventChangeDetection;
                self2.shouldCoalesceRunChangeDetection = shouldCoalesceRunChangeDetection;
                self2.lastRequestAnimationFrameId = -1;
                self2.nativeRequestAnimationFrame = getNativeRequestAnimationFrame().nativeRequestAnimationFrame;
                forkInnerZoneWithAngularBehavior(self2);
            }
            static isInAngularZone() {
                return typeof Zone !== "undefined" && Zone.current.get("isAngularZone") === true;
            }
            static assertInAngularZone() {
                if (!core_NgZone.isInAngularZone()) {
                    throw new RuntimeError(909, false);
                }
            }
            static assertNotInAngularZone() {
                if (core_NgZone.isInAngularZone()) {
                    throw new RuntimeError(909, false);
                }
            }
            run(fn, applyThis, applyArgs) {
                return this._inner.run(fn, applyThis, applyArgs);
            }
            runTask(fn, applyThis, applyArgs, name) {
                const zone = this._inner;
                const task = zone.scheduleEventTask("NgZoneEvent: " + name, fn, EMPTY_PAYLOAD, core_noop, core_noop);
                try {
                    return zone.runTask(task, applyThis, applyArgs);
                } finally {
                    zone.cancelTask(task);
                }
            }
            runGuarded(fn, applyThis, applyArgs) {
                return this._inner.runGuarded(fn, applyThis, applyArgs);
            }
            runOutsideAngular(fn) {
                return this._outer.run(fn);
            }
        }
        const EMPTY_PAYLOAD = {};
        function checkStable(zone) {
            if (zone._nesting == 0 && !zone.hasPendingMicrotasks && !zone.isStable) {
                try {
                    zone._nesting++;
                    zone.onMicrotaskEmpty.emit(null);
                } finally {
                    zone._nesting--;
                    if (!zone.hasPendingMicrotasks) {
                        try {
                            zone.runOutsideAngular(() => zone.onStable.emit(null));
                        } finally {
                            zone.isStable = true;
                        }
                    }
                }
            }
        }
        function delayChangeDetectionForEvents(zone) {
            if (zone.isCheckStableRunning || zone.lastRequestAnimationFrameId !== -1) {
                return;
            }
            zone.lastRequestAnimationFrameId = zone.nativeRequestAnimationFrame.call(_global, () => {
                if (!zone.fakeTopEventTask) {
                    zone.fakeTopEventTask = Zone.root.scheduleEventTask("fakeTopEventTask", () => {
                        zone.lastRequestAnimationFrameId = -1;
                        updateMicroTaskStatus(zone);
                        zone.isCheckStableRunning = true;
                        checkStable(zone);
                        zone.isCheckStableRunning = false;
                    }, void 0, () => {}, () => {});
                }
                zone.fakeTopEventTask.invoke();
            });
            updateMicroTaskStatus(zone);
        }
        function forkInnerZoneWithAngularBehavior(zone) {
            const delayChangeDetectionForEventsDelegate = () => {
                delayChangeDetectionForEvents(zone);
            };
            zone._inner = zone._inner.fork({
                name: "angular",
                properties: {
                    isAngularZone: true
                },
                onInvokeTask: (delegate, current, target, task, applyThis, applyArgs) => {
                    try {
                        onEnter(zone);
                        return delegate.invokeTask(target, task, applyThis, applyArgs);
                    } finally {
                        if (zone.shouldCoalesceEventChangeDetection && task.type === "eventTask" || zone.shouldCoalesceRunChangeDetection) {
                            delayChangeDetectionForEventsDelegate();
                        }
                        onLeave(zone);
                    }
                },
                onInvoke: (delegate, current, target, callback, applyThis, applyArgs, source) => {
                    try {
                        onEnter(zone);
                        return delegate.invoke(target, callback, applyThis, applyArgs, source);
                    } finally {
                        if (zone.shouldCoalesceRunChangeDetection) {
                            delayChangeDetectionForEventsDelegate();
                        }
                        onLeave(zone);
                    }
                },
                onHasTask: (delegate, current, target, hasTaskState) => {
                    delegate.hasTask(target, hasTaskState);
                    if (current === target) {
                        if (hasTaskState.change == "microTask") {
                            zone._hasPendingMicrotasks = hasTaskState.microTask;
                            updateMicroTaskStatus(zone);
                            checkStable(zone);
                        } else if (hasTaskState.change == "macroTask") {
                            zone.hasPendingMacrotasks = hasTaskState.macroTask;
                        }
                    }
                },
                onHandleError: (delegate, current, target, error) => {
                    delegate.handleError(target, error);
                    zone.runOutsideAngular(() => zone.onError.emit(error));
                    return false;
                }
            });
        }
        function updateMicroTaskStatus(zone) {
            if (zone._hasPendingMicrotasks || (zone.shouldCoalesceEventChangeDetection || zone.shouldCoalesceRunChangeDetection) && zone.lastRequestAnimationFrameId !== -1) {
                zone.hasPendingMicrotasks = true;
            } else {
                zone.hasPendingMicrotasks = false;
            }
        }
        function onEnter(zone) {
            zone._nesting++;
            if (zone.isStable) {
                zone.isStable = false;
                zone.onUnstable.emit(null);
            }
        }
        function onLeave(zone) {
            zone._nesting--;
            checkStable(zone);
        }
        class NoopNgZone {
            constructor() {
                this.hasPendingMicrotasks = false;
                this.hasPendingMacrotasks = false;
                this.isStable = true;
                this.onUnstable = new EventEmitter;
                this.onMicrotaskEmpty = new EventEmitter;
                this.onStable = new EventEmitter;
                this.onError = new EventEmitter;
            }
            run(fn, applyThis, applyArgs) {
                return fn.apply(applyThis, applyArgs);
            }
            runGuarded(fn, applyThis, applyArgs) {
                return fn.apply(applyThis, applyArgs);
            }
            runOutsideAngular(fn) {
                return fn();
            }
            runTask(fn, applyThis, applyArgs, name) {
                return fn.apply(applyThis, applyArgs);
            }
        }
        const TESTABILITY = new InjectionToken("");
        const TESTABILITY_GETTER = new InjectionToken("");
        let Testability = (() => {
            class Testability2 {
                constructor(_ngZone, registry, testabilityGetter) {
                    this._ngZone = _ngZone;
                    this.registry = registry;
                    this._pendingCount = 0;
                    this._isZoneStable = true;
                    this._didWork = false;
                    this._callbacks = [];
                    this.taskTrackingZone = null;
                    if (!_testabilityGetter) {
                        setTestabilityGetter(testabilityGetter);
                        testabilityGetter.addToWindow(registry);
                    }
                    this._watchAngularEvents();
                    _ngZone.run(() => {
                        this.taskTrackingZone = typeof Zone == "undefined" ? null : Zone.current.get("TaskTrackingZone");
                    });
                }
                _watchAngularEvents() {
                    this._ngZone.onUnstable.subscribe({
                        next: () => {
                            this._didWork = true;
                            this._isZoneStable = false;
                        }
                    });
                    this._ngZone.runOutsideAngular(() => {
                        this._ngZone.onStable.subscribe({
                            next: () => {
                                core_NgZone.assertNotInAngularZone();
                                scheduleMicroTask(() => {
                                    this._isZoneStable = true;
                                    this._runCallbacksIfReady();
                                });
                            }
                        });
                    });
                }
                increasePendingRequestCount() {
                    this._pendingCount += 1;
                    this._didWork = true;
                    return this._pendingCount;
                }
                decreasePendingRequestCount() {
                    this._pendingCount -= 1;
                    if (this._pendingCount < 0) {
                        throw new Error("pending async requests below zero");
                    }
                    this._runCallbacksIfReady();
                    return this._pendingCount;
                }
                isStable() {
                    return this._isZoneStable && this._pendingCount === 0 && !this._ngZone.hasPendingMacrotasks;
                }
                _runCallbacksIfReady() {
                    if (this.isStable()) {
                        scheduleMicroTask(() => {
                            while (this._callbacks.length !== 0) {
                                let cb = this._callbacks.pop();
                                clearTimeout(cb.timeoutId);
                                cb.doneCb(this._didWork);
                            }
                            this._didWork = false;
                        });
                    } else {
                        let pending = this.getPendingTasks();
                        this._callbacks = this._callbacks.filter(cb => {
                            if (cb.updateCb && cb.updateCb(pending)) {
                                clearTimeout(cb.timeoutId);
                                return false;
                            }
                            return true;
                        });
                        this._didWork = true;
                    }
                }
                getPendingTasks() {
                    if (!this.taskTrackingZone) {
                        return [];
                    }
                    return this.taskTrackingZone.macroTasks.map(t => ({
                        source: t.source,
                        creationLocation: t.creationLocation,
                        data: t.data
                    }));
                }
                addCallback(cb, timeout, updateCb) {
                    let timeoutId = -1;
                    if (timeout && timeout > 0) {
                        timeoutId = setTimeout(() => {
                            this._callbacks = this._callbacks.filter(cb2 => cb2.timeoutId !== timeoutId);
                            cb(this._didWork, this.getPendingTasks());
                        }, timeout);
                    }
                    this._callbacks.push({
                        doneCb: cb,
                        timeoutId,
                        updateCb
                    });
                }
                whenStable(doneCb, timeout, updateCb) {
                    if (updateCb && !this.taskTrackingZone) {
                        throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');
                    }
                    this.addCallback(doneCb, timeout, updateCb);
                    this._runCallbacksIfReady();
                }
                getPendingRequestCount() {
                    return this._pendingCount;
                }
                registerApplication(token) {
                    this.registry.registerApplication(token, this);
                }
                unregisterApplication(token) {
                    this.registry.unregisterApplication(token);
                }
                findProviders(using, provider, exactMatch) {
                    return [];
                }
            }
            Testability2.fac = function Testability_Factory(t) {
                return new (t || Testability2)(core_inject(core_NgZone), core_inject(TestabilityRegistry), core_inject(TESTABILITY_GETTER));
            };
            Testability2.prov = defineInjectable({
                token: Testability2,
                factory: Testability2.fac
            });
            return Testability2;
        })();
        (function() {})();
        let TestabilityRegistry = (() => {
            class TestabilityRegistry2 {
                constructor() {
                    this._applications = new Map;
                }
                registerApplication(token, testability) {
                    this._applications.set(token, testability);
                }
                unregisterApplication(token) {
                    this._applications.delete(token);
                }
                unregisterAllApplications() {
                    this._applications.clear();
                }
                getTestability(elem) {
                    return this._applications.get(elem) || null;
                }
                getAllTestabilities() {
                    return Array.from(this._applications.values());
                }
                getAllRootElements() {
                    return Array.from(this._applications.keys());
                }
                findTestabilityInTree(elem, findInAncestors = true) {
                    return _testabilityGetter?.findTestabilityInTree(this, elem, findInAncestors) ?? null;
                }
            }
            TestabilityRegistry2.fac = function TestabilityRegistry_Factory(t) {
                return new (t || TestabilityRegistry2);
            };
            TestabilityRegistry2.prov = defineInjectable({
                token: TestabilityRegistry2,
                factory: TestabilityRegistry2.fac,
                providedIn: "platform"
            });
            return TestabilityRegistry2;
        })();
        (function() {})();
        function setTestabilityGetter(getter) {
            _testabilityGetter = getter;
        }
        let _testabilityGetter;
        let _platformInjector = null;
        const ALLOW_MULTIPLE_PLATFORMS = new InjectionToken("AllowMultipleToken");
        const PLATFORM_DESTROY_LISTENERS = new InjectionToken("PlatformDestroyListeners");
        const NG_DEV_MODE = false;
        function compileNgModuleFactory(injector, options, moduleType) {
            const moduleFactory = new NgModuleFactory(moduleType);
            if (true) {
                return Promise.resolve(moduleFactory);
            }
            const compilerOptions = injector.get(COMPILER_OPTIONS, []).concat(options);
            setJitOptions({
                defaultEncapsulation: _lastDefined(compilerOptions.map(opts => opts.defaultEncapsulation)),
                preserveWhitespaces: _lastDefined(compilerOptions.map(opts => opts.preserveWhitespaces))
            });
            if (isComponentResourceResolutionQueueEmpty()) {
                return Promise.resolve(moduleFactory);
            }
            const compilerProviders = _mergeArrays(compilerOptions.map(o => o.providers));
            if (compilerProviders.length === 0) {
                return Promise.resolve(moduleFactory);
            }
            const compiler = getCompilerFacade({
                usage: 0,
                kind: "NgModule",
                type: moduleType
            });
            const compilerInjector = core_Injector.create({
                providers: compilerProviders
            });
            const resourceLoader = compilerInjector.get(compiler.ResourceLoader);
            return resolveComponentResources(url => Promise.resolve(resourceLoader.get(url))).then(() => moduleFactory);
        }
        function publishDefaultGlobalUtils() {}
        function isBoundToModule(cf) {
            return cf.isBoundToModule;
        }
        class NgProbeToken {
            constructor(name, token) {
                this.name = name;
                this.token = token;
            }
        }
        function createPlatform(injector) {
            if (_platformInjector && !_platformInjector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {
                throw new RuntimeError(400, false);
            }
            publishDefaultGlobalUtils();
            _platformInjector = injector;
            const platform = injector.get(PlatformRef);
            runPlatformInitializers(injector);
            return platform;
        }
        function createOrReusePlatformInjector(providers = []) {
            if (_platformInjector) {
                return _platformInjector;
            }
            const injector = createPlatformInjector(providers);
            _platformInjector = injector;
            publishDefaultGlobalUtils();
            runPlatformInitializers(injector);
            return injector;
        }
        function runPlatformInitializers(injector) {
            const inits = injector.get(PLATFORM_INITIALIZER, null);
            if (inits) {
                inits.forEach(init => init());
            }
        }
        function internalCreateApplication(config2) {
            const {rootComponent, appProviders, platformProviders} = config2;
            if (NG_DEV_MODE && rootComponent !== void 0) {
                assertStandaloneComponentType(rootComponent);
            }
            const platformInjector = createOrReusePlatformInjector(platformProviders);
            const ngZone = getNgZone("zone.js", getNgZoneOptions());
            return ngZone.run(() => {
                const allAppProviders = [ {
                    provide: core_NgZone,
                    useValue: ngZone
                }, ...appProviders || [] ];
                const envInjector = createEnvironmentInjector(allAppProviders, platformInjector, "Environment Injector");
                const exceptionHandler = envInjector.get(ErrorHandler, null);
                if (NG_DEV_MODE && !exceptionHandler) {
                    throw new RuntimeError(402, "No `ErrorHandler` found in the Dependency Injection tree.");
                }
                let onErrorSubscription;
                ngZone.runOutsideAngular(() => {
                    onErrorSubscription = ngZone.onError.subscribe({
                        next: error => {
                            exceptionHandler.handleError(error);
                        }
                    });
                });
                const destroyListener = () => envInjector.destroy();
                const onPlatformDestroyListeners = platformInjector.get(PLATFORM_DESTROY_LISTENERS);
                onPlatformDestroyListeners.add(destroyListener);
                envInjector.onDestroy(() => {
                    onErrorSubscription.unsubscribe();
                    onPlatformDestroyListeners.delete(destroyListener);
                });
                return _callAndReportToErrorHandler(exceptionHandler, ngZone, () => {
                    const initStatus = envInjector.get(ApplicationInitStatus);
                    initStatus.runInitializers();
                    return initStatus.donePromise.then(() => {
                        const localeId = envInjector.get(LOCALE_ID, DEFAULT_LOCALE_ID);
                        setLocaleId(localeId || DEFAULT_LOCALE_ID);
                        const appRef = envInjector.get(core_ApplicationRef);
                        if (rootComponent !== void 0) {
                            appRef.bootstrap(rootComponent);
                        }
                        return appRef;
                    });
                });
            });
        }
        function createPlatformFactory(parentPlatformFactory, name, providers = []) {
            const desc = `Platform: ${name}`;
            const marker = new InjectionToken(desc);
            return (extraProviders = []) => {
                let platform = getPlatform();
                if (!platform || platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {
                    const platformProviders = [ ...providers, ...extraProviders, {
                        provide: marker,
                        useValue: true
                    } ];
                    if (parentPlatformFactory) {
                        parentPlatformFactory(platformProviders);
                    } else {
                        createPlatform(createPlatformInjector(platformProviders, desc));
                    }
                }
                return assertPlatform(marker);
            };
        }
        function assertPlatform(requiredToken) {
            const platform = getPlatform();
            if (!platform) {
                throw new RuntimeError(401, false);
            }
            if (false) {
                throw new RuntimeError(400, "A platform with a different configuration has been created. Please destroy it first.");
            }
            return platform;
        }
        function createPlatformInjector(providers = [], name) {
            return core_Injector.create({
                name,
                providers: [ {
                    provide: INJECTOR_SCOPE,
                    useValue: "platform"
                }, {
                    provide: PLATFORM_DESTROY_LISTENERS,
                    useValue: new Set([ () => _platformInjector = null ])
                }, ...providers ]
            });
        }
        function destroyPlatform() {
            getPlatform()?.destroy();
        }
        function getPlatform() {
            return _platformInjector?.get(PlatformRef) ?? null;
        }
        let PlatformRef = (() => {
            class PlatformRef2 {
                constructor(_injector) {
                    this._injector = _injector;
                    this._modules = [];
                    this._destroyListeners = [];
                    this._destroyed = false;
                }
                bootstrapModuleFactory(moduleFactory, options) {
                    const ngZone = getNgZone(options?.ngZone, getNgZoneOptions(options));
                    const providers = [ {
                        provide: core_NgZone,
                        useValue: ngZone
                    } ];
                    return ngZone.run(() => {
                        const ngZoneInjector = core_Injector.create({
                            providers,
                            parent: this.injector,
                            name: moduleFactory.moduleType.name
                        });
                        const moduleRef = moduleFactory.create(ngZoneInjector);
                        const exceptionHandler = moduleRef.injector.get(ErrorHandler, null);
                        if (!exceptionHandler) {
                            throw new RuntimeError(402, false);
                        }
                        ngZone.runOutsideAngular(() => {
                            const subscription = ngZone.onError.subscribe({
                                next: error => {
                                    exceptionHandler.handleError(error);
                                }
                            });
                            moduleRef.onDestroy(() => {
                                remove(this._modules, moduleRef);
                                subscription.unsubscribe();
                            });
                        });
                        return _callAndReportToErrorHandler(exceptionHandler, ngZone, () => {
                            const initStatus = moduleRef.injector.get(ApplicationInitStatus);
                            initStatus.runInitializers();
                            return initStatus.donePromise.then(() => {
                                const localeId = moduleRef.injector.get(LOCALE_ID, DEFAULT_LOCALE_ID);
                                setLocaleId(localeId || DEFAULT_LOCALE_ID);
                                this._moduleDoBootstrap(moduleRef);
                                return moduleRef;
                            });
                        });
                    });
                }
                bootstrapModule(moduleType, compilerOptions = []) {
                    const options = optionsReducer({}, compilerOptions);
                    return compileNgModuleFactory(this.injector, options, moduleType).then(moduleFactory => this.bootstrapModuleFactory(moduleFactory, options));
                }
                _moduleDoBootstrap(moduleRef) {
                    const appRef = moduleRef.injector.get(core_ApplicationRef);
                    if (moduleRef._bootstrapComponents.length > 0) {
                        moduleRef._bootstrapComponents.forEach(f => appRef.bootstrap(f));
                    } else if (moduleRef.instance.ngDoBootstrap) {
                        moduleRef.instance.ngDoBootstrap(appRef);
                    } else {
                        throw new RuntimeError(403, false);
                    }
                    this._modules.push(moduleRef);
                }
                onDestroy(callback) {
                    this._destroyListeners.push(callback);
                }
                get injector() {
                    return this._injector;
                }
                destroy() {
                    if (this._destroyed) {
                        throw new RuntimeError(404, false);
                    }
                    this._modules.slice().forEach(module => module.destroy());
                    this._destroyListeners.forEach(listener => listener());
                    const destroyListeners = this._injector.get(PLATFORM_DESTROY_LISTENERS, null);
                    if (destroyListeners) {
                        destroyListeners.forEach(listener => listener());
                        destroyListeners.clear();
                    }
                    this._destroyed = true;
                }
                get destroyed() {
                    return this._destroyed;
                }
            }
            PlatformRef2.fac = function PlatformRef_Factory(t) {
                return new (t || PlatformRef2)(core_inject(core_Injector));
            };
            PlatformRef2.prov = defineInjectable({
                token: PlatformRef2,
                factory: PlatformRef2.fac,
                providedIn: "platform"
            });
            return PlatformRef2;
        })();
        (function() {})();
        function getNgZoneOptions(options) {
            return {
                enableLongStackTrace: false ? false : false,
                shouldCoalesceEventChangeDetection: !!(options && options.ngZoneEventCoalescing) || false,
                shouldCoalesceRunChangeDetection: !!(options && options.ngZoneRunCoalescing) || false
            };
        }
        function getNgZone(ngZoneToUse, options) {
            let ngZone;
            if (ngZoneToUse === "noop") {
                ngZone = new NoopNgZone;
            } else {
                ngZone = (ngZoneToUse === "zone.js" ? void 0 : ngZoneToUse) || new core_NgZone(options);
            }
            return ngZone;
        }
        function _callAndReportToErrorHandler(errorHandler2, ngZone, callback) {
            try {
                const result = callback();
                if (core_isPromise(result)) {
                    return result.catch(e => {
                        ngZone.runOutsideAngular(() => errorHandler2.handleError(e));
                        throw e;
                    });
                }
                return result;
            } catch (e) {
                ngZone.runOutsideAngular(() => errorHandler2.handleError(e));
                throw e;
            }
        }
        function optionsReducer(dst, objs) {
            if (Array.isArray(objs)) {
                dst = objs.reduce(optionsReducer, dst);
            } else {
                dst = {
                    ...dst,
                    ...objs
                };
            }
            return dst;
        }
        let core_ApplicationRef = (() => {
            class ApplicationRef2 {
                constructor(_zone, _injector, _exceptionHandler) {
                    this._zone = _zone;
                    this._injector = _injector;
                    this._exceptionHandler = _exceptionHandler;
                    this._bootstrapListeners = [];
                    this._views = [];
                    this._runningTick = false;
                    this._stable = true;
                    this._destroyed = false;
                    this._destroyListeners = [];
                    this.componentTypes = [];
                    this.components = [];
                    this._onMicrotaskEmptySubscription = this._zone.onMicrotaskEmpty.subscribe({
                        next: () => {
                            this._zone.run(() => {
                                this.tick();
                            });
                        }
                    });
                    const isCurrentlyStable = new Observable_Observable(observer => {
                        this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks;
                        this._zone.runOutsideAngular(() => {
                            observer.next(this._stable);
                            observer.complete();
                        });
                    });
                    const isStable = new Observable_Observable(observer => {
                        let stableSub;
                        this._zone.runOutsideAngular(() => {
                            stableSub = this._zone.onStable.subscribe(() => {
                                core_NgZone.assertNotInAngularZone();
                                scheduleMicroTask(() => {
                                    if (!this._stable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks) {
                                        this._stable = true;
                                        observer.next(true);
                                    }
                                });
                            });
                        });
                        const unstableSub = this._zone.onUnstable.subscribe(() => {
                            core_NgZone.assertInAngularZone();
                            if (this._stable) {
                                this._stable = false;
                                this._zone.runOutsideAngular(() => {
                                    observer.next(false);
                                });
                            }
                        });
                        return () => {
                            stableSub.unsubscribe();
                            unstableSub.unsubscribe();
                        };
                    });
                    this.isStable = merge(isCurrentlyStable, isStable.pipe(share()));
                }
                get destroyed() {
                    return this._destroyed;
                }
                get injector() {
                    return this._injector;
                }
                bootstrap(componentOrFactory, rootSelectorOrNode) {
                    NG_DEV_MODE && this.warnIfDestroyed();
                    const isComponentFactory = componentOrFactory instanceof ComponentFactory$1;
                    const initStatus = this._injector.get(ApplicationInitStatus);
                    if (!initStatus.done) {
                        const standalone = !isComponentFactory && isStandalone(componentOrFactory);
                        const errorMessage = "Cannot bootstrap as there are still asynchronous initializers running." + (standalone ? "" : " Bootstrap components in the `ngDoBootstrap` method of the root module.");
                        throw new RuntimeError(405, NG_DEV_MODE && errorMessage);
                    }
                    let componentFactory;
                    if (isComponentFactory) {
                        componentFactory = componentOrFactory;
                    } else {
                        const resolver = this._injector.get(ComponentFactoryResolver$1);
                        componentFactory = resolver.resolveComponentFactory(componentOrFactory);
                    }
                    this.componentTypes.push(componentFactory.componentType);
                    const ngModule = isBoundToModule(componentFactory) ? void 0 : this._injector.get(NgModuleRef$1);
                    const selectorOrNode = rootSelectorOrNode || componentFactory.selector;
                    const compRef = componentFactory.create(core_Injector.NULL, [], selectorOrNode, ngModule);
                    const nativeElement = compRef.location.nativeElement;
                    const testability = compRef.injector.get(TESTABILITY, null);
                    testability?.registerApplication(nativeElement);
                    compRef.onDestroy(() => {
                        this.detachView(compRef.hostView);
                        remove(this.components, compRef);
                        testability?.unregisterApplication(nativeElement);
                    });
                    this._loadComponent(compRef);
                    if (false) {
                        const _console = this._injector.get(Console);
                        _console.log(`Angular is running in development mode. Call enableProdMode() to enable production mode.`);
                    }
                    return compRef;
                }
                tick() {
                    NG_DEV_MODE && this.warnIfDestroyed();
                    if (this._runningTick) {
                        throw new RuntimeError(101, false);
                    }
                    try {
                        this._runningTick = true;
                        for (let view of this._views) {
                            view.detectChanges();
                        }
                        if (false) {
                            for (let view of this._views) {
                                view.checkNoChanges();
                            }
                        }
                    } catch (e) {
                        this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(e));
                    } finally {
                        this._runningTick = false;
                    }
                }
                attachView(viewRef) {
                    NG_DEV_MODE && this.warnIfDestroyed();
                    const view = viewRef;
                    this._views.push(view);
                    view.attachToAppRef(this);
                }
                detachView(viewRef) {
                    NG_DEV_MODE && this.warnIfDestroyed();
                    const view = viewRef;
                    remove(this._views, view);
                    view.detachFromAppRef();
                }
                _loadComponent(componentRef) {
                    this.attachView(componentRef.hostView);
                    this.tick();
                    this.components.push(componentRef);
                    const listeners = this._injector.get(core_APP_BOOTSTRAP_LISTENER, []).concat(this._bootstrapListeners);
                    listeners.forEach(listener => listener(componentRef));
                }
                ngOnDestroy() {
                    if (this._destroyed) {
                        return;
                    }
                    try {
                        this._destroyListeners.forEach(listener => listener());
                        this._views.slice().forEach(view => view.destroy());
                        this._onMicrotaskEmptySubscription.unsubscribe();
                    } finally {
                        this._destroyed = true;
                        this._views = [];
                        this._bootstrapListeners = [];
                        this._destroyListeners = [];
                    }
                }
                onDestroy(callback) {
                    NG_DEV_MODE && this.warnIfDestroyed();
                    this._destroyListeners.push(callback);
                    return () => remove(this._destroyListeners, callback);
                }
                destroy() {
                    if (this._destroyed) {
                        throw new RuntimeError(406, false);
                    }
                    const injector = this._injector;
                    if (injector.destroy && !injector.destroyed) {
                        injector.destroy();
                    }
                }
                get viewCount() {
                    return this._views.length;
                }
                warnIfDestroyed() {
                    if (NG_DEV_MODE && this._destroyed) {
                        console.warn(formatRuntimeError(406, "This instance of the `ApplicationRef` has already been destroyed."));
                    }
                }
            }
            ApplicationRef2.fac = function ApplicationRef_Factory(t) {
                return new (t || ApplicationRef2)(core_inject(core_NgZone), core_inject(EnvironmentInjector), core_inject(ErrorHandler));
            };
            ApplicationRef2.prov = defineInjectable({
                token: ApplicationRef2,
                factory: ApplicationRef2.fac,
                providedIn: "root"
            });
            return ApplicationRef2;
        })();
        (function() {})();
        function remove(list, el) {
            const index = list.indexOf(el);
            if (index > -1) {
                list.splice(index, 1);
            }
        }
        function _lastDefined(args) {
            for (let i = args.length - 1; i >= 0; i--) {
                if (args[i] !== void 0) {
                    return args[i];
                }
            }
            return void 0;
        }
        function _mergeArrays(parts) {
            const result = [];
            parts.forEach(part => part && result.push(...part));
            return result;
        }
        let _devMode = true;
        let _runModeLocked = false;
        function isDevMode() {
            _runModeLocked = true;
            return _devMode;
        }
        function enableProdMode() {
            if (_runModeLocked) {
                throw new Error("Cannot enable prod mode after platform setup.");
            }
            if (false) {
                _global["ngDevMode"] = false;
            }
            _devMode = false;
        }
        function getModuleFactory(id) {
            const type = getRegisteredNgModuleType(id);
            if (!type) {
                throw noModuleError(id);
            }
            return new NgModuleFactory(type);
        }
        function getNgModuleById(id) {
            const type = getRegisteredNgModuleType(id);
            if (!type) {
                throw noModuleError(id);
            }
            return type;
        }
        function noModuleError(id) {
            return new Error(`No module with ID ${id} loaded`);
        }
        let ChangeDetectorRef = (() => {
            class ChangeDetectorRef2 {}
            ChangeDetectorRef2.__NG_ELEMENT_ID__ = injectChangeDetectorRef;
            return ChangeDetectorRef2;
        })();
        function injectChangeDetectorRef(flags) {
            return createViewRef(getCurrentTNode(), getLView(), (flags & 16) === 16);
        }
        function createViewRef(tNode, lView, isPipe) {
            if (isComponentHost(tNode) && !isPipe) {
                const componentView = getComponentLViewByIndex(tNode.index, lView);
                return new ViewRef$1(componentView, componentView);
            } else if (tNode.type & (3 | 12 | 32)) {
                const hostComponentView = lView[DECLARATION_COMPONENT_VIEW];
                return new ViewRef$1(hostComponentView, lView);
            }
            return null;
        }
        class ViewRef extends(null){}
        class EmbeddedViewRef extends(null){}
        var ng_module_factory_loader_impl = {};
        class DebugEventListener {
            constructor(name, callback) {
                this.name = name;
                this.callback = callback;
            }
        }
        function asNativeElements(debugEls) {
            return debugEls.map(el => el.nativeElement);
        }
        class DebugNode {
            constructor(nativeNode) {
                this.nativeNode = nativeNode;
            }
            get parent() {
                const parent = this.nativeNode.parentNode;
                return parent ? new DebugElement(parent) : null;
            }
            get injector() {
                return getInjector(this.nativeNode);
            }
            get componentInstance() {
                const nativeElement = this.nativeNode;
                return nativeElement && (getComponent(nativeElement) || getOwningComponent(nativeElement));
            }
            get context() {
                return getComponent(this.nativeNode) || getContext(this.nativeNode);
            }
            get listeners() {
                return getListeners(this.nativeNode).filter(listener => listener.type === "dom");
            }
            get references() {
                return getLocalRefs(this.nativeNode);
            }
            get providerTokens() {
                return getInjectionTokens(this.nativeNode);
            }
        }
        class DebugElement extends(null){
            constructor(nativeNode) {
                super(nativeNode);
            }
            get nativeElement() {
                return this.nativeNode.nodeType == Node.ELEMENT_NODE ? this.nativeNode : null;
            }
            get name() {
                const context2 = getLContext(this.nativeNode);
                const lView = context2 ? context2.lView : null;
                if (lView !== null) {
                    const tData = lView[TVIEW].data;
                    const tNode = tData[context2.nodeIndex];
                    return tNode.value;
                } else {
                    return this.nativeNode.nodeName;
                }
            }
            get properties() {
                const context2 = getLContext(this.nativeNode);
                const lView = context2 ? context2.lView : null;
                if (lView === null) {
                    return {};
                }
                const tData = lView[TVIEW].data;
                const tNode = tData[context2.nodeIndex];
                const properties = {};
                copyDomProperties(this.nativeElement, properties);
                collectPropertyBindings(properties, tNode, lView, tData);
                return properties;
            }
            get attributes() {
                const attributes = {};
                const element = this.nativeElement;
                if (!element) {
                    return attributes;
                }
                const context2 = getLContext(element);
                const lView = context2 ? context2.lView : null;
                if (lView === null) {
                    return {};
                }
                const tNodeAttrs = lView[TVIEW].data[context2.nodeIndex].attrs;
                const lowercaseTNodeAttrs = [];
                if (tNodeAttrs) {
                    let i = 0;
                    while (i < tNodeAttrs.length) {
                        const attrName = tNodeAttrs[i];
                        if (typeof attrName !== "string") {
                            break;
                        }
                        const attrValue = tNodeAttrs[i + 1];
                        attributes[attrName] = attrValue;
                        lowercaseTNodeAttrs.push(attrName.toLowerCase());
                        i += 2;
                    }
                }
                const eAttrs = element.attributes;
                for (let i = 0; i < eAttrs.length; i++) {
                    const attr = eAttrs[i];
                    const lowercaseName = attr.name.toLowerCase();
                    if (lowercaseTNodeAttrs.indexOf(lowercaseName) === -1) {
                        attributes[lowercaseName] = attr.value;
                    }
                }
                return attributes;
            }
            get styles() {
                if (this.nativeElement && this.nativeElement.style) {
                    return this.nativeElement.style;
                }
                return {};
            }
            get classes() {
                const result = {};
                const element = this.nativeElement;
                const className = element.className;
                const classes = typeof className !== "string" ? className.baseVal.split(" ") : className.split(" ");
                classes.forEach(value => result[value] = true);
                return result;
            }
            get childNodes() {
                const childNodes = this.nativeNode.childNodes;
                const children = [];
                for (let i = 0; i < childNodes.length; i++) {
                    const element = childNodes[i];
                    children.push(getDebugNode(element));
                }
                return children;
            }
            get children() {
                const nativeElement = this.nativeElement;
                if (!nativeElement) {
                    return [];
                }
                const childNodes = nativeElement.children;
                const children = [];
                for (let i = 0; i < childNodes.length; i++) {
                    const element = childNodes[i];
                    children.push(getDebugNode(element));
                }
                return children;
            }
            query(predicate) {
                const results = this.queryAll(predicate);
                return results[0] || null;
            }
            queryAll(predicate) {
                const matches = [];
                _queryAll(this, predicate, matches, true);
                return matches;
            }
            queryAllNodes(predicate) {
                const matches = [];
                _queryAll(this, predicate, matches, false);
                return matches;
            }
            triggerEventHandler(eventName, eventObj) {
                const node = this.nativeNode;
                const invokedListeners = [];
                this.listeners.forEach(listener => {
                    if (listener.name === eventName) {
                        const callback = listener.callback;
                        callback.call(node, eventObj);
                        invokedListeners.push(callback);
                    }
                });
                if (typeof node.eventListeners === "function") {
                    node.eventListeners(eventName).forEach(listener => {
                        if (listener.toString().indexOf("__ngUnwrap__") !== -1) {
                            const unwrappedListener = listener("__ngUnwrap__");
                            return invokedListeners.indexOf(unwrappedListener) === -1 && unwrappedListener.call(node, eventObj);
                        }
                    });
                }
            }
        }
        function copyDomProperties(element, properties) {
            if (element) {
                let obj = Object.getPrototypeOf(element);
                const NodePrototype = Node.prototype;
                while (obj !== null && obj !== NodePrototype) {
                    const descriptors = Object.getOwnPropertyDescriptors(obj);
                    for (let key in descriptors) {
                        if (!key.startsWith("__") && !key.startsWith("on")) {
                            const value = element[key];
                            if (isPrimitiveValue(value)) {
                                properties[key] = value;
                            }
                        }
                    }
                    obj = Object.getPrototypeOf(obj);
                }
            }
        }
        function isPrimitiveValue(value) {
            return typeof value === "string" || typeof value === "boolean" || typeof value === "number" || value === null;
        }
        function _queryAll(parentElement, predicate, matches, elementsOnly) {
            const context2 = getLContext(parentElement.nativeNode);
            const lView = context2 ? context2.lView : null;
            if (lView !== null) {
                const parentTNode = lView[TVIEW].data[context2.nodeIndex];
                _queryNodeChildren(parentTNode, lView, predicate, matches, elementsOnly, parentElement.nativeNode);
            } else {
                _queryNativeNodeDescendants(parentElement.nativeNode, predicate, matches, elementsOnly);
            }
        }
        function _queryNodeChildren(tNode, lView, predicate, matches, elementsOnly, rootNativeNode) {
            const nativeNode = getNativeByTNodeOrNull(tNode, lView);
            if (tNode.type & (3 | 8)) {
                _addQueryMatch(nativeNode, predicate, matches, elementsOnly, rootNativeNode);
                if (isComponentHost(tNode)) {
                    const componentView = getComponentLViewByIndex(tNode.index, lView);
                    if (componentView && componentView[TVIEW].firstChild) {
                        _queryNodeChildren(componentView[TVIEW].firstChild, componentView, predicate, matches, elementsOnly, rootNativeNode);
                    }
                } else {
                    if (tNode.child) {
                        _queryNodeChildren(tNode.child, lView, predicate, matches, elementsOnly, rootNativeNode);
                    }
                    nativeNode && _queryNativeNodeDescendants(nativeNode, predicate, matches, elementsOnly);
                }
                const nodeOrContainer = lView[tNode.index];
                if (isLContainer(nodeOrContainer)) {
                    _queryNodeChildrenInContainer(nodeOrContainer, predicate, matches, elementsOnly, rootNativeNode);
                }
            } else if (tNode.type & 4) {
                const lContainer = lView[tNode.index];
                _addQueryMatch(lContainer[NATIVE], predicate, matches, elementsOnly, rootNativeNode);
                _queryNodeChildrenInContainer(lContainer, predicate, matches, elementsOnly, rootNativeNode);
            } else if (tNode.type & 16) {
                const componentView = lView[DECLARATION_COMPONENT_VIEW];
                const componentHost = componentView[T_HOST];
                const head = componentHost.projection[tNode.projection];
                if (Array.isArray(head)) {
                    for (let nativeNode2 of head) {
                        _addQueryMatch(nativeNode2, predicate, matches, elementsOnly, rootNativeNode);
                    }
                } else if (head) {
                    const nextLView = componentView[PARENT];
                    const nextTNode = nextLView[TVIEW].data[head.index];
                    _queryNodeChildren(nextTNode, nextLView, predicate, matches, elementsOnly, rootNativeNode);
                }
            } else if (tNode.child) {
                _queryNodeChildren(tNode.child, lView, predicate, matches, elementsOnly, rootNativeNode);
            }
            if (rootNativeNode !== nativeNode) {
                const nextTNode = tNode.flags & 4 ? tNode.projectionNext : tNode.next;
                if (nextTNode) {
                    _queryNodeChildren(nextTNode, lView, predicate, matches, elementsOnly, rootNativeNode);
                }
            }
        }
        function _queryNodeChildrenInContainer(lContainer, predicate, matches, elementsOnly, rootNativeNode) {
            for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
                const childView = lContainer[i];
                const firstChild = childView[TVIEW].firstChild;
                if (firstChild) {
                    _queryNodeChildren(firstChild, childView, predicate, matches, elementsOnly, rootNativeNode);
                }
            }
        }
        function _addQueryMatch(nativeNode, predicate, matches, elementsOnly, rootNativeNode) {
            if (rootNativeNode !== nativeNode) {
                const debugNode = getDebugNode(nativeNode);
                if (!debugNode) {
                    return;
                }
                if (elementsOnly && debugNode instanceof DebugElement && predicate(debugNode) && matches.indexOf(debugNode) === -1) {
                    matches.push(debugNode);
                } else if (!elementsOnly && predicate(debugNode) && matches.indexOf(debugNode) === -1) {
                    matches.push(debugNode);
                }
            }
        }
        function _queryNativeNodeDescendants(parentNode, predicate, matches, elementsOnly) {
            const nodes = parentNode.childNodes;
            const length = nodes.length;
            for (let i = 0; i < length; i++) {
                const node = nodes[i];
                const debugNode = getDebugNode(node);
                if (debugNode) {
                    if (elementsOnly && debugNode instanceof DebugElement && predicate(debugNode) && matches.indexOf(debugNode) === -1) {
                        matches.push(debugNode);
                    } else if (!elementsOnly && predicate(debugNode) && matches.indexOf(debugNode) === -1) {
                        matches.push(debugNode);
                    }
                    _queryNativeNodeDescendants(node, predicate, matches, elementsOnly);
                }
            }
        }
        function collectPropertyBindings(properties, tNode, lView, tData) {
            let bindingIndexes = tNode.propertyBindings;
            if (bindingIndexes !== null) {
                for (let i = 0; i < bindingIndexes.length; i++) {
                    const bindingIndex = bindingIndexes[i];
                    const propMetadata = tData[bindingIndex];
                    const metadataParts = propMetadata.split(INTERPOLATION_DELIMITER);
                    const propertyName = metadataParts[0];
                    if (metadataParts.length > 1) {
                        let value = metadataParts[1];
                        for (let j = 1; j < metadataParts.length - 1; j++) {
                            value += renderStringify(lView[bindingIndex + j - 1]) + metadataParts[j + 1];
                        }
                        properties[propertyName] = value;
                    } else {
                        properties[propertyName] = lView[bindingIndex];
                    }
                }
            }
        }
        const _nativeNodeToDebugNode = new Map;
        const NG_DEBUG_PROPERTY = "__ng_debug__";
        function getDebugNode(nativeNode) {
            if (nativeNode instanceof Node) {
                if (!nativeNode.hasOwnProperty(NG_DEBUG_PROPERTY)) {
                    nativeNode[NG_DEBUG_PROPERTY] = nativeNode.nodeType == Node.ELEMENT_NODE ? new DebugElement(nativeNode) : new DebugNode(nativeNode);
                }
                return nativeNode[NG_DEBUG_PROPERTY];
            }
            return null;
        }
        function getDebugNodeR2(_nativeNode) {
            return null;
        }
        function getAllDebugNodes() {
            return Array.from(_nativeNodeToDebugNode.values());
        }
        function indexDebugNode(node) {
            _nativeNodeToDebugNode.set(node.nativeNode, node);
        }
        function removeDebugNodeFromIndex(node) {
            _nativeNodeToDebugNode.delete(node.nativeNode);
        }
        class DefaultIterableDifferFactory {
            constructor() {}
            supports(obj) {
                return isListLikeIterable(obj);
            }
            create(trackByFn) {
                return new DefaultIterableDiffer(trackByFn);
            }
        }
        const trackByIdentity = (index, item) => item;
        class DefaultIterableDiffer {
            constructor(trackByFn) {
                this.length = 0;
                this._linkedRecords = null;
                this._unlinkedRecords = null;
                this._previousItHead = null;
                this._itHead = null;
                this._itTail = null;
                this._additionsHead = null;
                this._additionsTail = null;
                this._movesHead = null;
                this._movesTail = null;
                this._removalsHead = null;
                this._removalsTail = null;
                this._identityChangesHead = null;
                this._identityChangesTail = null;
                this._trackByFn = trackByFn || trackByIdentity;
            }
            forEachItem(fn) {
                let record;
                for (record = this._itHead; record !== null; record = record._next) {
                    fn(record);
                }
            }
            forEachOperation(fn) {
                let nextIt = this._itHead;
                let nextRemove = this._removalsHead;
                let addRemoveOffset = 0;
                let moveOffsets = null;
                while (nextIt || nextRemove) {
                    const record = !nextRemove || nextIt && nextIt.currentIndex < getPreviousIndex(nextRemove, addRemoveOffset, moveOffsets) ? nextIt : nextRemove;
                    const adjPreviousIndex = getPreviousIndex(record, addRemoveOffset, moveOffsets);
                    const currentIndex = record.currentIndex;
                    if (record === nextRemove) {
                        addRemoveOffset--;
                        nextRemove = nextRemove._nextRemoved;
                    } else {
                        nextIt = nextIt._next;
                        if (record.previousIndex == null) {
                            addRemoveOffset++;
                        } else {
                            if (!moveOffsets) {
                                moveOffsets = [];
                            }
                            const localMovePreviousIndex = adjPreviousIndex - addRemoveOffset;
                            const localCurrentIndex = currentIndex - addRemoveOffset;
                            if (localMovePreviousIndex != localCurrentIndex) {
                                for (let i = 0; i < localMovePreviousIndex; i++) {
                                    const offset = i < moveOffsets.length ? moveOffsets[i] : moveOffsets[i] = 0;
                                    const index = offset + i;
                                    if (localCurrentIndex <= index && index < localMovePreviousIndex) {
                                        moveOffsets[i] = offset + 1;
                                    }
                                }
                                const previousIndex = record.previousIndex;
                                moveOffsets[previousIndex] = localCurrentIndex - localMovePreviousIndex;
                            }
                        }
                    }
                    if (adjPreviousIndex !== currentIndex) {
                        fn(record, adjPreviousIndex, currentIndex);
                    }
                }
            }
            forEachPreviousItem(fn) {
                let record;
                for (record = this._previousItHead; record !== null; record = record._nextPrevious) {
                    fn(record);
                }
            }
            forEachAddedItem(fn) {
                let record;
                for (record = this._additionsHead; record !== null; record = record._nextAdded) {
                    fn(record);
                }
            }
            forEachMovedItem(fn) {
                let record;
                for (record = this._movesHead; record !== null; record = record._nextMoved) {
                    fn(record);
                }
            }
            forEachRemovedItem(fn) {
                let record;
                for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
                    fn(record);
                }
            }
            forEachIdentityChange(fn) {
                let record;
                for (record = this._identityChangesHead; record !== null; record = record._nextIdentityChange) {
                    fn(record);
                }
            }
            diff(collection) {
                if (collection == null) {
                    collection = [];
                }
                if (!isListLikeIterable(collection)) {
                    throw new RuntimeError(900, false);
                }
                if (this.check(collection)) {
                    return this;
                } else {
                    return null;
                }
            }
            onDestroy() {}
            check(collection) {
                this._reset();
                let record = this._itHead;
                let mayBeDirty = false;
                let index;
                let item;
                let itemTrackBy;
                if (Array.isArray(collection)) {
                    this.length = collection.length;
                    for (let index2 = 0; index2 < this.length; index2++) {
                        item = collection[index2];
                        itemTrackBy = this._trackByFn(index2, item);
                        if (record === null || !Object.is(record.trackById, itemTrackBy)) {
                            record = this._mismatch(record, item, itemTrackBy, index2);
                            mayBeDirty = true;
                        } else {
                            if (mayBeDirty) {
                                record = this._verifyReinsertion(record, item, itemTrackBy, index2);
                            }
                            if (!Object.is(record.item, item)) {
                                this._addIdentityChange(record, item);
                            }
                        }
                        record = record._next;
                    }
                } else {
                    index = 0;
                    iterateListLike(collection, item2 => {
                        itemTrackBy = this._trackByFn(index, item2);
                        if (record === null || !Object.is(record.trackById, itemTrackBy)) {
                            record = this._mismatch(record, item2, itemTrackBy, index);
                            mayBeDirty = true;
                        } else {
                            if (mayBeDirty) {
                                record = this._verifyReinsertion(record, item2, itemTrackBy, index);
                            }
                            if (!Object.is(record.item, item2)) {
                                this._addIdentityChange(record, item2);
                            }
                        }
                        record = record._next;
                        index++;
                    });
                    this.length = index;
                }
                this._truncate(record);
                this.collection = collection;
                return this.isDirty;
            }
            get isDirty() {
                return this._additionsHead !== null || this._movesHead !== null || this._removalsHead !== null || this._identityChangesHead !== null;
            }
            _reset() {
                if (this.isDirty) {
                    let record;
                    for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {
                        record._nextPrevious = record._next;
                    }
                    for (record = this._additionsHead; record !== null; record = record._nextAdded) {
                        record.previousIndex = record.currentIndex;
                    }
                    this._additionsHead = this._additionsTail = null;
                    for (record = this._movesHead; record !== null; record = record._nextMoved) {
                        record.previousIndex = record.currentIndex;
                    }
                    this._movesHead = this._movesTail = null;
                    this._removalsHead = this._removalsTail = null;
                    this._identityChangesHead = this._identityChangesTail = null;
                }
            }
            _mismatch(record, item, itemTrackBy, index) {
                let previousRecord;
                if (record === null) {
                    previousRecord = this._itTail;
                } else {
                    previousRecord = record._prev;
                    this._remove(record);
                }
                record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);
                if (record !== null) {
                    if (!Object.is(record.item, item)) {
                        this._addIdentityChange(record, item);
                    }
                    this._reinsertAfter(record, previousRecord, index);
                } else {
                    record = this._linkedRecords === null ? null : this._linkedRecords.get(itemTrackBy, index);
                    if (record !== null) {
                        if (!Object.is(record.item, item)) {
                            this._addIdentityChange(record, item);
                        }
                        this._moveAfter(record, previousRecord, index);
                    } else {
                        record = this._addAfter(new IterableChangeRecord_(item, itemTrackBy), previousRecord, index);
                    }
                }
                return record;
            }
            _verifyReinsertion(record, item, itemTrackBy, index) {
                let reinsertRecord = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);
                if (reinsertRecord !== null) {
                    record = this._reinsertAfter(reinsertRecord, record._prev, index);
                } else if (record.currentIndex != index) {
                    record.currentIndex = index;
                    this._addToMoves(record, index);
                }
                return record;
            }
            _truncate(record) {
                while (record !== null) {
                    const nextRecord = record._next;
                    this._addToRemovals(this._unlink(record));
                    record = nextRecord;
                }
                if (this._unlinkedRecords !== null) {
                    this._unlinkedRecords.clear();
                }
                if (this._additionsTail !== null) {
                    this._additionsTail._nextAdded = null;
                }
                if (this._movesTail !== null) {
                    this._movesTail._nextMoved = null;
                }
                if (this._itTail !== null) {
                    this._itTail._next = null;
                }
                if (this._removalsTail !== null) {
                    this._removalsTail._nextRemoved = null;
                }
                if (this._identityChangesTail !== null) {
                    this._identityChangesTail._nextIdentityChange = null;
                }
            }
            _reinsertAfter(record, prevRecord, index) {
                if (this._unlinkedRecords !== null) {
                    this._unlinkedRecords.remove(record);
                }
                const prev = record._prevRemoved;
                const next = record._nextRemoved;
                if (prev === null) {
                    this._removalsHead = next;
                } else {
                    prev._nextRemoved = next;
                }
                if (next === null) {
                    this._removalsTail = prev;
                } else {
                    next._prevRemoved = prev;
                }
                this._insertAfter(record, prevRecord, index);
                this._addToMoves(record, index);
                return record;
            }
            _moveAfter(record, prevRecord, index) {
                this._unlink(record);
                this._insertAfter(record, prevRecord, index);
                this._addToMoves(record, index);
                return record;
            }
            _addAfter(record, prevRecord, index) {
                this._insertAfter(record, prevRecord, index);
                if (this._additionsTail === null) {
                    this._additionsTail = this._additionsHead = record;
                } else {
                    this._additionsTail = this._additionsTail._nextAdded = record;
                }
                return record;
            }
            _insertAfter(record, prevRecord, index) {
                const next = prevRecord === null ? this._itHead : prevRecord._next;
                record._next = next;
                record._prev = prevRecord;
                if (next === null) {
                    this._itTail = record;
                } else {
                    next._prev = record;
                }
                if (prevRecord === null) {
                    this._itHead = record;
                } else {
                    prevRecord._next = record;
                }
                if (this._linkedRecords === null) {
                    this._linkedRecords = new _DuplicateMap;
                }
                this._linkedRecords.put(record);
                record.currentIndex = index;
                return record;
            }
            _remove(record) {
                return this._addToRemovals(this._unlink(record));
            }
            _unlink(record) {
                if (this._linkedRecords !== null) {
                    this._linkedRecords.remove(record);
                }
                const prev = record._prev;
                const next = record._next;
                if (prev === null) {
                    this._itHead = next;
                } else {
                    prev._next = next;
                }
                if (next === null) {
                    this._itTail = prev;
                } else {
                    next._prev = prev;
                }
                return record;
            }
            _addToMoves(record, toIndex) {
                if (record.previousIndex === toIndex) {
                    return record;
                }
                if (this._movesTail === null) {
                    this._movesTail = this._movesHead = record;
                } else {
                    this._movesTail = this._movesTail._nextMoved = record;
                }
                return record;
            }
            _addToRemovals(record) {
                if (this._unlinkedRecords === null) {
                    this._unlinkedRecords = new _DuplicateMap;
                }
                this._unlinkedRecords.put(record);
                record.currentIndex = null;
                record._nextRemoved = null;
                if (this._removalsTail === null) {
                    this._removalsTail = this._removalsHead = record;
                    record._prevRemoved = null;
                } else {
                    record._prevRemoved = this._removalsTail;
                    this._removalsTail = this._removalsTail._nextRemoved = record;
                }
                return record;
            }
            _addIdentityChange(record, item) {
                record.item = item;
                if (this._identityChangesTail === null) {
                    this._identityChangesTail = this._identityChangesHead = record;
                } else {
                    this._identityChangesTail = this._identityChangesTail._nextIdentityChange = record;
                }
                return record;
            }
        }
        class IterableChangeRecord_ {
            constructor(item, trackById) {
                this.item = item;
                this.trackById = trackById;
                this.currentIndex = null;
                this.previousIndex = null;
                this._nextPrevious = null;
                this._prev = null;
                this._next = null;
                this._prevDup = null;
                this._nextDup = null;
                this._prevRemoved = null;
                this._nextRemoved = null;
                this._nextAdded = null;
                this._nextMoved = null;
                this._nextIdentityChange = null;
            }
        }
        class _DuplicateItemRecordList {
            constructor() {
                this._head = null;
                this._tail = null;
            }
            add(record) {
                if (this._head === null) {
                    this._head = this._tail = record;
                    record._nextDup = null;
                    record._prevDup = null;
                } else {
                    this._tail._nextDup = record;
                    record._prevDup = this._tail;
                    record._nextDup = null;
                    this._tail = record;
                }
            }
            get(trackById, atOrAfterIndex) {
                let record;
                for (record = this._head; record !== null; record = record._nextDup) {
                    if ((atOrAfterIndex === null || atOrAfterIndex <= record.currentIndex) && Object.is(record.trackById, trackById)) {
                        return record;
                    }
                }
                return null;
            }
            remove(record) {
                const prev = record._prevDup;
                const next = record._nextDup;
                if (prev === null) {
                    this._head = next;
                } else {
                    prev._nextDup = next;
                }
                if (next === null) {
                    this._tail = prev;
                } else {
                    next._prevDup = prev;
                }
                return this._head === null;
            }
        }
        class _DuplicateMap {
            constructor() {
                this.map = new Map;
            }
            put(record) {
                const key = record.trackById;
                let duplicates = this.map.get(key);
                if (!duplicates) {
                    duplicates = new _DuplicateItemRecordList;
                    this.map.set(key, duplicates);
                }
                duplicates.add(record);
            }
            get(trackById, atOrAfterIndex) {
                const key = trackById;
                const recordList = this.map.get(key);
                return recordList ? recordList.get(trackById, atOrAfterIndex) : null;
            }
            remove(record) {
                const key = record.trackById;
                const recordList = this.map.get(key);
                if (recordList.remove(record)) {
                    this.map.delete(key);
                }
                return record;
            }
            get isEmpty() {
                return this.map.size === 0;
            }
            clear() {
                this.map.clear();
            }
        }
        function getPreviousIndex(item, addRemoveOffset, moveOffsets) {
            const previousIndex = item.previousIndex;
            if (previousIndex === null) {
                return previousIndex;
            }
            let moveOffset = 0;
            if (moveOffsets && previousIndex < moveOffsets.length) {
                moveOffset = moveOffsets[previousIndex];
            }
            return previousIndex + addRemoveOffset + moveOffset;
        }
        class DefaultKeyValueDifferFactory {
            constructor() {}
            supports(obj) {
                return obj instanceof Map || isJsObject(obj);
            }
            create() {
                return new DefaultKeyValueDiffer;
            }
        }
        class DefaultKeyValueDiffer {
            constructor() {
                this._records = new Map;
                this._mapHead = null;
                this._appendAfter = null;
                this._previousMapHead = null;
                this._changesHead = null;
                this._changesTail = null;
                this._additionsHead = null;
                this._additionsTail = null;
                this._removalsHead = null;
                this._removalsTail = null;
            }
            get isDirty() {
                return this._additionsHead !== null || this._changesHead !== null || this._removalsHead !== null;
            }
            forEachItem(fn) {
                let record;
                for (record = this._mapHead; record !== null; record = record._next) {
                    fn(record);
                }
            }
            forEachPreviousItem(fn) {
                let record;
                for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
                    fn(record);
                }
            }
            forEachChangedItem(fn) {
                let record;
                for (record = this._changesHead; record !== null; record = record._nextChanged) {
                    fn(record);
                }
            }
            forEachAddedItem(fn) {
                let record;
                for (record = this._additionsHead; record !== null; record = record._nextAdded) {
                    fn(record);
                }
            }
            forEachRemovedItem(fn) {
                let record;
                for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
                    fn(record);
                }
            }
            diff(map2) {
                if (!map2) {
                    map2 = new Map;
                } else if (!(map2 instanceof Map || isJsObject(map2))) {
                    throw new RuntimeError(900, false);
                }
                return this.check(map2) ? this : null;
            }
            onDestroy() {}
            check(map2) {
                this._reset();
                let insertBefore = this._mapHead;
                this._appendAfter = null;
                this._forEach(map2, (value, key) => {
                    if (insertBefore && insertBefore.key === key) {
                        this._maybeAddToChanges(insertBefore, value);
                        this._appendAfter = insertBefore;
                        insertBefore = insertBefore._next;
                    } else {
                        const record = this._getOrCreateRecordForKey(key, value);
                        insertBefore = this._insertBeforeOrAppend(insertBefore, record);
                    }
                });
                if (insertBefore) {
                    if (insertBefore._prev) {
                        insertBefore._prev._next = null;
                    }
                    this._removalsHead = insertBefore;
                    for (let record = insertBefore; record !== null; record = record._nextRemoved) {
                        if (record === this._mapHead) {
                            this._mapHead = null;
                        }
                        this._records.delete(record.key);
                        record._nextRemoved = record._next;
                        record.previousValue = record.currentValue;
                        record.currentValue = null;
                        record._prev = null;
                        record._next = null;
                    }
                }
                if (this._changesTail) {
                    this._changesTail._nextChanged = null;
                }
                if (this._additionsTail) {
                    this._additionsTail._nextAdded = null;
                }
                return this.isDirty;
            }
            _insertBeforeOrAppend(before, record) {
                if (before) {
                    const prev = before._prev;
                    record._next = before;
                    record._prev = prev;
                    before._prev = record;
                    if (prev) {
                        prev._next = record;
                    }
                    if (before === this._mapHead) {
                        this._mapHead = record;
                    }
                    this._appendAfter = before;
                    return before;
                }
                if (this._appendAfter) {
                    this._appendAfter._next = record;
                    record._prev = this._appendAfter;
                } else {
                    this._mapHead = record;
                }
                this._appendAfter = record;
                return null;
            }
            _getOrCreateRecordForKey(key, value) {
                if (this._records.has(key)) {
                    const record2 = this._records.get(key);
                    this._maybeAddToChanges(record2, value);
                    const prev = record2._prev;
                    const next = record2._next;
                    if (prev) {
                        prev._next = next;
                    }
                    if (next) {
                        next._prev = prev;
                    }
                    record2._next = null;
                    record2._prev = null;
                    return record2;
                }
                const record = new KeyValueChangeRecord_(key);
                this._records.set(key, record);
                record.currentValue = value;
                this._addToAdditions(record);
                return record;
            }
            _reset() {
                if (this.isDirty) {
                    let record;
                    this._previousMapHead = this._mapHead;
                    for (record = this._previousMapHead; record !== null; record = record._next) {
                        record._nextPrevious = record._next;
                    }
                    for (record = this._changesHead; record !== null; record = record._nextChanged) {
                        record.previousValue = record.currentValue;
                    }
                    for (record = this._additionsHead; record != null; record = record._nextAdded) {
                        record.previousValue = record.currentValue;
                    }
                    this._changesHead = this._changesTail = null;
                    this._additionsHead = this._additionsTail = null;
                    this._removalsHead = null;
                }
            }
            _maybeAddToChanges(record, newValue) {
                if (!Object.is(newValue, record.currentValue)) {
                    record.previousValue = record.currentValue;
                    record.currentValue = newValue;
                    this._addToChanges(record);
                }
            }
            _addToAdditions(record) {
                if (this._additionsHead === null) {
                    this._additionsHead = this._additionsTail = record;
                } else {
                    this._additionsTail._nextAdded = record;
                    this._additionsTail = record;
                }
            }
            _addToChanges(record) {
                if (this._changesHead === null) {
                    this._changesHead = this._changesTail = record;
                } else {
                    this._changesTail._nextChanged = record;
                    this._changesTail = record;
                }
            }
            _forEach(obj, fn) {
                if (obj instanceof Map) {
                    obj.forEach(fn);
                } else {
                    Object.keys(obj).forEach(k => fn(obj[k], k));
                }
            }
        }
        class KeyValueChangeRecord_ {
            constructor(key) {
                this.key = key;
                this.previousValue = null;
                this.currentValue = null;
                this._nextPrevious = null;
                this._next = null;
                this._prev = null;
                this._nextAdded = null;
                this._nextRemoved = null;
                this._nextChanged = null;
            }
        }
        function defaultIterableDiffersFactory() {
            return new IterableDiffers([ new DefaultIterableDifferFactory ]);
        }
        let IterableDiffers = (() => {
            class IterableDiffers2 {
                constructor(factories) {
                    this.factories = factories;
                }
                static create(factories, parent) {
                    if (parent != null) {
                        const copied = parent.factories.slice();
                        factories = factories.concat(copied);
                    }
                    return new IterableDiffers2(factories);
                }
                static extend(factories) {
                    return {
                        provide: IterableDiffers2,
                        useFactory: parent => IterableDiffers2.create(factories, parent || defaultIterableDiffersFactory()),
                        deps: [ [ IterableDiffers2, new SkipSelf, new core_Optional ] ]
                    };
                }
                find(iterable) {
                    const factory = this.factories.find(f => f.supports(iterable));
                    if (factory != null) {
                        return factory;
                    } else {
                        throw new RuntimeError(901, false);
                    }
                }
            }
            IterableDiffers2.prov = defineInjectable({
                token: IterableDiffers2,
                providedIn: "root",
                factory: defaultIterableDiffersFactory
            });
            return IterableDiffers2;
        })();
        function getTypeNameForDebugging(type) {
            return type["name"] || typeof type;
        }
        function defaultKeyValueDiffersFactory() {
            return new KeyValueDiffers([ new DefaultKeyValueDifferFactory ]);
        }
        let KeyValueDiffers = (() => {
            class KeyValueDiffers2 {
                constructor(factories) {
                    this.factories = factories;
                }
                static create(factories, parent) {
                    if (parent) {
                        const copied = parent.factories.slice();
                        factories = factories.concat(copied);
                    }
                    return new KeyValueDiffers2(factories);
                }
                static extend(factories) {
                    return {
                        provide: KeyValueDiffers2,
                        useFactory: parent => KeyValueDiffers2.create(factories, parent || defaultKeyValueDiffersFactory()),
                        deps: [ [ KeyValueDiffers2, new SkipSelf, new core_Optional ] ]
                    };
                }
                find(kv) {
                    const factory = this.factories.find(f => f.supports(kv));
                    if (factory) {
                        return factory;
                    }
                    throw new RuntimeError(901, false);
                }
            }
            KeyValueDiffers2.prov = defineInjectable({
                token: KeyValueDiffers2,
                providedIn: "root",
                factory: defaultKeyValueDiffersFactory
            });
            return KeyValueDiffers2;
        })();
        const keyValDiff = [ new DefaultKeyValueDifferFactory ];
        const iterableDiff = [ new DefaultIterableDifferFactory ];
        const defaultIterableDiffers = new IterableDiffers(iterableDiff);
        const defaultKeyValueDiffers = new KeyValueDiffers(keyValDiff);
        const platformCore = createPlatformFactory(null, "core", []);
        let ApplicationModule = (() => {
            class ApplicationModule2 {
                constructor(appRef) {}
            }
            ApplicationModule2.fac = function ApplicationModule_Factory(t) {
                return new (t || ApplicationModule2)(core_inject(core_ApplicationRef));
            };
            ApplicationModule2.mod = defineNgModule({
                type: ApplicationModule2
            });
            ApplicationModule2.inj = defineInjector({});
            return ApplicationModule2;
        })();
        (function() {})();
        function coerceToBoolean(value) {
            return typeof value === "boolean" ? value : value != null && value !== "false";
        }
        const ivyEnabled = true;
        function ngDeclareDirective(decl) {
            const compiler = getCompilerFacade({
                usage: 1,
                kind: "directive",
                type: decl.type
            });
            return compiler.compileDirectiveDeclaration(angularCoreEnv, `ng:///${decl.type.name}/fac.js`, decl);
        }
        function ngDeclareClassMetadata(decl) {
            setClassMetadata(decl.type, decl.decorators, decl.ctorParameters ?? null, decl.propDecorators ?? null);
        }
        function ngDeclareComponent(decl) {
            const compiler = getCompilerFacade({
                usage: 1,
                kind: "component",
                type: decl.type
            });
            return compiler.compileComponentDeclaration(angularCoreEnv, `ng:///${decl.type.name}/cmp.js`, decl);
        }
        function ngDeclareFactory(decl) {
            const compiler = getCompilerFacade({
                usage: 1,
                kind: getFactoryKind(decl.target),
                type: decl.type
            });
            return compiler.compileFactoryDeclaration(angularCoreEnv, `ng:///${decl.type.name}/fac.js`, decl);
        }
        function getFactoryKind(target) {
            switch (target) {
              case FactoryTarget.Directive:
                return "directive";

              case FactoryTarget.Component:
                return "component";

              case FactoryTarget.Injectable:
                return "injectable";

              case FactoryTarget.Pipe:
                return "pipe";

              case FactoryTarget.NgModule:
                return "NgModule";
            }
        }
        function ngDeclareInjectable(decl) {
            const compiler = getCompilerFacade({
                usage: 1,
                kind: "injectable",
                type: decl.type
            });
            return compiler.compileInjectableDeclaration(angularCoreEnv, `ng:///${decl.type.name}/prov.js`, decl);
        }
        function ngDeclareInjector(decl) {
            const compiler = getCompilerFacade({
                usage: 1,
                kind: "NgModule",
                type: decl.type
            });
            return compiler.compileInjectorDeclaration(angularCoreEnv, `ng:///${decl.type.name}/inj.js`, decl);
        }
        function ngDeclareNgModule(decl) {
            const compiler = getCompilerFacade({
                usage: 1,
                kind: "NgModule",
                type: decl.type
            });
            return compiler.compileNgModuleDeclaration(angularCoreEnv, `ng:///${decl.type.name}/mod.js`, decl);
        }
        function ngDeclarePipe(decl) {
            const compiler = getCompilerFacade({
                usage: 1,
                kind: "pipe",
                type: decl.type
            });
            return compiler.compilePipeDeclaration(angularCoreEnv, `ng:///${decl.type.name}/pipe.js`, decl);
        }
        function createComponent(component, options) {
            const componentDef = getComponentDef(component);
            const elementInjector = options.elementInjector || getNullInjector();
            const factory = new ComponentFactory(componentDef);
            return factory.create(elementInjector, options.projectableNodes, options.hostElement, options.environmentInjector);
        }
        function reflectComponentType(component) {
            const componentDef = getComponentDef(component);
            if (!componentDef) {
                return null;
            }
            const factory = new ComponentFactory(componentDef);
            return {
                get selector() {
                    return factory.selector;
                },
                get type() {
                    return factory.componentType;
                },
                get inputs() {
                    return factory.inputs;
                },
                get outputs() {
                    return factory.outputs;
                },
                get ngContentSelectors() {
                    return factory.ngContentSelectors;
                },
                get isStandalone() {
                    return componentDef.standalone;
                }
            };
        }
        if (false) {
            _global.$localize = _global.$localize || function() {
                throw new Error("It looks like your application or one of its dependencies is using i18n.\nAngular 9 introduced a global `$localize()` function that needs to be loaded.\nPlease run `ng add @angular/localize` from the Angular CLI.\n(For non-CLI projects, add `import '@angular/localize/init';` to your `polyfills.ts` file.\nFor server-side rendering applications add the import to your `main.server.ts` file.)");
            };
        }
        let _DOM = null;
        function getDOM() {
            return _DOM;
        }
        function setDOM(adapter) {
            _DOM = adapter;
        }
        function setRootDomAdapter(adapter) {
            if (!_DOM) {
                _DOM = adapter;
            }
        }
        class DomAdapter {}
        const common_DOCUMENT = new InjectionToken("DocumentToken");
        let PlatformLocation = (() => {
            class PlatformLocation2 {
                historyGo(relativePosition) {
                    throw new Error("Not implemented");
                }
            }
            PlatformLocation2.fac = function PlatformLocation_Factory(t) {
                return new (t || PlatformLocation2);
            };
            PlatformLocation2.prov = defineInjectable({
                token: PlatformLocation2,
                factory: function() {
                    return useBrowserPlatformLocation();
                },
                providedIn: "platform"
            });
            return PlatformLocation2;
        })();
        (function() {})();
        function useBrowserPlatformLocation() {
            return core_inject(BrowserPlatformLocation);
        }
        const LOCATION_INITIALIZED = new InjectionToken("Location Initialized");
        let BrowserPlatformLocation = (() => {
            class BrowserPlatformLocation2 extends PlatformLocation {
                constructor(_doc) {
                    super();
                    this._doc = _doc;
                    this._init();
                }
                _init() {
                    this.location = window.location;
                    this._history = window.history;
                }
                getBaseHrefFromDOM() {
                    return getDOM().getBaseHref(this._doc);
                }
                onPopState(fn) {
                    const window2 = getDOM().getGlobalEventTarget(this._doc, "window");
                    window2.addEventListener("popstate", fn, false);
                    return () => window2.removeEventListener("popstate", fn);
                }
                onHashChange(fn) {
                    const window2 = getDOM().getGlobalEventTarget(this._doc, "window");
                    window2.addEventListener("hashchange", fn, false);
                    return () => window2.removeEventListener("hashchange", fn);
                }
                get href() {
                    return this.location.href;
                }
                get protocol() {
                    return this.location.protocol;
                }
                get hostname() {
                    return this.location.hostname;
                }
                get port() {
                    return this.location.port;
                }
                get pathname() {
                    return this.location.pathname;
                }
                get search() {
                    return this.location.search;
                }
                get hash() {
                    return this.location.hash;
                }
                set pathname(newPath) {
                    this.location.pathname = newPath;
                }
                pushState(state, title, url) {
                    if (supportsState()) {
                        this._history.pushState(state, title, url);
                    } else {
                        this.location.hash = url;
                    }
                }
                replaceState(state, title, url) {
                    if (supportsState()) {
                        this._history.replaceState(state, title, url);
                    } else {
                        this.location.hash = url;
                    }
                }
                forward() {
                    this._history.forward();
                }
                back() {
                    this._history.back();
                }
                historyGo(relativePosition = 0) {
                    this._history.go(relativePosition);
                }
                getState() {
                    return this._history.state;
                }
            }
            BrowserPlatformLocation2.fac = function BrowserPlatformLocation_Factory(t) {
                return new (t || BrowserPlatformLocation2)(core_inject(common_DOCUMENT));
            };
            BrowserPlatformLocation2.prov = defineInjectable({
                token: BrowserPlatformLocation2,
                factory: function() {
                    return createBrowserPlatformLocation();
                },
                providedIn: "platform"
            });
            return BrowserPlatformLocation2;
        })();
        (function() {})();
        function supportsState() {
            return !!window.history.pushState;
        }
        function createBrowserPlatformLocation() {
            return new BrowserPlatformLocation(core_inject(common_DOCUMENT));
        }
        function joinWithSlash(start, end) {
            if (start.length == 0) {
                return end;
            }
            if (end.length == 0) {
                return start;
            }
            let slashes = 0;
            if (start.endsWith("/")) {
                slashes++;
            }
            if (end.startsWith("/")) {
                slashes++;
            }
            if (slashes == 2) {
                return start + end.substring(1);
            }
            if (slashes == 1) {
                return start + end;
            }
            return start + "/" + end;
        }
        function stripTrailingSlash(url) {
            const match2 = url.match(/#|\?|$/);
            const pathEndIdx = match2 && match2.index || url.length;
            const droppedSlashIdx = pathEndIdx - (url[pathEndIdx - 1] === "/" ? 1 : 0);
            return url.slice(0, droppedSlashIdx) + url.slice(pathEndIdx);
        }
        function normalizeQueryParams(params) {
            return params && params[0] !== "?" ? "?" + params : params;
        }
        let LocationStrategy = (() => {
            class LocationStrategy2 {
                historyGo(relativePosition) {
                    throw new Error("Not implemented");
                }
            }
            LocationStrategy2.fac = function LocationStrategy_Factory(t) {
                return new (t || LocationStrategy2);
            };
            LocationStrategy2.prov = defineInjectable({
                token: LocationStrategy2,
                factory: function() {
                    return (() => fesm2020_core_inject(PathLocationStrategy))();
                },
                providedIn: "root"
            });
            return LocationStrategy2;
        })();
        (function() {})();
        const APP_BASE_HREF = new InjectionToken("appBaseHref");
        let PathLocationStrategy = (() => {
            class PathLocationStrategy2 extends LocationStrategy {
                constructor(_platformLocation, href) {
                    super();
                    this._platformLocation = _platformLocation;
                    this._removeListenerFns = [];
                    this._baseHref = href ?? this._platformLocation.getBaseHrefFromDOM() ?? fesm2020_core_inject(common_DOCUMENT).location?.origin ?? "";
                }
                ngOnDestroy() {
                    while (this._removeListenerFns.length) {
                        this._removeListenerFns.pop()();
                    }
                }
                onPopState(fn) {
                    this._removeListenerFns.push(this._platformLocation.onPopState(fn), this._platformLocation.onHashChange(fn));
                }
                getBaseHref() {
                    return this._baseHref;
                }
                prepareExternalUrl(internal) {
                    return joinWithSlash(this._baseHref, internal);
                }
                path(includeHash = false) {
                    const pathname = this._platformLocation.pathname + normalizeQueryParams(this._platformLocation.search);
                    const hash = this._platformLocation.hash;
                    return hash && includeHash ? `${pathname}${hash}` : pathname;
                }
                pushState(state, title, url, queryParams) {
                    const externalUrl = this.prepareExternalUrl(url + normalizeQueryParams(queryParams));
                    this._platformLocation.pushState(state, title, externalUrl);
                }
                replaceState(state, title, url, queryParams) {
                    const externalUrl = this.prepareExternalUrl(url + normalizeQueryParams(queryParams));
                    this._platformLocation.replaceState(state, title, externalUrl);
                }
                forward() {
                    this._platformLocation.forward();
                }
                back() {
                    this._platformLocation.back();
                }
                getState() {
                    return this._platformLocation.getState();
                }
                historyGo(relativePosition = 0) {
                    this._platformLocation.historyGo?.(relativePosition);
                }
            }
            PathLocationStrategy2.fac = function PathLocationStrategy_Factory(t) {
                return new (t || PathLocationStrategy2)(core_inject(PlatformLocation), core_inject(APP_BASE_HREF, 8));
            };
            PathLocationStrategy2.prov = defineInjectable({
                token: PathLocationStrategy2,
                factory: PathLocationStrategy2.fac,
                providedIn: "root"
            });
            return PathLocationStrategy2;
        })();
        (function() {})();
        let HashLocationStrategy = (() => {
            class HashLocationStrategy2 extends LocationStrategy {
                constructor(_platformLocation, _baseHref) {
                    super();
                    this._platformLocation = _platformLocation;
                    this._baseHref = "";
                    this._removeListenerFns = [];
                    if (_baseHref != null) {
                        this._baseHref = _baseHref;
                    }
                }
                ngOnDestroy() {
                    while (this._removeListenerFns.length) {
                        this._removeListenerFns.pop()();
                    }
                }
                onPopState(fn) {
                    this._removeListenerFns.push(this._platformLocation.onPopState(fn), this._platformLocation.onHashChange(fn));
                }
                getBaseHref() {
                    return this._baseHref;
                }
                path(includeHash = false) {
                    let path = this._platformLocation.hash;
                    if (path == null) {
                        path = "#";
                    }
                    return path.length > 0 ? path.substring(1) : path;
                }
                prepareExternalUrl(internal) {
                    const url = joinWithSlash(this._baseHref, internal);
                    return url.length > 0 ? "#" + url : url;
                }
                pushState(state, title, path, queryParams) {
                    let url = this.prepareExternalUrl(path + normalizeQueryParams(queryParams));
                    if (url.length == 0) {
                        url = this._platformLocation.pathname;
                    }
                    this._platformLocation.pushState(state, title, url);
                }
                replaceState(state, title, path, queryParams) {
                    let url = this.prepareExternalUrl(path + normalizeQueryParams(queryParams));
                    if (url.length == 0) {
                        url = this._platformLocation.pathname;
                    }
                    this._platformLocation.replaceState(state, title, url);
                }
                forward() {
                    this._platformLocation.forward();
                }
                back() {
                    this._platformLocation.back();
                }
                getState() {
                    return this._platformLocation.getState();
                }
                historyGo(relativePosition = 0) {
                    this._platformLocation.historyGo?.(relativePosition);
                }
            }
            HashLocationStrategy2.fac = function HashLocationStrategy_Factory(t) {
                return new (t || HashLocationStrategy2)(core_inject(PlatformLocation), core_inject(APP_BASE_HREF, 8));
            };
            HashLocationStrategy2.prov = defineInjectable({
                token: HashLocationStrategy2,
                factory: HashLocationStrategy2.fac
            });
            return HashLocationStrategy2;
        })();
        (function() {})();
        let Location = (() => {
            class Location2 {
                constructor(locationStrategy) {
                    this._subject = new EventEmitter;
                    this._urlChangeListeners = [];
                    this._urlChangeSubscription = null;
                    this._locationStrategy = locationStrategy;
                    const browserBaseHref = this._locationStrategy.getBaseHref();
                    this._baseHref = stripTrailingSlash(_stripIndexHtml(browserBaseHref));
                    this._locationStrategy.onPopState(ev => {
                        this._subject.emit({
                            url: this.path(true),
                            pop: true,
                            state: ev.state,
                            type: ev.type
                        });
                    });
                }
                ngOnDestroy() {
                    this._urlChangeSubscription?.unsubscribe();
                    this._urlChangeListeners = [];
                }
                path(includeHash = false) {
                    return this.normalize(this._locationStrategy.path(includeHash));
                }
                getState() {
                    return this._locationStrategy.getState();
                }
                isCurrentPathEqualTo(path, query = "") {
                    return this.path() == this.normalize(path + normalizeQueryParams(query));
                }
                normalize(url) {
                    return Location2.stripTrailingSlash(_stripBaseHref(this._baseHref, _stripIndexHtml(url)));
                }
                prepareExternalUrl(url) {
                    if (url && url[0] !== "/") {
                        url = "/" + url;
                    }
                    return this._locationStrategy.prepareExternalUrl(url);
                }
                go(path, query = "", state = null) {
                    this._locationStrategy.pushState(state, "", path, query);
                    this._notifyUrlChangeListeners(this.prepareExternalUrl(path + normalizeQueryParams(query)), state);
                }
                replaceState(path, query = "", state = null) {
                    this._locationStrategy.replaceState(state, "", path, query);
                    this._notifyUrlChangeListeners(this.prepareExternalUrl(path + normalizeQueryParams(query)), state);
                }
                forward() {
                    this._locationStrategy.forward();
                }
                back() {
                    this._locationStrategy.back();
                }
                historyGo(relativePosition = 0) {
                    this._locationStrategy.historyGo?.(relativePosition);
                }
                onUrlChange(fn) {
                    this._urlChangeListeners.push(fn);
                    if (!this._urlChangeSubscription) {
                        this._urlChangeSubscription = this.subscribe(v => {
                            this._notifyUrlChangeListeners(v.url, v.state);
                        });
                    }
                    return () => {
                        const fnIndex = this._urlChangeListeners.indexOf(fn);
                        this._urlChangeListeners.splice(fnIndex, 1);
                        if (this._urlChangeListeners.length === 0) {
                            this._urlChangeSubscription?.unsubscribe();
                            this._urlChangeSubscription = null;
                        }
                    };
                }
                _notifyUrlChangeListeners(url = "", state) {
                    this._urlChangeListeners.forEach(fn => fn(url, state));
                }
                subscribe(onNext, onThrow, onReturn) {
                    return this._subject.subscribe({
                        next: onNext,
                        error: onThrow,
                        complete: onReturn
                    });
                }
            }
            Location2.normalizeQueryParams = normalizeQueryParams;
            Location2.joinWithSlash = joinWithSlash;
            Location2.stripTrailingSlash = stripTrailingSlash;
            Location2.fac = function Location_Factory(t) {
                return new (t || Location2)(core_inject(LocationStrategy));
            };
            Location2.prov = defineInjectable({
                token: Location2,
                factory: function() {
                    return createLocation();
                },
                providedIn: "root"
            });
            return Location2;
        })();
        (function() {})();
        function createLocation() {
            return new Location(core_inject(LocationStrategy));
        }
        function _stripBaseHref(baseHref, url) {
            return baseHref && url.startsWith(baseHref) ? url.substring(baseHref.length) : url;
        }
        function _stripIndexHtml(url) {
            return url.replace(/\/index.html$/, "");
        }
        const CURRENCIES_EN = {
            ADP: [ void 0, void 0, 0 ],
            AFN: [ void 0, "", 0 ],
            ALL: [ void 0, void 0, 0 ],
            AMD: [ void 0, "", 2 ],
            AOA: [ void 0, "Kz" ],
            ARS: [ void 0, "$" ],
            AUD: [ "A$", "$" ],
            AZN: [ void 0, "" ],
            BAM: [ void 0, "KM" ],
            BBD: [ void 0, "$" ],
            BDT: [ void 0, "" ],
            BHD: [ void 0, void 0, 3 ],
            BIF: [ void 0, void 0, 0 ],
            BMD: [ void 0, "$" ],
            BND: [ void 0, "$" ],
            BOB: [ void 0, "Bs" ],
            BRL: [ "R$" ],
            BSD: [ void 0, "$" ],
            BWP: [ void 0, "P" ],
            BYN: [ void 0, void 0, 2 ],
            BYR: [ void 0, void 0, 0 ],
            BZD: [ void 0, "$" ],
            CAD: [ "CA$", "$", 2 ],
            CHF: [ void 0, void 0, 2 ],
            CLF: [ void 0, void 0, 4 ],
            CLP: [ void 0, "$", 0 ],
            CNY: [ "CN", "" ],
            COP: [ void 0, "$", 2 ],
            CRC: [ void 0, "", 2 ],
            CUC: [ void 0, "$" ],
            CUP: [ void 0, "$" ],
            CZK: [ void 0, "K", 2 ],
            DJF: [ void 0, void 0, 0 ],
            DKK: [ void 0, "kr", 2 ],
            DOP: [ void 0, "$" ],
            EGP: [ void 0, "E" ],
            ESP: [ void 0, "", 0 ],
            EUR: [ "" ],
            FJD: [ void 0, "$" ],
            FKP: [ void 0, "" ],
            GBP: [ "" ],
            GEL: [ void 0, "" ],
            GHS: [ void 0, "GH" ],
            GIP: [ void 0, "" ],
            GNF: [ void 0, "FG", 0 ],
            GTQ: [ void 0, "Q" ],
            GYD: [ void 0, "$", 2 ],
            HKD: [ "HK$", "$" ],
            HNL: [ void 0, "L" ],
            HRK: [ void 0, "kn" ],
            HUF: [ void 0, "Ft", 2 ],
            IDR: [ void 0, "Rp", 2 ],
            ILS: [ "" ],
            INR: [ "" ],
            IQD: [ void 0, void 0, 0 ],
            IRR: [ void 0, void 0, 0 ],
            ISK: [ void 0, "kr", 0 ],
            ITL: [ void 0, void 0, 0 ],
            JMD: [ void 0, "$" ],
            JOD: [ void 0, void 0, 3 ],
            JPY: [ "", void 0, 0 ],
            KHR: [ void 0, "" ],
            KMF: [ void 0, "CF", 0 ],
            KPW: [ void 0, "", 0 ],
            KRW: [ "", void 0, 0 ],
            KWD: [ void 0, void 0, 3 ],
            KYD: [ void 0, "$" ],
            KZT: [ void 0, "" ],
            LAK: [ void 0, "", 0 ],
            LBP: [ void 0, "L", 0 ],
            LKR: [ void 0, "Rs" ],
            LRD: [ void 0, "$" ],
            LTL: [ void 0, "Lt" ],
            LUF: [ void 0, void 0, 0 ],
            LVL: [ void 0, "Ls" ],
            LYD: [ void 0, void 0, 3 ],
            MGA: [ void 0, "Ar", 0 ],
            MGF: [ void 0, void 0, 0 ],
            MMK: [ void 0, "K", 0 ],
            MNT: [ void 0, "", 2 ],
            MRO: [ void 0, void 0, 0 ],
            MUR: [ void 0, "Rs", 2 ],
            MXN: [ "MX$", "$" ],
            MYR: [ void 0, "RM" ],
            NAD: [ void 0, "$" ],
            NGN: [ void 0, "" ],
            NIO: [ void 0, "C$" ],
            NOK: [ void 0, "kr", 2 ],
            NPR: [ void 0, "Rs" ],
            NZD: [ "NZ$", "$" ],
            OMR: [ void 0, void 0, 3 ],
            PHP: [ "" ],
            PKR: [ void 0, "Rs", 2 ],
            PLN: [ void 0, "z" ],
            PYG: [ void 0, "", 0 ],
            RON: [ void 0, "lei" ],
            RSD: [ void 0, void 0, 0 ],
            RUB: [ void 0, "" ],
            RWF: [ void 0, "RF", 0 ],
            SBD: [ void 0, "$" ],
            SEK: [ void 0, "kr", 2 ],
            SGD: [ void 0, "$" ],
            SHP: [ void 0, "" ],
            SLE: [ void 0, void 0, 2 ],
            SLL: [ void 0, void 0, 0 ],
            SOS: [ void 0, void 0, 0 ],
            SRD: [ void 0, "$" ],
            SSP: [ void 0, "" ],
            STD: [ void 0, void 0, 0 ],
            STN: [ void 0, "Db" ],
            SYP: [ void 0, "", 0 ],
            THB: [ void 0, "" ],
            TMM: [ void 0, void 0, 0 ],
            TND: [ void 0, void 0, 3 ],
            TOP: [ void 0, "T$" ],
            TRL: [ void 0, void 0, 0 ],
            TRY: [ void 0, "" ],
            TTD: [ void 0, "$" ],
            TWD: [ "NT$", "$", 2 ],
            TZS: [ void 0, void 0, 2 ],
            UAH: [ void 0, "" ],
            UGX: [ void 0, void 0, 0 ],
            USD: [ "$" ],
            UYI: [ void 0, void 0, 0 ],
            UYU: [ void 0, "$" ],
            UYW: [ void 0, void 0, 4 ],
            UZS: [ void 0, void 0, 2 ],
            VEF: [ void 0, "Bs", 2 ],
            VND: [ "", void 0, 0 ],
            VUV: [ void 0, void 0, 0 ],
            XAF: [ "FCFA", void 0, 0 ],
            XCD: [ "EC$", "$" ],
            XOF: [ "FCFA", void 0, 0 ],
            XPF: [ "CFPF", void 0, 0 ],
            XXX: [ "" ],
            YER: [ void 0, void 0, 0 ],
            ZAR: [ void 0, "R" ],
            ZMK: [ void 0, void 0, 0 ],
            ZMW: [ void 0, "ZK" ],
            ZWD: [ void 0, void 0, 0 ]
        };
        var NumberFormatStyle = (() => {
            NumberFormatStyle = NumberFormatStyle || {};
            NumberFormatStyle[NumberFormatStyle["Decimal"] = 0] = "Decimal";
            NumberFormatStyle[NumberFormatStyle["Percent"] = 1] = "Percent";
            NumberFormatStyle[NumberFormatStyle["Currency"] = 2] = "Currency";
            NumberFormatStyle[NumberFormatStyle["Scientific"] = 3] = "Scientific";
            return NumberFormatStyle;
        })();
        var Plural = (() => {
            Plural = Plural || {};
            Plural[Plural["Zero"] = 0] = "Zero";
            Plural[Plural["One"] = 1] = "One";
            Plural[Plural["Two"] = 2] = "Two";
            Plural[Plural["Few"] = 3] = "Few";
            Plural[Plural["Many"] = 4] = "Many";
            Plural[Plural["Other"] = 5] = "Other";
            return Plural;
        })();
        var FormStyle = (() => {
            FormStyle = FormStyle || {};
            FormStyle[FormStyle["Format"] = 0] = "Format";
            FormStyle[FormStyle["Standalone"] = 1] = "Standalone";
            return FormStyle;
        })();
        var TranslationWidth = (() => {
            TranslationWidth = TranslationWidth || {};
            TranslationWidth[TranslationWidth["Narrow"] = 0] = "Narrow";
            TranslationWidth[TranslationWidth["Abbreviated"] = 1] = "Abbreviated";
            TranslationWidth[TranslationWidth["Wide"] = 2] = "Wide";
            TranslationWidth[TranslationWidth["Short"] = 3] = "Short";
            return TranslationWidth;
        })();
        var FormatWidth = (() => {
            FormatWidth = FormatWidth || {};
            FormatWidth[FormatWidth["Short"] = 0] = "Short";
            FormatWidth[FormatWidth["Medium"] = 1] = "Medium";
            FormatWidth[FormatWidth["Long"] = 2] = "Long";
            FormatWidth[FormatWidth["Full"] = 3] = "Full";
            return FormatWidth;
        })();
        var NumberSymbol = (() => {
            NumberSymbol = NumberSymbol || {};
            NumberSymbol[NumberSymbol["Decimal"] = 0] = "Decimal";
            NumberSymbol[NumberSymbol["Group"] = 1] = "Group";
            NumberSymbol[NumberSymbol["List"] = 2] = "List";
            NumberSymbol[NumberSymbol["PercentSign"] = 3] = "PercentSign";
            NumberSymbol[NumberSymbol["PlusSign"] = 4] = "PlusSign";
            NumberSymbol[NumberSymbol["MinusSign"] = 5] = "MinusSign";
            NumberSymbol[NumberSymbol["Exponential"] = 6] = "Exponential";
            NumberSymbol[NumberSymbol["SuperscriptingExponent"] = 7] = "SuperscriptingExponent";
            NumberSymbol[NumberSymbol["PerMille"] = 8] = "PerMille";
            NumberSymbol[NumberSymbol["Infinity"] = 9] = "Infinity";
            NumberSymbol[NumberSymbol["NaN"] = 10] = "NaN";
            NumberSymbol[NumberSymbol["TimeSeparator"] = 11] = "TimeSeparator";
            NumberSymbol[NumberSymbol["CurrencyDecimal"] = 12] = "CurrencyDecimal";
            NumberSymbol[NumberSymbol["CurrencyGroup"] = 13] = "CurrencyGroup";
            return NumberSymbol;
        })();
        var WeekDay = null;
        function common_getLocaleId(locale) {
            return findLocaleData(locale)[LocaleDataIndex.LocaleId];
        }
        function getLocaleDayPeriods(locale, formStyle, width) {
            const data = findLocaleData(locale);
            const amPmData = [ data[LocaleDataIndex.DayPeriodsFormat], data[LocaleDataIndex.DayPeriodsStandalone] ];
            const amPm = getLastDefinedValue(amPmData, formStyle);
            return getLastDefinedValue(amPm, width);
        }
        function getLocaleDayNames(locale, formStyle, width) {
            const data = findLocaleData(locale);
            const daysData = [ data[LocaleDataIndex.DaysFormat], data[LocaleDataIndex.DaysStandalone] ];
            const days = getLastDefinedValue(daysData, formStyle);
            return getLastDefinedValue(days, width);
        }
        function getLocaleMonthNames(locale, formStyle, width) {
            const data = findLocaleData(locale);
            const monthsData = [ data[LocaleDataIndex.MonthsFormat], data[LocaleDataIndex.MonthsStandalone] ];
            const months = getLastDefinedValue(monthsData, formStyle);
            return getLastDefinedValue(months, width);
        }
        function getLocaleEraNames(locale, width) {
            const data = findLocaleData(locale);
            const erasData = data[LocaleDataIndex.Eras];
            return getLastDefinedValue(erasData, width);
        }
        function getLocaleFirstDayOfWeek(locale) {
            const data = findLocaleData(locale);
            return data[LocaleDataIndex.FirstDayOfWeek];
        }
        function getLocaleWeekEndRange(locale) {
            const data = findLocaleData(locale);
            return data[LocaleDataIndex.WeekendRange];
        }
        function getLocaleDateFormat(locale, width) {
            const data = findLocaleData(locale);
            return getLastDefinedValue(data[LocaleDataIndex.DateFormat], width);
        }
        function getLocaleTimeFormat(locale, width) {
            const data = findLocaleData(locale);
            return getLastDefinedValue(data[LocaleDataIndex.TimeFormat], width);
        }
        function getLocaleDateTimeFormat(locale, width) {
            const data = findLocaleData(locale);
            const dateTimeFormatData = data[LocaleDataIndex.DateTimeFormat];
            return getLastDefinedValue(dateTimeFormatData, width);
        }
        function getLocaleNumberSymbol(locale, symbol) {
            const data = findLocaleData(locale);
            const res = data[LocaleDataIndex.NumberSymbols][symbol];
            if (typeof res === "undefined") {
                if (symbol === NumberSymbol.CurrencyDecimal) {
                    return data[LocaleDataIndex.NumberSymbols][NumberSymbol.Decimal];
                } else if (symbol === NumberSymbol.CurrencyGroup) {
                    return data[LocaleDataIndex.NumberSymbols][NumberSymbol.Group];
                }
            }
            return res;
        }
        function getLocaleNumberFormat(locale, type) {
            const data = findLocaleData(locale);
            return data[LocaleDataIndex.NumberFormats][type];
        }
        function getLocaleCurrencySymbol(locale) {
            const data = findLocaleData(locale);
            return data[LocaleDataIndex.CurrencySymbol] || null;
        }
        function getLocaleCurrencyName(locale) {
            const data = findLocaleData(locale);
            return data[LocaleDataIndex.CurrencyName] || null;
        }
        function common_getLocaleCurrencyCode(locale) {
            return getLocaleCurrencyCode(locale);
        }
        function getLocaleCurrencies(locale) {
            const data = findLocaleData(locale);
            return data[LocaleDataIndex.Currencies];
        }
        const common_getLocalePluralCase = getLocalePluralCase;
        function checkFullData(data) {
            if (!data[LocaleDataIndex.ExtraData]) {
                throw new Error(`Missing extra locale data for the locale "${data[LocaleDataIndex.LocaleId]}". Use "registerLocaleData" to load new data. See the "I18n guide" on angular.io to know more.`);
            }
        }
        function getLocaleExtraDayPeriodRules(locale) {
            const data = findLocaleData(locale);
            checkFullData(data);
            const rules = data[LocaleDataIndex.ExtraData][2] || [];
            return rules.map(rule => {
                if (typeof rule === "string") {
                    return extractTime(rule);
                }
                return [ extractTime(rule[0]), extractTime(rule[1]) ];
            });
        }
        function getLocaleExtraDayPeriods(locale, formStyle, width) {
            const data = findLocaleData(locale);
            checkFullData(data);
            const dayPeriodsData = [ data[LocaleDataIndex.ExtraData][0], data[LocaleDataIndex.ExtraData][1] ];
            const dayPeriods = getLastDefinedValue(dayPeriodsData, formStyle) || [];
            return getLastDefinedValue(dayPeriods, width) || [];
        }
        function getLocaleDirection(locale) {
            const data = findLocaleData(locale);
            return data[LocaleDataIndex.Directionality];
        }
        function getLastDefinedValue(data, index) {
            for (let i = index; i > -1; i--) {
                if (typeof data[i] !== "undefined") {
                    return data[i];
                }
            }
            throw new Error("Locale data API: locale data undefined");
        }
        function extractTime(time) {
            const [h, m] = time.split(":");
            return {
                hours: +h,
                minutes: +m
            };
        }
        function getCurrencySymbol(code, format, locale = "en") {
            const currency = getLocaleCurrencies(locale)[code] || CURRENCIES_EN[code] || [];
            const symbolNarrow = currency[1];
            if (format === "narrow" && typeof symbolNarrow === "string") {
                return symbolNarrow;
            }
            return currency[0] || code;
        }
        const DEFAULT_NB_OF_CURRENCY_DIGITS = 2;
        function getNumberOfCurrencyDigits(code) {
            let digits;
            const currency = CURRENCIES_EN[code];
            if (currency) {
                digits = currency[2];
            }
            return typeof digits === "number" ? digits : DEFAULT_NB_OF_CURRENCY_DIGITS;
        }
        const ISO8601_DATE_REGEX = /^(\d{4,})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
        const NAMED_FORMATS = {};
        const DATE_FORMATS_SPLIT = /((?:[^BEGHLMOSWYZabcdhmswyz']+)|(?:'(?:[^']|'')*')|(?:G{1,5}|y{1,4}|Y{1,4}|M{1,5}|L{1,5}|w{1,2}|W{1}|d{1,2}|E{1,6}|c{1,6}|a{1,5}|b{1,5}|B{1,5}|h{1,2}|H{1,2}|m{1,2}|s{1,2}|S{1,3}|z{1,4}|Z{1,5}|O{1,4}))([\s\S]*)/;
        var ZoneWidth = (() => {
            ZoneWidth = ZoneWidth || {};
            ZoneWidth[ZoneWidth["Short"] = 0] = "Short";
            ZoneWidth[ZoneWidth["ShortGMT"] = 1] = "ShortGMT";
            ZoneWidth[ZoneWidth["Long"] = 2] = "Long";
            ZoneWidth[ZoneWidth["Extended"] = 3] = "Extended";
            return ZoneWidth;
        })();
        var DateType = (() => {
            DateType = DateType || {};
            DateType[DateType["FullYear"] = 0] = "FullYear";
            DateType[DateType["Month"] = 1] = "Month";
            DateType[DateType["Date"] = 2] = "Date";
            DateType[DateType["Hours"] = 3] = "Hours";
            DateType[DateType["Minutes"] = 4] = "Minutes";
            DateType[DateType["Seconds"] = 5] = "Seconds";
            DateType[DateType["FractionalSeconds"] = 6] = "FractionalSeconds";
            DateType[DateType["Day"] = 7] = "Day";
            return DateType;
        })();
        var TranslationType = (() => {
            TranslationType = TranslationType || {};
            TranslationType[TranslationType["DayPeriods"] = 0] = "DayPeriods";
            TranslationType[TranslationType["Days"] = 1] = "Days";
            TranslationType[TranslationType["Months"] = 2] = "Months";
            TranslationType[TranslationType["Eras"] = 3] = "Eras";
            return TranslationType;
        })();
        function formatDate(value, format, locale, timezone) {
            let date = toDate(value);
            const namedFormat = getNamedFormat(locale, format);
            format = namedFormat || format;
            let parts = [];
            let match2;
            while (format) {
                match2 = DATE_FORMATS_SPLIT.exec(format);
                if (match2) {
                    parts = parts.concat(match2.slice(1));
                    const part = parts.pop();
                    if (!part) {
                        break;
                    }
                    format = part;
                } else {
                    parts.push(format);
                    break;
                }
            }
            let dateTimezoneOffset = date.getTimezoneOffset();
            if (timezone) {
                dateTimezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
                date = convertTimezoneToLocal(date, timezone, true);
            }
            let text = "";
            parts.forEach(value2 => {
                const dateFormatter = getDateFormatter(value2);
                text += dateFormatter ? dateFormatter(date, locale, dateTimezoneOffset) : value2 === "''" ? "'" : value2.replace(/(^'|'$)/g, "").replace(/''/g, "'");
            });
            return text;
        }
        function createDate(year, month, date) {
            const newDate = new Date(0);
            newDate.setFullYear(year, month, date);
            newDate.setHours(0, 0, 0);
            return newDate;
        }
        function getNamedFormat(locale, format) {
            const localeId = common_getLocaleId(locale);
            NAMED_FORMATS[localeId] = NAMED_FORMATS[localeId] || {};
            if (NAMED_FORMATS[localeId][format]) {
                return NAMED_FORMATS[localeId][format];
            }
            let formatValue = "";
            switch (format) {
              case "shortDate":
                formatValue = getLocaleDateFormat(locale, FormatWidth.Short);
                break;

              case "mediumDate":
                formatValue = getLocaleDateFormat(locale, FormatWidth.Medium);
                break;

              case "longDate":
                formatValue = getLocaleDateFormat(locale, FormatWidth.Long);
                break;

              case "fullDate":
                formatValue = getLocaleDateFormat(locale, FormatWidth.Full);
                break;

              case "shortTime":
                formatValue = getLocaleTimeFormat(locale, FormatWidth.Short);
                break;

              case "mediumTime":
                formatValue = getLocaleTimeFormat(locale, FormatWidth.Medium);
                break;

              case "longTime":
                formatValue = getLocaleTimeFormat(locale, FormatWidth.Long);
                break;

              case "fullTime":
                formatValue = getLocaleTimeFormat(locale, FormatWidth.Full);
                break;

              case "short":
                const shortTime = getNamedFormat(locale, "shortTime");
                const shortDate = getNamedFormat(locale, "shortDate");
                formatValue = formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Short), [ shortTime, shortDate ]);
                break;

              case "medium":
                const mediumTime = getNamedFormat(locale, "mediumTime");
                const mediumDate = getNamedFormat(locale, "mediumDate");
                formatValue = formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Medium), [ mediumTime, mediumDate ]);
                break;

              case "long":
                const longTime = getNamedFormat(locale, "longTime");
                const longDate = getNamedFormat(locale, "longDate");
                formatValue = formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Long), [ longTime, longDate ]);
                break;

              case "full":
                const fullTime = getNamedFormat(locale, "fullTime");
                const fullDate = getNamedFormat(locale, "fullDate");
                formatValue = formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Full), [ fullTime, fullDate ]);
                break;
            }
            if (formatValue) {
                NAMED_FORMATS[localeId][format] = formatValue;
            }
            return formatValue;
        }
        function formatDateTime(str, opt_values) {
            if (opt_values) {
                str = str.replace(/\{([^}]+)}/g, function(match2, key) {
                    return opt_values != null && key in opt_values ? opt_values[key] : match2;
                });
            }
            return str;
        }
        function padNumber(num, digits, minusSign = "-", trim, negWrap) {
            let neg = "";
            if (num < 0 || negWrap && num <= 0) {
                if (negWrap) {
                    num = -num + 1;
                } else {
                    num = -num;
                    neg = minusSign;
                }
            }
            let strNum = String(num);
            while (strNum.length < digits) {
                strNum = "0" + strNum;
            }
            if (trim) {
                strNum = strNum.slice(strNum.length - digits);
            }
            return neg + strNum;
        }
        function formatFractionalSeconds(milliseconds, digits) {
            const strMs = padNumber(milliseconds, 3);
            return strMs.substring(0, digits);
        }
        function dateGetter(name, size, offset = 0, trim = false, negWrap = false) {
            return function(date, locale) {
                let part = getDatePart(name, date);
                if (offset > 0 || part > -offset) {
                    part += offset;
                }
                if (name === DateType.Hours) {
                    if (part === 0 && offset === -12) {
                        part = 12;
                    }
                } else if (name === DateType.FractionalSeconds) {
                    return formatFractionalSeconds(part, size);
                }
                const localeMinus = getLocaleNumberSymbol(locale, NumberSymbol.MinusSign);
                return padNumber(part, size, localeMinus, trim, negWrap);
            };
        }
        function getDatePart(part, date) {
            switch (part) {
              case DateType.FullYear:
                return date.getFullYear();

              case DateType.Month:
                return date.getMonth();

              case DateType.Date:
                return date.getDate();

              case DateType.Hours:
                return date.getHours();

              case DateType.Minutes:
                return date.getMinutes();

              case DateType.Seconds:
                return date.getSeconds();

              case DateType.FractionalSeconds:
                return date.getMilliseconds();

              case DateType.Day:
                return date.getDay();

              default:
                throw new Error(`Unknown DateType value "${part}".`);
            }
        }
        function dateStrGetter(name, width, form = FormStyle.Format, extended = false) {
            return function(date, locale) {
                return getDateTranslation(date, locale, name, width, form, extended);
            };
        }
        function getDateTranslation(date, locale, name, width, form, extended) {
            switch (name) {
              case TranslationType.Months:
                return getLocaleMonthNames(locale, form, width)[date.getMonth()];

              case TranslationType.Days:
                return getLocaleDayNames(locale, form, width)[date.getDay()];

              case TranslationType.DayPeriods:
                const currentHours = date.getHours();
                const currentMinutes = date.getMinutes();
                if (extended) {
                    const rules = getLocaleExtraDayPeriodRules(locale);
                    const dayPeriods = getLocaleExtraDayPeriods(locale, form, width);
                    const index = rules.findIndex(rule => {
                        if (Array.isArray(rule)) {
                            const [from2, to] = rule;
                            const afterFrom = currentHours >= from2.hours && currentMinutes >= from2.minutes;
                            const beforeTo = currentHours < to.hours || currentHours === to.hours && currentMinutes < to.minutes;
                            if (from2.hours < to.hours) {
                                if (afterFrom && beforeTo) {
                                    return true;
                                }
                            } else if (afterFrom || beforeTo) {
                                return true;
                            }
                        } else {
                            if (rule.hours === currentHours && rule.minutes === currentMinutes) {
                                return true;
                            }
                        }
                        return false;
                    });
                    if (index !== -1) {
                        return dayPeriods[index];
                    }
                }
                return getLocaleDayPeriods(locale, form, width)[currentHours < 12 ? 0 : 1];

              case TranslationType.Eras:
                return getLocaleEraNames(locale, width)[date.getFullYear() <= 0 ? 0 : 1];

              default:
                const unexpected = name;
                throw new Error(`unexpected translation type ${unexpected}`);
            }
        }
        function timeZoneGetter(width) {
            return function(date, locale, offset) {
                const zone = -1 * offset;
                const minusSign = getLocaleNumberSymbol(locale, NumberSymbol.MinusSign);
                const hours = zone > 0 ? Math.floor(zone / 60) : Math.ceil(zone / 60);
                switch (width) {
                  case ZoneWidth.Short:
                    return (zone >= 0 ? "+" : "") + padNumber(hours, 2, minusSign) + padNumber(Math.abs(zone % 60), 2, minusSign);

                  case ZoneWidth.ShortGMT:
                    return "GMT" + (zone >= 0 ? "+" : "") + padNumber(hours, 1, minusSign);

                  case ZoneWidth.Long:
                    return "GMT" + (zone >= 0 ? "+" : "") + padNumber(hours, 2, minusSign) + ":" + padNumber(Math.abs(zone % 60), 2, minusSign);

                  case ZoneWidth.Extended:
                    if (offset === 0) {
                        return "Z";
                    } else {
                        return (zone >= 0 ? "+" : "") + padNumber(hours, 2, minusSign) + ":" + padNumber(Math.abs(zone % 60), 2, minusSign);
                    }

                  default:
                    throw new Error(`Unknown zone width "${width}"`);
                }
            };
        }
        const JANUARY = 0;
        const THURSDAY = 4;
        function getFirstThursdayOfYear(year) {
            const firstDayOfYear = createDate(year, JANUARY, 1).getDay();
            return createDate(year, 0, 1 + (firstDayOfYear <= THURSDAY ? THURSDAY : THURSDAY + 7) - firstDayOfYear);
        }
        function getThursdayThisWeek(datetime) {
            return createDate(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (THURSDAY - datetime.getDay()));
        }
        function weekGetter(size, monthBased = false) {
            return function(date, locale) {
                let result;
                if (monthBased) {
                    const nbDaysBefore1stDayOfMonth = new Date(date.getFullYear(), date.getMonth(), 1).getDay() - 1;
                    const today = date.getDate();
                    result = 1 + Math.floor((today + nbDaysBefore1stDayOfMonth) / 7);
                } else {
                    const thisThurs = getThursdayThisWeek(date);
                    const firstThurs = getFirstThursdayOfYear(thisThurs.getFullYear());
                    const diff = thisThurs.getTime() - firstThurs.getTime();
                    result = 1 + Math.round(diff / 6048e5);
                }
                return padNumber(result, size, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));
            };
        }
        function weekNumberingYearGetter(size, trim = false) {
            return function(date, locale) {
                const thisThurs = getThursdayThisWeek(date);
                const weekNumberingYear = thisThurs.getFullYear();
                return padNumber(weekNumberingYear, size, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign), trim);
            };
        }
        const DATE_FORMATS = {};
        function getDateFormatter(format) {
            if (DATE_FORMATS[format]) {
                return DATE_FORMATS[format];
            }
            let formatter;
            switch (format) {
              case "G":
              case "GG":
              case "GGG":
                formatter = dateStrGetter(TranslationType.Eras, TranslationWidth.Abbreviated);
                break;

              case "GGGG":
                formatter = dateStrGetter(TranslationType.Eras, TranslationWidth.Wide);
                break;

              case "GGGGG":
                formatter = dateStrGetter(TranslationType.Eras, TranslationWidth.Narrow);
                break;

              case "y":
                formatter = dateGetter(DateType.FullYear, 1, 0, false, true);
                break;

              case "yy":
                formatter = dateGetter(DateType.FullYear, 2, 0, true, true);
                break;

              case "yyy":
                formatter = dateGetter(DateType.FullYear, 3, 0, false, true);
                break;

              case "yyyy":
                formatter = dateGetter(DateType.FullYear, 4, 0, false, true);
                break;

              case "Y":
                formatter = weekNumberingYearGetter(1);
                break;

              case "YY":
                formatter = weekNumberingYearGetter(2, true);
                break;

              case "YYY":
                formatter = weekNumberingYearGetter(3);
                break;

              case "YYYY":
                formatter = weekNumberingYearGetter(4);
                break;

              case "M":
              case "L":
                formatter = dateGetter(DateType.Month, 1, 1);
                break;

              case "MM":
              case "LL":
                formatter = dateGetter(DateType.Month, 2, 1);
                break;

              case "MMM":
                formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Abbreviated);
                break;

              case "MMMM":
                formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Wide);
                break;

              case "MMMMM":
                formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Narrow);
                break;

              case "LLL":
                formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Abbreviated, FormStyle.Standalone);
                break;

              case "LLLL":
                formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Wide, FormStyle.Standalone);
                break;

              case "LLLLL":
                formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Narrow, FormStyle.Standalone);
                break;

              case "w":
                formatter = weekGetter(1);
                break;

              case "ww":
                formatter = weekGetter(2);
                break;

              case "W":
                formatter = weekGetter(1, true);
                break;

              case "d":
                formatter = dateGetter(DateType.Date, 1);
                break;

              case "dd":
                formatter = dateGetter(DateType.Date, 2);
                break;

              case "c":
              case "cc":
                formatter = dateGetter(DateType.Day, 1);
                break;

              case "ccc":
                formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Abbreviated, FormStyle.Standalone);
                break;

              case "cccc":
                formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Wide, FormStyle.Standalone);
                break;

              case "ccccc":
                formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Narrow, FormStyle.Standalone);
                break;

              case "cccccc":
                formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Short, FormStyle.Standalone);
                break;

              case "E":
              case "EE":
              case "EEE":
                formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Abbreviated);
                break;

              case "EEEE":
                formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Wide);
                break;

              case "EEEEE":
                formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Narrow);
                break;

              case "EEEEEE":
                formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Short);
                break;

              case "a":
              case "aa":
              case "aaa":
                formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Abbreviated);
                break;

              case "aaaa":
                formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Wide);
                break;

              case "aaaaa":
                formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Narrow);
                break;

              case "b":
              case "bb":
              case "bbb":
                formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Abbreviated, FormStyle.Standalone, true);
                break;

              case "bbbb":
                formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Wide, FormStyle.Standalone, true);
                break;

              case "bbbbb":
                formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Narrow, FormStyle.Standalone, true);
                break;

              case "B":
              case "BB":
              case "BBB":
                formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Abbreviated, FormStyle.Format, true);
                break;

              case "BBBB":
                formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Wide, FormStyle.Format, true);
                break;

              case "BBBBB":
                formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Narrow, FormStyle.Format, true);
                break;

              case "h":
                formatter = dateGetter(DateType.Hours, 1, -12);
                break;

              case "hh":
                formatter = dateGetter(DateType.Hours, 2, -12);
                break;

              case "H":
                formatter = dateGetter(DateType.Hours, 1);
                break;

              case "HH":
                formatter = dateGetter(DateType.Hours, 2);
                break;

              case "m":
                formatter = dateGetter(DateType.Minutes, 1);
                break;

              case "mm":
                formatter = dateGetter(DateType.Minutes, 2);
                break;

              case "s":
                formatter = dateGetter(DateType.Seconds, 1);
                break;

              case "ss":
                formatter = dateGetter(DateType.Seconds, 2);
                break;

              case "S":
                formatter = dateGetter(DateType.FractionalSeconds, 1);
                break;

              case "SS":
                formatter = dateGetter(DateType.FractionalSeconds, 2);
                break;

              case "SSS":
                formatter = dateGetter(DateType.FractionalSeconds, 3);
                break;

              case "Z":
              case "ZZ":
              case "ZZZ":
                formatter = timeZoneGetter(ZoneWidth.Short);
                break;

              case "ZZZZZ":
                formatter = timeZoneGetter(ZoneWidth.Extended);
                break;

              case "O":
              case "OO":
              case "OOO":
              case "z":
              case "zz":
              case "zzz":
                formatter = timeZoneGetter(ZoneWidth.ShortGMT);
                break;

              case "OOOO":
              case "ZZZZ":
              case "zzzz":
                formatter = timeZoneGetter(ZoneWidth.Long);
                break;

              default:
                return null;
            }
            DATE_FORMATS[format] = formatter;
            return formatter;
        }
        function timezoneToOffset(timezone, fallback) {
            timezone = timezone.replace(/:/g, "");
            const requestedTimezoneOffset = Date.parse("Jan 01, 1970 00:00:00 " + timezone) / 6e4;
            return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
        }
        function addDateMinutes(date, minutes) {
            date = new Date(date.getTime());
            date.setMinutes(date.getMinutes() + minutes);
            return date;
        }
        function convertTimezoneToLocal(date, timezone, reverse) {
            const reverseValue = reverse ? -1 : 1;
            const dateTimezoneOffset = date.getTimezoneOffset();
            const timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
            return addDateMinutes(date, reverseValue * (timezoneOffset - dateTimezoneOffset));
        }
        function toDate(value) {
            if (isDate(value)) {
                return value;
            }
            if (typeof value === "number" && !isNaN(value)) {
                return new Date(value);
            }
            if (typeof value === "string") {
                value = value.trim();
                if (/^(\d{4}(-\d{1,2}(-\d{1,2})?)?)$/.test(value)) {
                    const [y, m = 1, d = 1] = value.split("-").map(val => +val);
                    return createDate(y, m - 1, d);
                }
                const parsedNb = parseFloat(value);
                if (!isNaN(value - parsedNb)) {
                    return new Date(parsedNb);
                }
                let match2;
                if (match2 = value.match(ISO8601_DATE_REGEX)) {
                    return isoStringToDate(match2);
                }
            }
            const date = new Date(value);
            if (!isDate(date)) {
                throw new Error(`Unable to convert "${value}" into a date`);
            }
            return date;
        }
        function isoStringToDate(match2) {
            const date = new Date(0);
            let tzHour = 0;
            let tzMin = 0;
            const dateSetter = match2[8] ? date.setUTCFullYear : date.setFullYear;
            const timeSetter = match2[8] ? date.setUTCHours : date.setHours;
            if (match2[9]) {
                tzHour = Number(match2[9] + match2[10]);
                tzMin = Number(match2[9] + match2[11]);
            }
            dateSetter.call(date, Number(match2[1]), Number(match2[2]) - 1, Number(match2[3]));
            const h = Number(match2[4] || 0) - tzHour;
            const m = Number(match2[5] || 0) - tzMin;
            const s = Number(match2[6] || 0);
            const ms = Math.floor(parseFloat("0." + (match2[7] || 0)) * 1e3);
            timeSetter.call(date, h, m, s, ms);
            return date;
        }
        function isDate(value) {
            return value instanceof Date && !isNaN(value.valueOf());
        }
        const NUMBER_FORMAT_REGEXP = /^(\d+)?\.((\d+)(-(\d+))?)?$/;
        const MAX_DIGITS = 22;
        const DECIMAL_SEP = ".";
        const ZERO_CHAR = "0";
        const PATTERN_SEP = ";";
        const GROUP_SEP = ",";
        const DIGIT_CHAR = "#";
        const CURRENCY_CHAR = "";
        const PERCENT_CHAR = "%";
        function formatNumberToLocaleString(value, pattern, locale, groupSymbol, decimalSymbol, digitsInfo, isPercent = false) {
            let formattedText = "";
            let isZero = false;
            if (!isFinite(value)) {
                formattedText = getLocaleNumberSymbol(locale, NumberSymbol.Infinity);
            } else {
                let parsedNumber = parseNumber(value);
                if (isPercent) {
                    parsedNumber = toPercent(parsedNumber);
                }
                let minInt = pattern.minInt;
                let minFraction = pattern.minFrac;
                let maxFraction = pattern.maxFrac;
                if (digitsInfo) {
                    const parts = digitsInfo.match(NUMBER_FORMAT_REGEXP);
                    if (parts === null) {
                        throw new Error(`${digitsInfo} is not a valid digit info`);
                    }
                    const minIntPart = parts[1];
                    const minFractionPart = parts[3];
                    const maxFractionPart = parts[5];
                    if (minIntPart != null) {
                        minInt = parseIntAutoRadix(minIntPart);
                    }
                    if (minFractionPart != null) {
                        minFraction = parseIntAutoRadix(minFractionPart);
                    }
                    if (maxFractionPart != null) {
                        maxFraction = parseIntAutoRadix(maxFractionPart);
                    } else if (minFractionPart != null && minFraction > maxFraction) {
                        maxFraction = minFraction;
                    }
                }
                roundNumber(parsedNumber, minFraction, maxFraction);
                let digits = parsedNumber.digits;
                let integerLen = parsedNumber.integerLen;
                const exponent = parsedNumber.exponent;
                let decimals = [];
                isZero = digits.every(d => !d);
                for (;integerLen < minInt; integerLen++) {
                    digits.unshift(0);
                }
                for (;integerLen < 0; integerLen++) {
                    digits.unshift(0);
                }
                if (integerLen > 0) {
                    decimals = digits.splice(integerLen, digits.length);
                } else {
                    decimals = digits;
                    digits = [ 0 ];
                }
                const groups = [];
                if (digits.length >= pattern.lgSize) {
                    groups.unshift(digits.splice(-pattern.lgSize, digits.length).join(""));
                }
                while (digits.length > pattern.gSize) {
                    groups.unshift(digits.splice(-pattern.gSize, digits.length).join(""));
                }
                if (digits.length) {
                    groups.unshift(digits.join(""));
                }
                formattedText = groups.join(getLocaleNumberSymbol(locale, groupSymbol));
                if (decimals.length) {
                    formattedText += getLocaleNumberSymbol(locale, decimalSymbol) + decimals.join("");
                }
                if (exponent) {
                    formattedText += getLocaleNumberSymbol(locale, NumberSymbol.Exponential) + "+" + exponent;
                }
            }
            if (value < 0 && !isZero) {
                formattedText = pattern.negPre + formattedText + pattern.negSuf;
            } else {
                formattedText = pattern.posPre + formattedText + pattern.posSuf;
            }
            return formattedText;
        }
        function formatCurrency(value, locale, currency, currencyCode, digitsInfo) {
            const format = getLocaleNumberFormat(locale, NumberFormatStyle.Currency);
            const pattern = parseNumberFormat(format, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));
            pattern.minFrac = getNumberOfCurrencyDigits(currencyCode);
            pattern.maxFrac = pattern.minFrac;
            const res = formatNumberToLocaleString(value, pattern, locale, NumberSymbol.CurrencyGroup, NumberSymbol.CurrencyDecimal, digitsInfo);
            return res.replace(CURRENCY_CHAR, currency).replace(CURRENCY_CHAR, "").trim();
        }
        function formatPercent(value, locale, digitsInfo) {
            const format = getLocaleNumberFormat(locale, NumberFormatStyle.Percent);
            const pattern = parseNumberFormat(format, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));
            const res = formatNumberToLocaleString(value, pattern, locale, NumberSymbol.Group, NumberSymbol.Decimal, digitsInfo, true);
            return res.replace(new RegExp(PERCENT_CHAR, "g"), getLocaleNumberSymbol(locale, NumberSymbol.PercentSign));
        }
        function formatNumber(value, locale, digitsInfo) {
            const format = getLocaleNumberFormat(locale, NumberFormatStyle.Decimal);
            const pattern = parseNumberFormat(format, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));
            return formatNumberToLocaleString(value, pattern, locale, NumberSymbol.Group, NumberSymbol.Decimal, digitsInfo);
        }
        function parseNumberFormat(format, minusSign = "-") {
            const p = {
                minInt: 1,
                minFrac: 0,
                maxFrac: 0,
                posPre: "",
                posSuf: "",
                negPre: "",
                negSuf: "",
                gSize: 0,
                lgSize: 0
            };
            const patternParts = format.split(PATTERN_SEP);
            const positive = patternParts[0];
            const negative = patternParts[1];
            const positiveParts = positive.indexOf(DECIMAL_SEP) !== -1 ? positive.split(DECIMAL_SEP) : [ positive.substring(0, positive.lastIndexOf(ZERO_CHAR) + 1), positive.substring(positive.lastIndexOf(ZERO_CHAR) + 1) ], integer = positiveParts[0], fraction = positiveParts[1] || "";
            p.posPre = integer.substring(0, integer.indexOf(DIGIT_CHAR));
            for (let i = 0; i < fraction.length; i++) {
                const ch = fraction.charAt(i);
                if (ch === ZERO_CHAR) {
                    p.minFrac = p.maxFrac = i + 1;
                } else if (ch === DIGIT_CHAR) {
                    p.maxFrac = i + 1;
                } else {
                    p.posSuf += ch;
                }
            }
            const groups = integer.split(GROUP_SEP);
            p.gSize = groups[1] ? groups[1].length : 0;
            p.lgSize = groups[2] || groups[1] ? (groups[2] || groups[1]).length : 0;
            if (negative) {
                const trunkLen = positive.length - p.posPre.length - p.posSuf.length, pos = negative.indexOf(DIGIT_CHAR);
                p.negPre = negative.substring(0, pos).replace(/'/g, "");
                p.negSuf = negative.slice(pos + trunkLen).replace(/'/g, "");
            } else {
                p.negPre = minusSign + p.posPre;
                p.negSuf = p.posSuf;
            }
            return p;
        }
        function toPercent(parsedNumber) {
            if (parsedNumber.digits[0] === 0) {
                return parsedNumber;
            }
            const fractionLen = parsedNumber.digits.length - parsedNumber.integerLen;
            if (parsedNumber.exponent) {
                parsedNumber.exponent += 2;
            } else {
                if (fractionLen === 0) {
                    parsedNumber.digits.push(0, 0);
                } else if (fractionLen === 1) {
                    parsedNumber.digits.push(0);
                }
                parsedNumber.integerLen += 2;
            }
            return parsedNumber;
        }
        function parseNumber(num) {
            let numStr = Math.abs(num) + "";
            let exponent = 0, digits, integerLen;
            let i, j, zeros;
            if ((integerLen = numStr.indexOf(DECIMAL_SEP)) > -1) {
                numStr = numStr.replace(DECIMAL_SEP, "");
            }
            if ((i = numStr.search(/e/i)) > 0) {
                if (integerLen < 0) {
                    integerLen = i;
                }
                integerLen += +numStr.slice(i + 1);
                numStr = numStr.substring(0, i);
            } else if (integerLen < 0) {
                integerLen = numStr.length;
            }
            for (i = 0; numStr.charAt(i) === ZERO_CHAR; i++) {}
            if (i === (zeros = numStr.length)) {
                digits = [ 0 ];
                integerLen = 1;
            } else {
                zeros--;
                while (numStr.charAt(zeros) === ZERO_CHAR) {
                    zeros--;
                }
                integerLen -= i;
                digits = [];
                for (j = 0; i <= zeros; i++, j++) {
                    digits[j] = Number(numStr.charAt(i));
                }
            }
            if (integerLen > MAX_DIGITS) {
                digits = digits.splice(0, MAX_DIGITS - 1);
                exponent = integerLen - 1;
                integerLen = 1;
            }
            return {
                digits,
                exponent,
                integerLen
            };
        }
        function roundNumber(parsedNumber, minFrac, maxFrac) {
            if (minFrac > maxFrac) {
                throw new Error(`The minimum number of digits after fraction (${minFrac}) is higher than the maximum (${maxFrac}).`);
            }
            let digits = parsedNumber.digits;
            let fractionLen = digits.length - parsedNumber.integerLen;
            const fractionSize = Math.min(Math.max(minFrac, fractionLen), maxFrac);
            let roundAt = fractionSize + parsedNumber.integerLen;
            let digit = digits[roundAt];
            if (roundAt > 0) {
                digits.splice(Math.max(parsedNumber.integerLen, roundAt));
                for (let j = roundAt; j < digits.length; j++) {
                    digits[j] = 0;
                }
            } else {
                fractionLen = Math.max(0, fractionLen);
                parsedNumber.integerLen = 1;
                digits.length = Math.max(1, roundAt = fractionSize + 1);
                digits[0] = 0;
                for (let i = 1; i < roundAt; i++) {
                    digits[i] = 0;
                }
            }
            if (digit >= 5) {
                if (roundAt - 1 < 0) {
                    for (let k = 0; k > roundAt; k--) {
                        digits.unshift(0);
                        parsedNumber.integerLen++;
                    }
                    digits.unshift(1);
                    parsedNumber.integerLen++;
                } else {
                    digits[roundAt - 1]++;
                }
            }
            for (;fractionLen < Math.max(0, fractionSize); fractionLen++) {
                digits.push(0);
            }
            let dropTrailingZeros = fractionSize !== 0;
            const minLen = minFrac + parsedNumber.integerLen;
            const carry = digits.reduceRight(function(carry2, d, i, digits2) {
                d = d + carry2;
                digits2[i] = d < 10 ? d : d - 10;
                if (dropTrailingZeros) {
                    if (digits2[i] === 0 && i >= minLen) {
                        digits2.pop();
                    } else {
                        dropTrailingZeros = false;
                    }
                }
                return d >= 10 ? 1 : 0;
            }, 0);
            if (carry) {
                digits.unshift(carry);
                parsedNumber.integerLen++;
            }
        }
        function parseIntAutoRadix(text) {
            const result = parseInt(text);
            if (isNaN(result)) {
                throw new Error("Invalid integer literal when parsing " + text);
            }
            return result;
        }
        let NgLocalization = (() => {
            class NgLocalization2 {}
            NgLocalization2.fac = function NgLocalization_Factory(t) {
                return new (t || NgLocalization2);
            };
            NgLocalization2.prov = defineInjectable({
                token: NgLocalization2,
                factory: function NgLocalization_Factory(t) {
                    let r = null;
                    if (t) {
                        r = new t;
                    } else {
                        r = (locale => new NgLocaleLocalization(locale))(core_inject(LOCALE_ID));
                    }
                    return r;
                },
                providedIn: "root"
            });
            return NgLocalization2;
        })();
        (function() {})();
        function getPluralCategory(value, cases, ngLocalization, locale) {
            let key = `=${value}`;
            if (cases.indexOf(key) > -1) {
                return key;
            }
            key = ngLocalization.getPluralCategory(value, locale);
            if (cases.indexOf(key) > -1) {
                return key;
            }
            if (cases.indexOf("other") > -1) {
                return "other";
            }
            throw new Error(`No plural message found for value "${value}"`);
        }
        let NgLocaleLocalization = (() => {
            class NgLocaleLocalization2 extends NgLocalization {
                constructor(locale) {
                    super();
                    this.locale = locale;
                }
                getPluralCategory(value, locale) {
                    const plural2 = common_getLocalePluralCase(locale || this.locale)(value);
                    switch (plural2) {
                      case Plural.Zero:
                        return "zero";

                      case Plural.One:
                        return "one";

                      case Plural.Two:
                        return "two";

                      case Plural.Few:
                        return "few";

                      case Plural.Many:
                        return "many";

                      default:
                        return "other";
                    }
                }
            }
            NgLocaleLocalization2.fac = function NgLocaleLocalization_Factory(t) {
                return new (t || NgLocaleLocalization2)(core_inject(LOCALE_ID));
            };
            NgLocaleLocalization2.prov = defineInjectable({
                token: NgLocaleLocalization2,
                factory: NgLocaleLocalization2.fac
            });
            return NgLocaleLocalization2;
        })();
        (function() {})();
        function common_registerLocaleData(data, localeId, extraData) {
            return registerLocaleData(data, localeId, extraData);
        }
        function parseCookieValue(cookieStr, name) {
            name = encodeURIComponent(name);
            for (const cookie of cookieStr.split(";")) {
                const eqIndex = cookie.indexOf("=");
                const [cookieName, cookieValue] = eqIndex == -1 ? [ cookie, "" ] : [ cookie.slice(0, eqIndex), cookie.slice(eqIndex + 1) ];
                if (cookieName.trim() === name) {
                    return decodeURIComponent(cookieValue);
                }
            }
            return null;
        }
        let NgClass = (() => {
            class NgClass2 {
                constructor(_iterableDiffers, _keyValueDiffers, _ngEl, _renderer) {
                    this._iterableDiffers = _iterableDiffers;
                    this._keyValueDiffers = _keyValueDiffers;
                    this._ngEl = _ngEl;
                    this._renderer = _renderer;
                    this._iterableDiffer = null;
                    this._keyValueDiffer = null;
                    this._initialClasses = [];
                    this._rawClass = null;
                }
                set klass(value) {
                    this._removeClasses(this._initialClasses);
                    this._initialClasses = typeof value === "string" ? value.split(/\s+/) : [];
                    this._applyClasses(this._initialClasses);
                    this._applyClasses(this._rawClass);
                }
                set ngClass(value) {
                    this._removeClasses(this._rawClass);
                    this._applyClasses(this._initialClasses);
                    this._iterableDiffer = null;
                    this._keyValueDiffer = null;
                    this._rawClass = typeof value === "string" ? value.split(/\s+/) : value;
                    if (this._rawClass) {
                        if (isListLikeIterable(this._rawClass)) {
                            this._iterableDiffer = this._iterableDiffers.find(this._rawClass).create();
                        } else {
                            this._keyValueDiffer = this._keyValueDiffers.find(this._rawClass).create();
                        }
                    }
                }
                ngDoCheck() {
                    if (this._iterableDiffer) {
                        const iterableChanges = this._iterableDiffer.diff(this._rawClass);
                        if (iterableChanges) {
                            this._applyIterableChanges(iterableChanges);
                        }
                    } else if (this._keyValueDiffer) {
                        const keyValueChanges = this._keyValueDiffer.diff(this._rawClass);
                        if (keyValueChanges) {
                            this._applyKeyValueChanges(keyValueChanges);
                        }
                    }
                }
                _applyKeyValueChanges(changes) {
                    changes.forEachAddedItem(record => this._toggleClass(record.key, record.currentValue));
                    changes.forEachChangedItem(record => this._toggleClass(record.key, record.currentValue));
                    changes.forEachRemovedItem(record => {
                        if (record.previousValue) {
                            this._toggleClass(record.key, false);
                        }
                    });
                }
                _applyIterableChanges(changes) {
                    changes.forEachAddedItem(record => {
                        if (typeof record.item === "string") {
                            this._toggleClass(record.item, true);
                        } else {
                            throw new Error(`NgClass can only toggle CSS classes expressed as strings, got ${stringify(record.item)}`);
                        }
                    });
                    changes.forEachRemovedItem(record => this._toggleClass(record.item, false));
                }
                _applyClasses(rawClassVal) {
                    if (rawClassVal) {
                        if (Array.isArray(rawClassVal) || rawClassVal instanceof Set) {
                            rawClassVal.forEach(klass => this._toggleClass(klass, true));
                        } else {
                            Object.keys(rawClassVal).forEach(klass => this._toggleClass(klass, !!rawClassVal[klass]));
                        }
                    }
                }
                _removeClasses(rawClassVal) {
                    if (rawClassVal) {
                        if (Array.isArray(rawClassVal) || rawClassVal instanceof Set) {
                            rawClassVal.forEach(klass => this._toggleClass(klass, false));
                        } else {
                            Object.keys(rawClassVal).forEach(klass => this._toggleClass(klass, false));
                        }
                    }
                }
                _toggleClass(klass, enabled) {
                    klass = klass.trim();
                    if (klass) {
                        klass.split(/\s+/g).forEach(klass2 => {
                            if (enabled) {
                                this._renderer.addClass(this._ngEl.nativeElement, klass2);
                            } else {
                                this._renderer.removeClass(this._ngEl.nativeElement, klass2);
                            }
                        });
                    }
                }
            }
            NgClass2.fac = function NgClass_Factory(t) {
                return new (t || NgClass2)(directiveInject(IterableDiffers), directiveInject(KeyValueDiffers), directiveInject(core_ElementRef), directiveInject(core_Renderer2));
            };
            NgClass2.dir = defineDirective({
                type: NgClass2,
                selectors: [ [ "", "ngClass", "" ] ],
                inputs: {
                    klass: [ "class", "klass" ],
                    ngClass: "ngClass"
                },
                standalone: true
            });
            return NgClass2;
        })();
        (function() {})();
        let NgComponentOutlet = (() => {
            class NgComponentOutlet2 {
                constructor(_viewContainerRef) {
                    this._viewContainerRef = _viewContainerRef;
                    this.ngComponentOutlet = null;
                }
                ngOnChanges(changes) {
                    const {_viewContainerRef: viewContainerRef, ngComponentOutletNgModule: ngModule, ngComponentOutletNgModuleFactory: ngModuleFactory} = this;
                    viewContainerRef.clear();
                    this._componentRef = void 0;
                    if (this.ngComponentOutlet) {
                        const injector = this.ngComponentOutletInjector || viewContainerRef.parentInjector;
                        if (changes["ngComponentOutletNgModule"] || changes["ngComponentOutletNgModuleFactory"]) {
                            if (this._moduleRef) {
                                this._moduleRef.destroy();
                            }
                            if (ngModule) {
                                this._moduleRef = createNgModule(ngModule, getParentInjector(injector));
                            } else if (ngModuleFactory) {
                                this._moduleRef = ngModuleFactory.create(getParentInjector(injector));
                            } else {
                                this._moduleRef = void 0;
                            }
                        }
                        this._componentRef = viewContainerRef.createComponent(this.ngComponentOutlet, {
                            index: viewContainerRef.length,
                            injector,
                            ngModuleRef: this._moduleRef,
                            projectableNodes: this.ngComponentOutletContent
                        });
                    }
                }
                ngOnDestroy() {
                    if (this._moduleRef) {
                        this._moduleRef.destroy();
                    }
                }
            }
            NgComponentOutlet2.fac = function NgComponentOutlet_Factory(t) {
                return new (t || NgComponentOutlet2)(directiveInject(ViewContainerRef));
            };
            NgComponentOutlet2.dir = defineDirective({
                type: NgComponentOutlet2,
                selectors: [ [ "", "ngComponentOutlet", "" ] ],
                inputs: {
                    ngComponentOutlet: "ngComponentOutlet",
                    ngComponentOutletInjector: "ngComponentOutletInjector",
                    ngComponentOutletContent: "ngComponentOutletContent",
                    ngComponentOutletNgModule: "ngComponentOutletNgModule",
                    ngComponentOutletNgModuleFactory: "ngComponentOutletNgModuleFactory"
                },
                standalone: true,
                features: [ NgOnChangesFeature ]
            });
            return NgComponentOutlet2;
        })();
        (function() {})();
        function getParentInjector(injector) {
            const parentNgModule = injector.get(NgModuleRef$1);
            return parentNgModule.injector;
        }
        const common_NG_DEV_MODE = false;
        class NgForOfContext {
            constructor($implicit, ngForOf, index, count) {
                this.$implicit = $implicit;
                this.ngForOf = ngForOf;
                this.index = index;
                this.count = count;
            }
            get first() {
                return this.index === 0;
            }
            get last() {
                return this.index === this.count - 1;
            }
            get even() {
                return this.index % 2 === 0;
            }
            get odd() {
                return !this.even;
            }
        }
        let NgForOf = (() => {
            class NgForOf2 {
                constructor(_viewContainer, _template, _differs) {
                    this._viewContainer = _viewContainer;
                    this._template = _template;
                    this._differs = _differs;
                    this._ngForOf = null;
                    this._ngForOfDirty = true;
                    this._differ = null;
                }
                set ngForOf(ngForOf) {
                    this._ngForOf = ngForOf;
                    this._ngForOfDirty = true;
                }
                set ngForTrackBy(fn) {
                    if (common_NG_DEV_MODE && fn != null && typeof fn !== "function") {
                        if (console && console.warn) {
                            console.warn(`trackBy must be a function, but received ${JSON.stringify(fn)}. See https://angular.io/api/common/NgForOf#change-propagation for more information.`);
                        }
                    }
                    this._trackByFn = fn;
                }
                get ngForTrackBy() {
                    return this._trackByFn;
                }
                set ngForTemplate(value) {
                    if (value) {
                        this._template = value;
                    }
                }
                ngDoCheck() {
                    if (this._ngForOfDirty) {
                        this._ngForOfDirty = false;
                        const value = this._ngForOf;
                        if (!this._differ && value) {
                            if (common_NG_DEV_MODE) {
                                try {
                                    this._differ = this._differs.find(value).create(this.ngForTrackBy);
                                } catch {
                                    let errorMessage = `Cannot find a differ supporting object '${value}' of type '${common_getTypeName(value)}'. NgFor only supports binding to Iterables, such as Arrays.`;
                                    if (typeof value === "object") {
                                        errorMessage += " Did you mean to use the keyvalue pipe?";
                                    }
                                    throw new RuntimeError(-2200, errorMessage);
                                }
                            } else {
                                this._differ = this._differs.find(value).create(this.ngForTrackBy);
                            }
                        }
                    }
                    if (this._differ) {
                        const changes = this._differ.diff(this._ngForOf);
                        if (changes) {
                            this._applyChanges(changes);
                        }
                    }
                }
                _applyChanges(changes) {
                    const viewContainer = this._viewContainer;
                    changes.forEachOperation((item, adjustedPreviousIndex, currentIndex) => {
                        if (item.previousIndex == null) {
                            viewContainer.createEmbeddedView(this._template, new NgForOfContext(item.item, this._ngForOf, -1, -1), currentIndex === null ? void 0 : currentIndex);
                        } else if (currentIndex == null) {
                            viewContainer.remove(adjustedPreviousIndex === null ? void 0 : adjustedPreviousIndex);
                        } else if (adjustedPreviousIndex !== null) {
                            const view = viewContainer.get(adjustedPreviousIndex);
                            viewContainer.move(view, currentIndex);
                            applyViewChange(view, item);
                        }
                    });
                    for (let i = 0, ilen = viewContainer.length; i < ilen; i++) {
                        const viewRef = viewContainer.get(i);
                        const context2 = viewRef.context;
                        context2.index = i;
                        context2.count = ilen;
                        context2.ngForOf = this._ngForOf;
                    }
                    changes.forEachIdentityChange(record => {
                        const viewRef = viewContainer.get(record.currentIndex);
                        applyViewChange(viewRef, record);
                    });
                }
                static ngTemplateContextGuard(dir, ctx) {
                    return true;
                }
            }
            NgForOf2.fac = function NgForOf_Factory(t) {
                return new (t || NgForOf2)(directiveInject(ViewContainerRef), directiveInject(TemplateRef), directiveInject(IterableDiffers));
            };
            NgForOf2.dir = defineDirective({
                type: NgForOf2,
                selectors: [ [ "", "ngFor", "", "ngForOf", "" ] ],
                inputs: {
                    ngForOf: "ngForOf",
                    ngForTrackBy: "ngForTrackBy",
                    ngForTemplate: "ngForTemplate"
                },
                standalone: true
            });
            return NgForOf2;
        })();
        (function() {})();
        function applyViewChange(view, record) {
            view.context.$implicit = record.item;
        }
        function common_getTypeName(type) {
            return type["name"] || typeof type;
        }
        let NgIf = (() => {
            class NgIf2 {
                constructor(_viewContainer, templateRef) {
                    this._viewContainer = _viewContainer;
                    this._context = new NgIfContext;
                    this._thenTemplateRef = null;
                    this._elseTemplateRef = null;
                    this._thenViewRef = null;
                    this._elseViewRef = null;
                    this._thenTemplateRef = templateRef;
                }
                set ngIf(condition) {
                    this._context.$implicit = this._context.ngIf = condition;
                    this._updateView();
                }
                set ngIfThen(templateRef) {
                    assertTemplate("ngIfThen", templateRef);
                    this._thenTemplateRef = templateRef;
                    this._thenViewRef = null;
                    this._updateView();
                }
                set ngIfElse(templateRef) {
                    assertTemplate("ngIfElse", templateRef);
                    this._elseTemplateRef = templateRef;
                    this._elseViewRef = null;
                    this._updateView();
                }
                _updateView() {
                    if (this._context.$implicit) {
                        if (!this._thenViewRef) {
                            this._viewContainer.clear();
                            this._elseViewRef = null;
                            if (this._thenTemplateRef) {
                                this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context);
                            }
                        }
                    } else {
                        if (!this._elseViewRef) {
                            this._viewContainer.clear();
                            this._thenViewRef = null;
                            if (this._elseTemplateRef) {
                                this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context);
                            }
                        }
                    }
                }
                static ngTemplateContextGuard(dir, ctx) {
                    return true;
                }
            }
            NgIf2.fac = function NgIf_Factory(t) {
                return new (t || NgIf2)(directiveInject(ViewContainerRef), directiveInject(TemplateRef));
            };
            NgIf2.dir = defineDirective({
                type: NgIf2,
                selectors: [ [ "", "ngIf", "" ] ],
                inputs: {
                    ngIf: "ngIf",
                    ngIfThen: "ngIfThen",
                    ngIfElse: "ngIfElse"
                },
                standalone: true
            });
            return NgIf2;
        })();
        (function() {})();
        class NgIfContext {
            constructor() {
                this.$implicit = null;
                this.ngIf = null;
            }
        }
        function assertTemplate(property, templateRef) {
            const isTemplateRefOrNull = !!(!templateRef || templateRef.createEmbeddedView);
            if (!isTemplateRefOrNull) {
                throw new Error(`${property} must be a TemplateRef, but received '${stringify(templateRef)}'.`);
            }
        }
        class SwitchView {
            constructor(_viewContainerRef, _templateRef) {
                this._viewContainerRef = _viewContainerRef;
                this._templateRef = _templateRef;
                this._created = false;
            }
            create() {
                this._created = true;
                this._viewContainerRef.createEmbeddedView(this._templateRef);
            }
            destroy() {
                this._created = false;
                this._viewContainerRef.clear();
            }
            enforceState(created) {
                if (created && !this._created) {
                    this.create();
                } else if (!created && this._created) {
                    this.destroy();
                }
            }
        }
        let NgSwitch = (() => {
            class NgSwitch2 {
                constructor() {
                    this._defaultUsed = false;
                    this._caseCount = 0;
                    this._lastCaseCheckIndex = 0;
                    this._lastCasesMatched = false;
                }
                set ngSwitch(newValue) {
                    this._ngSwitch = newValue;
                    if (this._caseCount === 0) {
                        this._updateDefaultCases(true);
                    }
                }
                _addCase() {
                    return this._caseCount++;
                }
                _addDefault(view) {
                    if (!this._defaultViews) {
                        this._defaultViews = [];
                    }
                    this._defaultViews.push(view);
                }
                _matchCase(value) {
                    const matched = value == this._ngSwitch;
                    this._lastCasesMatched = this._lastCasesMatched || matched;
                    this._lastCaseCheckIndex++;
                    if (this._lastCaseCheckIndex === this._caseCount) {
                        this._updateDefaultCases(!this._lastCasesMatched);
                        this._lastCaseCheckIndex = 0;
                        this._lastCasesMatched = false;
                    }
                    return matched;
                }
                _updateDefaultCases(useDefault) {
                    if (this._defaultViews && useDefault !== this._defaultUsed) {
                        this._defaultUsed = useDefault;
                        for (let i = 0; i < this._defaultViews.length; i++) {
                            const defaultView = this._defaultViews[i];
                            defaultView.enforceState(useDefault);
                        }
                    }
                }
            }
            NgSwitch2.fac = function NgSwitch_Factory(t) {
                return new (t || NgSwitch2);
            };
            NgSwitch2.dir = defineDirective({
                type: NgSwitch2,
                selectors: [ [ "", "ngSwitch", "" ] ],
                inputs: {
                    ngSwitch: "ngSwitch"
                },
                standalone: true
            });
            return NgSwitch2;
        })();
        (function() {})();
        let NgSwitchCase = (() => {
            class NgSwitchCase2 {
                constructor(viewContainer, templateRef, ngSwitch) {
                    this.ngSwitch = ngSwitch;
                    if (false) {
                        throwNgSwitchProviderNotFoundError("ngSwitchCase", "NgSwitchCase");
                    }
                    ngSwitch._addCase();
                    this._view = new SwitchView(viewContainer, templateRef);
                }
                ngDoCheck() {
                    this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase));
                }
            }
            NgSwitchCase2.fac = function NgSwitchCase_Factory(t) {
                return new (t || NgSwitchCase2)(directiveInject(ViewContainerRef), directiveInject(TemplateRef), directiveInject(NgSwitch, 9));
            };
            NgSwitchCase2.dir = defineDirective({
                type: NgSwitchCase2,
                selectors: [ [ "", "ngSwitchCase", "" ] ],
                inputs: {
                    ngSwitchCase: "ngSwitchCase"
                },
                standalone: true
            });
            return NgSwitchCase2;
        })();
        (function() {})();
        let NgSwitchDefault = (() => {
            class NgSwitchDefault2 {
                constructor(viewContainer, templateRef, ngSwitch) {
                    if (false) {
                        throwNgSwitchProviderNotFoundError("ngSwitchDefault", "NgSwitchDefault");
                    }
                    ngSwitch._addDefault(new SwitchView(viewContainer, templateRef));
                }
            }
            NgSwitchDefault2.fac = function NgSwitchDefault_Factory(t) {
                return new (t || NgSwitchDefault2)(directiveInject(ViewContainerRef), directiveInject(TemplateRef), directiveInject(NgSwitch, 9));
            };
            NgSwitchDefault2.dir = defineDirective({
                type: NgSwitchDefault2,
                selectors: [ [ "", "ngSwitchDefault", "" ] ],
                standalone: true
            });
            return NgSwitchDefault2;
        })();
        (function() {})();
        function throwNgSwitchProviderNotFoundError(attrName, directiveName) {
            throw new RuntimeError(2e3, `An element with the "${attrName}" attribute (matching the "${directiveName}" directive) must be located inside an element with the "ngSwitch" attribute (matching "NgSwitch" directive)`);
        }
        let NgPlural = (() => {
            class NgPlural2 {
                constructor(_localization) {
                    this._localization = _localization;
                    this._caseViews = {};
                }
                set ngPlural(value) {
                    this._switchValue = value;
                    this._updateView();
                }
                addCase(value, switchView) {
                    this._caseViews[value] = switchView;
                }
                _updateView() {
                    this._clearViews();
                    const cases = Object.keys(this._caseViews);
                    const key = getPluralCategory(this._switchValue, cases, this._localization);
                    this._activateView(this._caseViews[key]);
                }
                _clearViews() {
                    if (this._activeView) {
                        this._activeView.destroy();
                    }
                }
                _activateView(view) {
                    if (view) {
                        this._activeView = view;
                        this._activeView.create();
                    }
                }
            }
            NgPlural2.fac = function NgPlural_Factory(t) {
                return new (t || NgPlural2)(directiveInject(NgLocalization));
            };
            NgPlural2.dir = defineDirective({
                type: NgPlural2,
                selectors: [ [ "", "ngPlural", "" ] ],
                inputs: {
                    ngPlural: "ngPlural"
                },
                standalone: true
            });
            return NgPlural2;
        })();
        (function() {})();
        let NgPluralCase = (() => {
            class NgPluralCase2 {
                constructor(value, template, viewContainer, ngPlural) {
                    this.value = value;
                    const isANumber = !isNaN(Number(value));
                    ngPlural.addCase(isANumber ? `=${value}` : value, new SwitchView(viewContainer, template));
                }
            }
            NgPluralCase2.fac = function NgPluralCase_Factory(t) {
                return new (t || NgPluralCase2)(injectAttribute("ngPluralCase"), directiveInject(TemplateRef), directiveInject(ViewContainerRef), directiveInject(NgPlural, 1));
            };
            NgPluralCase2.dir = defineDirective({
                type: NgPluralCase2,
                selectors: [ [ "", "ngPluralCase", "" ] ],
                standalone: true
            });
            return NgPluralCase2;
        })();
        (function() {})();
        let NgStyle = (() => {
            class NgStyle2 {
                constructor(_ngEl, _differs, _renderer) {
                    this._ngEl = _ngEl;
                    this._differs = _differs;
                    this._renderer = _renderer;
                    this._ngStyle = null;
                    this._differ = null;
                }
                set ngStyle(values) {
                    this._ngStyle = values;
                    if (!this._differ && values) {
                        this._differ = this._differs.find(values).create();
                    }
                }
                ngDoCheck() {
                    if (this._differ) {
                        const changes = this._differ.diff(this._ngStyle);
                        if (changes) {
                            this._applyChanges(changes);
                        }
                    }
                }
                _setStyle(nameAndUnit, value) {
                    const [name, unit] = nameAndUnit.split(".");
                    const flags = name.indexOf("-") === -1 ? void 0 : RendererStyleFlags2.DashCase;
                    if (value != null) {
                        this._renderer.setStyle(this._ngEl.nativeElement, name, unit ? `${value}${unit}` : value, flags);
                    } else {
                        this._renderer.removeStyle(this._ngEl.nativeElement, name, flags);
                    }
                }
                _applyChanges(changes) {
                    changes.forEachRemovedItem(record => this._setStyle(record.key, null));
                    changes.forEachAddedItem(record => this._setStyle(record.key, record.currentValue));
                    changes.forEachChangedItem(record => this._setStyle(record.key, record.currentValue));
                }
            }
            NgStyle2.fac = function NgStyle_Factory(t) {
                return new (t || NgStyle2)(directiveInject(core_ElementRef), directiveInject(KeyValueDiffers), directiveInject(core_Renderer2));
            };
            NgStyle2.dir = defineDirective({
                type: NgStyle2,
                selectors: [ [ "", "ngStyle", "" ] ],
                inputs: {
                    ngStyle: "ngStyle"
                },
                standalone: true
            });
            return NgStyle2;
        })();
        (function() {})();
        let NgTemplateOutlet = (() => {
            class NgTemplateOutlet2 {
                constructor(_viewContainerRef) {
                    this._viewContainerRef = _viewContainerRef;
                    this._viewRef = null;
                    this.ngTemplateOutletContext = null;
                    this.ngTemplateOutlet = null;
                    this.ngTemplateOutletInjector = null;
                }
                ngOnChanges(changes) {
                    if (changes["ngTemplateOutlet"] || changes["ngTemplateOutletInjector"]) {
                        const viewContainerRef = this._viewContainerRef;
                        if (this._viewRef) {
                            viewContainerRef.remove(viewContainerRef.indexOf(this._viewRef));
                        }
                        if (this.ngTemplateOutlet) {
                            const {ngTemplateOutlet: template, ngTemplateOutletContext: context2, ngTemplateOutletInjector: injector} = this;
                            this._viewRef = viewContainerRef.createEmbeddedView(template, context2, injector ? {
                                injector
                            } : void 0);
                        } else {
                            this._viewRef = null;
                        }
                    } else if (this._viewRef && changes["ngTemplateOutletContext"] && this.ngTemplateOutletContext) {
                        this._viewRef.context = this.ngTemplateOutletContext;
                    }
                }
            }
            NgTemplateOutlet2.fac = function NgTemplateOutlet_Factory(t) {
                return new (t || NgTemplateOutlet2)(directiveInject(ViewContainerRef));
            };
            NgTemplateOutlet2.dir = defineDirective({
                type: NgTemplateOutlet2,
                selectors: [ [ "", "ngTemplateOutlet", "" ] ],
                inputs: {
                    ngTemplateOutletContext: "ngTemplateOutletContext",
                    ngTemplateOutlet: "ngTemplateOutlet",
                    ngTemplateOutletInjector: "ngTemplateOutletInjector"
                },
                standalone: true,
                features: [ NgOnChangesFeature ]
            });
            return NgTemplateOutlet2;
        })();
        (function() {})();
        const COMMON_DIRECTIVES = [ NgClass, NgComponentOutlet, NgForOf, NgIf, NgTemplateOutlet, NgStyle, NgSwitch, NgSwitchCase, NgSwitchDefault, NgPlural, NgPluralCase ];
        function invalidPipeArgumentError(type, value) {
            return new RuntimeError(2100, false);
        }
        class SubscribableStrategy {
            createSubscription(async, updateLatestValue) {
                return async.subscribe({
                    next: updateLatestValue,
                    error: e => {
                        throw e;
                    }
                });
            }
            dispose(subscription) {
                subscription.unsubscribe();
            }
        }
        class PromiseStrategy {
            createSubscription(async, updateLatestValue) {
                return async.then(updateLatestValue, e => {
                    throw e;
                });
            }
            dispose(subscription) {}
        }
        const _promiseStrategy = new PromiseStrategy;
        const _subscribableStrategy = new SubscribableStrategy;
        let AsyncPipe = (() => {
            class AsyncPipe2 {
                constructor(ref) {
                    this._latestValue = null;
                    this._subscription = null;
                    this._obj = null;
                    this._strategy = null;
                    this._ref = ref;
                }
                ngOnDestroy() {
                    if (this._subscription) {
                        this._dispose();
                    }
                    this._ref = null;
                }
                transform(obj) {
                    if (!this._obj) {
                        if (obj) {
                            this._subscribe(obj);
                        }
                        return this._latestValue;
                    }
                    if (obj !== this._obj) {
                        this._dispose();
                        return this.transform(obj);
                    }
                    return this._latestValue;
                }
                _subscribe(obj) {
                    this._obj = obj;
                    this._strategy = this._selectStrategy(obj);
                    this._subscription = this._strategy.createSubscription(obj, value => this._updateLatestValue(obj, value));
                }
                _selectStrategy(obj) {
                    if (core_isPromise(obj)) {
                        return _promiseStrategy;
                    }
                    if (isSubscribable(obj)) {
                        return _subscribableStrategy;
                    }
                    throw invalidPipeArgumentError(AsyncPipe2, obj);
                }
                _dispose() {
                    this._strategy.dispose(this._subscription);
                    this._latestValue = null;
                    this._subscription = null;
                    this._obj = null;
                }
                _updateLatestValue(async, value) {
                    if (async === this._obj) {
                        this._latestValue = value;
                        this._ref.markForCheck();
                    }
                }
            }
            AsyncPipe2.fac = function AsyncPipe_Factory(t) {
                return new (t || AsyncPipe2)(directiveInject(ChangeDetectorRef, 16));
            };
            AsyncPipe2.pipe = definePipe({
                name: "async",
                type: AsyncPipe2,
                pure: false,
                standalone: true
            });
            return AsyncPipe2;
        })();
        (function() {})();
        let LowerCasePipe = (() => {
            class LowerCasePipe2 {
                transform(value) {
                    if (value == null) {
                        return null;
                    }
                    if (typeof value !== "string") {
                        throw invalidPipeArgumentError(LowerCasePipe2, value);
                    }
                    return value.toLowerCase();
                }
            }
            LowerCasePipe2.fac = function LowerCasePipe_Factory(t) {
                return new (t || LowerCasePipe2);
            };
            LowerCasePipe2.pipe = definePipe({
                name: "lowercase",
                type: LowerCasePipe2,
                pure: true,
                standalone: true
            });
            return LowerCasePipe2;
        })();
        (function() {})();
        const unicodeWordMatch = /(?:[0-9A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])\S*/g;
        let TitleCasePipe = (() => {
            class TitleCasePipe2 {
                transform(value) {
                    if (value == null) {
                        return null;
                    }
                    if (typeof value !== "string") {
                        throw invalidPipeArgumentError(TitleCasePipe2, value);
                    }
                    return value.replace(unicodeWordMatch, txt => txt[0].toUpperCase() + txt.slice(1).toLowerCase());
                }
            }
            TitleCasePipe2.fac = function TitleCasePipe_Factory(t) {
                return new (t || TitleCasePipe2);
            };
            TitleCasePipe2.pipe = definePipe({
                name: "titlecase",
                type: TitleCasePipe2,
                pure: true,
                standalone: true
            });
            return TitleCasePipe2;
        })();
        (function() {})();
        let UpperCasePipe = (() => {
            class UpperCasePipe2 {
                transform(value) {
                    if (value == null) {
                        return null;
                    }
                    if (typeof value !== "string") {
                        throw invalidPipeArgumentError(UpperCasePipe2, value);
                    }
                    return value.toUpperCase();
                }
            }
            UpperCasePipe2.fac = function UpperCasePipe_Factory(t) {
                return new (t || UpperCasePipe2);
            };
            UpperCasePipe2.pipe = definePipe({
                name: "uppercase",
                type: UpperCasePipe2,
                pure: true,
                standalone: true
            });
            return UpperCasePipe2;
        })();
        (function() {})();
        const DATE_PIPE_DEFAULT_TIMEZONE = new InjectionToken("DATE_PIPE_DEFAULT_TIMEZONE");
        let DatePipe = (() => {
            class DatePipe2 {
                constructor(locale, defaultTimezone) {
                    this.locale = locale;
                    this.defaultTimezone = defaultTimezone;
                }
                transform(value, format = "mediumDate", timezone, locale) {
                    if (value == null || value === "" || value !== value) {
                        return null;
                    }
                    try {
                        return formatDate(value, format, locale || this.locale, timezone ?? this.defaultTimezone ?? void 0);
                    } catch (error) {
                        throw invalidPipeArgumentError(DatePipe2, error.message);
                    }
                }
            }
            DatePipe2.fac = function DatePipe_Factory(t) {
                return new (t || DatePipe2)(directiveInject(LOCALE_ID, 16), directiveInject(DATE_PIPE_DEFAULT_TIMEZONE, 24));
            };
            DatePipe2.pipe = definePipe({
                name: "date",
                type: DatePipe2,
                pure: true,
                standalone: true
            });
            return DatePipe2;
        })();
        (function() {})();
        const _INTERPOLATION_REGEXP = /#/g;
        let I18nPluralPipe = (() => {
            class I18nPluralPipe2 {
                constructor(_localization) {
                    this._localization = _localization;
                }
                transform(value, pluralMap, locale) {
                    if (value == null) {
                        return "";
                    }
                    if (typeof pluralMap !== "object" || pluralMap === null) {
                        throw invalidPipeArgumentError(I18nPluralPipe2, pluralMap);
                    }
                    const key = getPluralCategory(value, Object.keys(pluralMap), this._localization, locale);
                    return pluralMap[key].replace(_INTERPOLATION_REGEXP, value.toString());
                }
            }
            I18nPluralPipe2.fac = function I18nPluralPipe_Factory(t) {
                return new (t || I18nPluralPipe2)(directiveInject(NgLocalization, 16));
            };
            I18nPluralPipe2.pipe = definePipe({
                name: "i18nPlural",
                type: I18nPluralPipe2,
                pure: true,
                standalone: true
            });
            return I18nPluralPipe2;
        })();
        (function() {})();
        let I18nSelectPipe = (() => {
            class I18nSelectPipe2 {
                transform(value, mapping) {
                    if (value == null) {
                        return "";
                    }
                    if (typeof mapping !== "object" || typeof value !== "string") {
                        throw invalidPipeArgumentError(I18nSelectPipe2, mapping);
                    }
                    if (mapping.hasOwnProperty(value)) {
                        return mapping[value];
                    }
                    if (mapping.hasOwnProperty("other")) {
                        return mapping["other"];
                    }
                    return "";
                }
            }
            I18nSelectPipe2.fac = function I18nSelectPipe_Factory(t) {
                return new (t || I18nSelectPipe2);
            };
            I18nSelectPipe2.pipe = definePipe({
                name: "i18nSelect",
                type: I18nSelectPipe2,
                pure: true,
                standalone: true
            });
            return I18nSelectPipe2;
        })();
        (function() {})();
        let JsonPipe = (() => {
            class JsonPipe2 {
                transform(value) {
                    return JSON.stringify(value, null, 2);
                }
            }
            JsonPipe2.fac = function JsonPipe_Factory(t) {
                return new (t || JsonPipe2);
            };
            JsonPipe2.pipe = definePipe({
                name: "json",
                type: JsonPipe2,
                pure: false,
                standalone: true
            });
            return JsonPipe2;
        })();
        (function() {})();
        function makeKeyValuePair(key, value) {
            return {
                key,
                value
            };
        }
        let KeyValuePipe = (() => {
            class KeyValuePipe2 {
                constructor(differs) {
                    this.differs = differs;
                    this.keyValues = [];
                    this.compareFn = defaultComparator;
                }
                transform(input, compareFn = defaultComparator) {
                    if (!input || !(input instanceof Map) && typeof input !== "object") {
                        return null;
                    }
                    if (!this.differ) {
                        this.differ = this.differs.find(input).create();
                    }
                    const differChanges = this.differ.diff(input);
                    const compareFnChanged = compareFn !== this.compareFn;
                    if (differChanges) {
                        this.keyValues = [];
                        differChanges.forEachItem(r => {
                            this.keyValues.push(makeKeyValuePair(r.key, r.currentValue));
                        });
                    }
                    if (differChanges || compareFnChanged) {
                        this.keyValues.sort(compareFn);
                        this.compareFn = compareFn;
                    }
                    return this.keyValues;
                }
            }
            KeyValuePipe2.fac = function KeyValuePipe_Factory(t) {
                return new (t || KeyValuePipe2)(directiveInject(KeyValueDiffers, 16));
            };
            KeyValuePipe2.pipe = definePipe({
                name: "keyvalue",
                type: KeyValuePipe2,
                pure: false,
                standalone: true
            });
            return KeyValuePipe2;
        })();
        (function() {})();
        function defaultComparator(keyValueA, keyValueB) {
            const a = keyValueA.key;
            const b = keyValueB.key;
            if (a === b) {
                return 0;
            }
            if (a === void 0) {
                return 1;
            }
            if (b === void 0) {
                return -1;
            }
            if (a === null) {
                return 1;
            }
            if (b === null) {
                return -1;
            }
            if (typeof a == "string" && typeof b == "string") {
                return a < b ? -1 : 1;
            }
            if (typeof a == "number" && typeof b == "number") {
                return a - b;
            }
            if (typeof a == "boolean" && typeof b == "boolean") {
                return a < b ? -1 : 1;
            }
            const aString = String(a);
            const bString = String(b);
            return aString == bString ? 0 : aString < bString ? -1 : 1;
        }
        let DecimalPipe = (() => {
            class DecimalPipe2 {
                constructor(_locale) {
                    this._locale = _locale;
                }
                transform(value, digitsInfo, locale) {
                    if (!isValue(value)) {
                        return null;
                    }
                    locale = locale || this._locale;
                    try {
                        const num = strToNumber(value);
                        return formatNumber(num, locale, digitsInfo);
                    } catch (error) {
                        throw invalidPipeArgumentError(DecimalPipe2, error.message);
                    }
                }
            }
            DecimalPipe2.fac = function DecimalPipe_Factory(t) {
                return new (t || DecimalPipe2)(directiveInject(LOCALE_ID, 16));
            };
            DecimalPipe2.pipe = definePipe({
                name: "number",
                type: DecimalPipe2,
                pure: true,
                standalone: true
            });
            return DecimalPipe2;
        })();
        (function() {})();
        let PercentPipe = (() => {
            class PercentPipe2 {
                constructor(_locale) {
                    this._locale = _locale;
                }
                transform(value, digitsInfo, locale) {
                    if (!isValue(value)) {
                        return null;
                    }
                    locale = locale || this._locale;
                    try {
                        const num = strToNumber(value);
                        return formatPercent(num, locale, digitsInfo);
                    } catch (error) {
                        throw invalidPipeArgumentError(PercentPipe2, error.message);
                    }
                }
            }
            PercentPipe2.fac = function PercentPipe_Factory(t) {
                return new (t || PercentPipe2)(directiveInject(LOCALE_ID, 16));
            };
            PercentPipe2.pipe = definePipe({
                name: "percent",
                type: PercentPipe2,
                pure: true,
                standalone: true
            });
            return PercentPipe2;
        })();
        (function() {})();
        let CurrencyPipe = (() => {
            class CurrencyPipe2 {
                constructor(_locale, _defaultCurrencyCode = "USD") {
                    this._locale = _locale;
                    this._defaultCurrencyCode = _defaultCurrencyCode;
                }
                transform(value, currencyCode = this._defaultCurrencyCode, display = "symbol", digitsInfo, locale) {
                    if (!isValue(value)) {
                        return null;
                    }
                    locale = locale || this._locale;
                    if (typeof display === "boolean") {
                        if (false) {
                            console.warn(`Warning: the currency pipe has been changed in Angular v5. The symbolDisplay option (third parameter) is now a string instead of a boolean. The accepted values are "code", "symbol" or "symbol-narrow".`);
                        }
                        display = display ? "symbol" : "code";
                    }
                    let currency = currencyCode || this._defaultCurrencyCode;
                    if (display !== "code") {
                        if (display === "symbol" || display === "symbol-narrow") {
                            currency = getCurrencySymbol(currency, display === "symbol" ? "wide" : "narrow", locale);
                        } else {
                            currency = display;
                        }
                    }
                    try {
                        const num = strToNumber(value);
                        return formatCurrency(num, locale, currency, currencyCode, digitsInfo);
                    } catch (error) {
                        throw invalidPipeArgumentError(CurrencyPipe2, error.message);
                    }
                }
            }
            CurrencyPipe2.fac = function CurrencyPipe_Factory(t) {
                return new (t || CurrencyPipe2)(directiveInject(LOCALE_ID, 16), directiveInject(DEFAULT_CURRENCY_CODE, 16));
            };
            CurrencyPipe2.pipe = definePipe({
                name: "currency",
                type: CurrencyPipe2,
                pure: true,
                standalone: true
            });
            return CurrencyPipe2;
        })();
        (function() {})();
        function isValue(value) {
            return !(value == null || value === "" || value !== value);
        }
        function strToNumber(value) {
            if (typeof value === "string" && !isNaN(Number(value) - parseFloat(value))) {
                return Number(value);
            }
            if (typeof value !== "number") {
                throw new Error(`${value} is not a number`);
            }
            return value;
        }
        let SlicePipe = (() => {
            class SlicePipe2 {
                transform(value, start, end) {
                    if (value == null) {
                        return null;
                    }
                    if (!this.supports(value)) {
                        throw invalidPipeArgumentError(SlicePipe2, value);
                    }
                    return value.slice(start, end);
                }
                supports(obj) {
                    return typeof obj === "string" || Array.isArray(obj);
                }
            }
            SlicePipe2.fac = function SlicePipe_Factory(t) {
                return new (t || SlicePipe2);
            };
            SlicePipe2.pipe = definePipe({
                name: "slice",
                type: SlicePipe2,
                pure: false,
                standalone: true
            });
            return SlicePipe2;
        })();
        (function() {})();
        const COMMON_PIPES = [ AsyncPipe, UpperCasePipe, LowerCasePipe, JsonPipe, SlicePipe, DecimalPipe, PercentPipe, TitleCasePipe, CurrencyPipe, DatePipe, I18nPluralPipe, I18nSelectPipe, KeyValuePipe ];
        let CommonModule = (() => {
            class CommonModule2 {}
            CommonModule2.fac = function CommonModule_Factory(t) {
                return new (t || CommonModule2);
            };
            CommonModule2.mod = defineNgModule({
                type: CommonModule2
            });
            CommonModule2.inj = defineInjector({});
            return CommonModule2;
        })();
        (function() {})();
        const PLATFORM_BROWSER_ID = "browser";
        const PLATFORM_SERVER_ID = "server";
        const PLATFORM_WORKER_APP_ID = "browserWorkerApp";
        const PLATFORM_WORKER_UI_ID = "browserWorkerUi";
        function isPlatformBrowser(platformId) {
            return platformId === PLATFORM_BROWSER_ID;
        }
        function isPlatformServer(platformId) {
            return platformId === PLATFORM_SERVER_ID;
        }
        function isPlatformWorkerApp(platformId) {
            return platformId === PLATFORM_WORKER_APP_ID;
        }
        function isPlatformWorkerUi(platformId) {
            return platformId === PLATFORM_WORKER_UI_ID;
        }
        const common_VERSION = new Version("14.3.0");
        let common_ViewportScroller = (() => {
            class ViewportScroller2 {}
            ViewportScroller2.prov = defineInjectable({
                token: ViewportScroller2,
                providedIn: "root",
                factory: () => new BrowserViewportScroller(core_inject(common_DOCUMENT), window)
            });
            return ViewportScroller2;
        })();
        class BrowserViewportScroller {
            constructor(document2, window2) {
                this.document = document2;
                this.window = window2;
                this.offset = () => [ 0, 0 ];
            }
            setOffset(offset) {
                if (Array.isArray(offset)) {
                    this.offset = () => offset;
                } else {
                    this.offset = offset;
                }
            }
            getScrollPosition() {
                if (this.supportsScrolling()) {
                    return [ this.window.pageXOffset, this.window.pageYOffset ];
                } else {
                    return [ 0, 0 ];
                }
            }
            scrollToPosition(position) {
                if (this.supportsScrolling()) {
                    this.window.scrollTo(position[0], position[1]);
                }
            }
            scrollToAnchor(target) {
                if (!this.supportsScrolling()) {
                    return;
                }
                const elSelected = findAnchorFromDocument(this.document, target);
                if (elSelected) {
                    this.scrollToElement(elSelected);
                    elSelected.focus();
                }
            }
            setHistoryScrollRestoration(scrollRestoration) {
                if (this.supportScrollRestoration()) {
                    const history = this.window.history;
                    if (history && history.scrollRestoration) {
                        history.scrollRestoration = scrollRestoration;
                    }
                }
            }
            scrollToElement(el) {
                const rect = el.getBoundingClientRect();
                const left = rect.left + this.window.pageXOffset;
                const top = rect.top + this.window.pageYOffset;
                const offset = this.offset();
                this.window.scrollTo(left - offset[0], top - offset[1]);
            }
            supportScrollRestoration() {
                try {
                    if (!this.supportsScrolling()) {
                        return false;
                    }
                    const scrollRestorationDescriptor = getScrollRestorationProperty(this.window.history) || getScrollRestorationProperty(Object.getPrototypeOf(this.window.history));
                    return !!scrollRestorationDescriptor && !!(scrollRestorationDescriptor.writable || scrollRestorationDescriptor.set);
                } catch {
                    return false;
                }
            }
            supportsScrolling() {
                try {
                    return !!this.window && !!this.window.scrollTo && "pageXOffset" in this.window;
                } catch {
                    return false;
                }
            }
        }
        function getScrollRestorationProperty(obj) {
            return Object.getOwnPropertyDescriptor(obj, "scrollRestoration");
        }
        function findAnchorFromDocument(document2, target) {
            const documentResult = document2.getElementById(target) || document2.getElementsByName(target)[0];
            if (documentResult) {
                return documentResult;
            }
            if (typeof document2.createTreeWalker === "function" && document2.body && (document2.body.createShadowRoot || document2.body.attachShadow)) {
                const treeWalker = document2.createTreeWalker(document2.body, NodeFilter.SHOW_ELEMENT);
                let currentNode = treeWalker.currentNode;
                while (currentNode) {
                    const shadowRoot = currentNode.shadowRoot;
                    if (shadowRoot) {
                        const result = shadowRoot.getElementById(target) || shadowRoot.querySelector(`[name="${target}"]`);
                        if (result) {
                            return result;
                        }
                    }
                    currentNode = treeWalker.nextNode();
                }
            }
            return null;
        }
        class NullViewportScroller {
            setOffset(offset) {}
            getScrollPosition() {
                return [ 0, 0 ];
            }
            scrollToPosition(position) {}
            scrollToAnchor(anchor) {}
            setHistoryScrollRestoration(scrollRestoration) {}
        }
        class XhrFactory {}
        function getUrl(src, win2) {
            return isAbsoluteUrl(src) ? new URL(src) : new URL(src, win2.location.href);
        }
        function isAbsoluteUrl(src) {
            return /^https?:\/\//.test(src);
        }
        function extractHostname(url) {
            return isAbsoluteUrl(url) ? new URL(url).hostname : url;
        }
        function isValidPath(path) {
            const isString = typeof path === "string";
            if (!isString || path.trim() === "") {
                return false;
            }
            try {
                const url = new URL(path);
                return true;
            } catch {
                return false;
            }
        }
        function normalizePath(path) {
            return path.endsWith("/") ? path.slice(0, -1) : path;
        }
        function normalizeSrc(src) {
            return src.startsWith("/") ? src.slice(1) : src;
        }
        const noopImageLoader = config2 => config2.src;
        const IMAGE_LOADER = new InjectionToken("ImageLoader", {
            providedIn: "root",
            factory: () => noopImageLoader
        });
        function createImageLoader(buildUrlFn, exampleUrls) {
            return function provideImageLoader(path) {
                if (!isValidPath(path)) {
                    throwInvalidPathError(path, exampleUrls || []);
                }
                path = normalizePath(path);
                const loaderFn = config2 => {
                    if (isAbsoluteUrl(config2.src)) {
                        throwUnexpectedAbsoluteUrlError(path, config2.src);
                    }
                    return buildUrlFn(path, {
                        ...config2,
                        src: normalizeSrc(config2.src)
                    });
                };
                const providers = [ {
                    provide: IMAGE_LOADER,
                    useValue: loaderFn
                } ];
                return providers;
            };
        }
        function throwInvalidPathError(path, exampleUrls) {
            throw new RuntimeError(2959, false);
        }
        function throwUnexpectedAbsoluteUrlError(path, url) {
            throw new RuntimeError(2959, false);
        }
        const provideCloudflareLoader = createImageLoader(createCloudflareUrl, false ? [ "https://<ZONE>/cdn-cgi/image/<OPTIONS>/<SOURCE-IMAGE>" ] : void 0);
        function createCloudflareUrl(path, config2) {
            let params = `format=auto`;
            if (config2.width) {
                params += `,width=${config2.width}`;
            }
            return `${path}/cdn-cgi/image/${params}/${config2.src}`;
        }
        const cloudinaryLoaderInfo = {
            name: "Cloudinary",
            testUrl: isCloudinaryUrl
        };
        const CLOUDINARY_LOADER_REGEX = /https?\:\/\/[^\/]+\.cloudinary\.com\/.+/;
        function isCloudinaryUrl(url) {
            return CLOUDINARY_LOADER_REGEX.test(url);
        }
        const provideCloudinaryLoader = createImageLoader(createCloudinaryUrl, false ? [ "https://res.cloudinary.com/mysite", "https://mysite.cloudinary.com", "https://subdomain.mysite.com" ] : void 0);
        function createCloudinaryUrl(path, config2) {
            let params = `f_auto,q_auto`;
            if (config2.width) {
                params += `,w_${config2.width}`;
            }
            return `${path}/image/upload/${params}/${config2.src}`;
        }
        const imageKitLoaderInfo = {
            name: "ImageKit",
            testUrl: isImageKitUrl
        };
        const IMAGE_KIT_LOADER_REGEX = /https?\:\/\/[^\/]+\.imagekit\.io\/.+/;
        function isImageKitUrl(url) {
            return IMAGE_KIT_LOADER_REGEX.test(url);
        }
        const provideImageKitLoader = createImageLoader(createImagekitUrl, false ? [ "https://ik.imagekit.io/mysite", "https://subdomain.mysite.com" ] : void 0);
        function createImagekitUrl(path, config2) {
            let params = `tr:q-auto`;
            if (config2.width) {
                params += `,w-${config2.width}`;
            }
            return `${path}/${params}/${config2.src}`;
        }
        const imgixLoaderInfo = {
            name: "Imgix",
            testUrl: isImgixUrl
        };
        const IMGIX_LOADER_REGEX = /https?\:\/\/[^\/]+\.imgix\.net\/.+/;
        function isImgixUrl(url) {
            return IMGIX_LOADER_REGEX.test(url);
        }
        const provideImgixLoader = createImageLoader(createImgixUrl, false ? [ "https://somepath.imgix.net/" ] : void 0);
        function createImgixUrl(path, config2) {
            const url = new URL(`${path}/${config2.src}`);
            url.searchParams.set("auto", "format");
            if (config2.width) {
                url.searchParams.set("w", config2.width.toString());
            }
            return url.href;
        }
        function imgDirectiveDetails(ngSrc, includeNgSrc = true) {
            const ngSrcInfo = includeNgSrc ? `(activated on an <img> element with the \`ngSrc="${ngSrc}"\`) ` : "";
            return `The NgOptimizedImage directive ${ngSrcInfo}has detected that`;
        }
        function assertDevMode(checkName) {
            if (true) {
                throw new RuntimeError(2958, `Unexpected invocation of the ${checkName} in the prod mode. Please make sure that the prod mode is enabled for production builds.`);
            }
        }
        let LCPImageObserver = null;
        (function() {})();
        function logMissingPriorityWarning(ngSrc) {
            const directiveDetails = imgDirectiveDetails(ngSrc);
            console.warn(formatRuntimeError(2955, `${directiveDetails} this image is the Largest Contentful Paint (LCP) element but was not marked "priority". This image should be marked "priority" in order to prioritize its loading. To fix this, add the "priority" attribute.`));
        }
        const INTERNAL_PRECONNECT_CHECK_BLOCKLIST = new Set([ "localhost", "127.0.0.1", "0.0.0.0" ]);
        const PRECONNECT_CHECK_BLOCKLIST = new InjectionToken("PRECONNECT_CHECK_BLOCKLIST");
        let PreconnectLinkChecker = null;
        (function() {})();
        function common_deepForEach(input, fn) {
            for (let value of input) {
                Array.isArray(value) ? common_deepForEach(value, fn) : fn(value);
            }
        }
        const DEFAULT_PRELOADED_IMAGES_LIMIT = 5;
        const PRELOADED_IMAGES = new InjectionToken("NG_OPTIMIZED_PRELOADED_IMAGES", {
            providedIn: "root",
            factory: () => new Set
        });
        let PreloadLinkCreator = null;
        (function() {})();
        const BASE64_IMG_MAX_LENGTH_IN_ERROR = 50;
        const VALID_WIDTH_DESCRIPTOR_SRCSET = /^((\s*\d+w\s*(,|$)){1,})$/;
        const VALID_DENSITY_DESCRIPTOR_SRCSET = /^((\s*\d+(\.\d+)?x\s*(,|$)){1,})$/;
        const ABSOLUTE_SRCSET_DENSITY_CAP = 3;
        const RECOMMENDED_SRCSET_DENSITY_CAP = 2;
        const DENSITY_SRCSET_MULTIPLIERS = null;
        const VIEWPORT_BREAKPOINT_CUTOFF = 640;
        const ASPECT_RATIO_TOLERANCE = .1;
        const OVERSIZED_IMAGE_TOLERANCE = 1e3;
        const FIXED_SRCSET_WIDTH_LIMIT = 1920;
        const FIXED_SRCSET_HEIGHT_LIMIT = 1080;
        const BUILT_IN_LOADERS = [ imgixLoaderInfo, imageKitLoaderInfo, cloudinaryLoaderInfo ];
        const defaultConfig = {
            breakpoints: [ 16, 32, 48, 64, 96, 128, 256, 384, 640, 750, 828, 1080, 1200, 1920, 2048, 3840 ]
        };
        const IMAGE_CONFIG = new InjectionToken("ImageConfig", {
            providedIn: "root",
            factory: () => defaultConfig
        });
        let NgOptimizedImage = null;
        (function() {})();
        function inputToInteger(value) {
            return typeof value === "string" ? parseInt(value, 10) : value;
        }
        function inputToBoolean(value) {
            return value != null && `${value}` !== "false";
        }
        function processConfig(config2) {
            let sortedBreakpoints = {};
            if (config2.breakpoints) {
                sortedBreakpoints.breakpoints = config2.breakpoints.sort((a, b) => a - b);
            }
            return Object.assign({}, defaultConfig, config2, sortedBreakpoints);
        }
        function assertNoConflictingSrc(dir) {
            if (dir.src) {
                throw new RuntimeError(2950, `${imgDirectiveDetails(dir.ngSrc)} both \`src\` and \`ngSrc\` have been set. Supplying both of these attributes breaks lazy loading. The NgOptimizedImage directive sets \`src\` itself based on the value of \`ngSrc\`. To fix this, please remove the \`src\` attribute.`);
            }
        }
        function assertNoConflictingSrcset(dir) {
            if (dir.srcset) {
                throw new RuntimeError(2951, `${imgDirectiveDetails(dir.ngSrc)} both \`srcset\` and \`ngSrcset\` have been set. Supplying both of these attributes breaks lazy loading. The NgOptimizedImage directive sets \`srcset\` itself based on the value of \`ngSrcset\`. To fix this, please remove the \`srcset\` attribute.`);
            }
        }
        function assertNotBase64Image(dir) {
            let ngSrc = dir.ngSrc.trim();
            if (ngSrc.startsWith("data:")) {
                if (ngSrc.length > BASE64_IMG_MAX_LENGTH_IN_ERROR) {
                    ngSrc = ngSrc.substring(0, BASE64_IMG_MAX_LENGTH_IN_ERROR) + "...";
                }
                throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc, false)} \`ngSrc\` is a Base64-encoded string (${ngSrc}). NgOptimizedImage does not support Base64-encoded strings. To fix this, disable the NgOptimizedImage directive for this element by removing \`ngSrc\` and using a standard \`src\` attribute instead.`);
            }
        }
        function assertNoComplexSizes(dir) {
            let sizes = dir.sizes;
            if (sizes?.match(/((\)|,)\s|^)\d+px/)) {
                throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc, false)} \`sizes\` was set to a string including pixel values. For automatic \`srcset\` generation, \`sizes\` must only include responsive values, such as \`sizes="50vw"\` or \`sizes="(min-width: 768px) 50vw, 100vw"\`. To fix this, modify the \`sizes\` attribute, or provide your own \`ngSrcset\` value directly.`);
            }
        }
        function assertNotBlobUrl(dir) {
            const ngSrc = dir.ngSrc.trim();
            if (ngSrc.startsWith("blob:")) {
                throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} \`ngSrc\` was set to a blob URL (${ngSrc}). Blob URLs are not supported by the NgOptimizedImage directive. To fix this, disable the NgOptimizedImage directive for this element by removing \`ngSrc\` and using a regular \`src\` attribute instead.`);
            }
        }
        function assertNonEmptyInput(dir, name, value) {
            const isString = typeof value === "string";
            const isEmptyString = isString && value.trim() === "";
            if (!isString || isEmptyString) {
                throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} \`${name}\` has an invalid value (\`${value}\`). To fix this, change the value to a non-empty string.`);
            }
        }
        function assertValidNgSrcset(dir, value) {
            if (value == null) {
                return;
            }
            assertNonEmptyInput(dir, "ngSrcset", value);
            const stringVal = value;
            const isValidWidthDescriptor = VALID_WIDTH_DESCRIPTOR_SRCSET.test(stringVal);
            const isValidDensityDescriptor = VALID_DENSITY_DESCRIPTOR_SRCSET.test(stringVal);
            if (isValidDensityDescriptor) {
                assertUnderDensityCap(dir, stringVal);
            }
            const isValidSrcset = isValidWidthDescriptor || isValidDensityDescriptor;
            if (!isValidSrcset) {
                throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} \`ngSrcset\` has an invalid value (\`${value}\`). To fix this, supply \`ngSrcset\` using a comma-separated list of one or more width descriptors (e.g. "100w, 200w") or density descriptors (e.g. "1x, 2x").`);
            }
        }
        function assertUnderDensityCap(dir, value) {
            const underDensityCap = value.split(",").every(num => num === "" || parseFloat(num) <= ABSOLUTE_SRCSET_DENSITY_CAP);
            if (!underDensityCap) {
                throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the \`ngSrcset\` contains an unsupported image density:\`${value}\`. NgOptimizedImage generally recommends a max image density of ${RECOMMENDED_SRCSET_DENSITY_CAP}x but supports image densities up to ${ABSOLUTE_SRCSET_DENSITY_CAP}x. The human eye cannot distinguish between image densities greater than ${RECOMMENDED_SRCSET_DENSITY_CAP}x - which makes them unnecessary for most use cases. Images that will be pinch-zoomed are typically the primary use case for ${ABSOLUTE_SRCSET_DENSITY_CAP}x images. Please remove the high density descriptor and try again.`);
            }
        }
        function postInitInputChangeError(dir, inputName) {
            let reason;
            if (inputName === "width" || inputName === "height") {
                reason = `Changing \`${inputName}\` may result in different attribute value applied to the underlying image element and cause layout shifts on a page.`;
            } else {
                reason = `Changing the \`${inputName}\` would have no effect on the underlying image element, because the resource loading has already occurred.`;
            }
            return new RuntimeError(2953, `${imgDirectiveDetails(dir.ngSrc)} \`${inputName}\` was updated after initialization. The NgOptimizedImage directive will not react to this input change. ${reason} To fix this, either switch \`${inputName}\` to a static value or wrap the image element in an *ngIf that is gated on the necessary value.`);
        }
        function assertNoPostInitInputChange(dir, changes, inputs) {
            inputs.forEach(input => {
                const isUpdated = changes.hasOwnProperty(input);
                if (isUpdated && !changes[input].isFirstChange()) {
                    if (input === "ngSrc") {
                        dir = {
                            ngSrc: changes[input].previousValue
                        };
                    }
                    throw postInitInputChangeError(dir, input);
                }
            });
        }
        function assertGreaterThanZero(dir, inputValue, inputName) {
            const validNumber = typeof inputValue === "number" && inputValue > 0;
            const validString = typeof inputValue === "string" && /^\d+$/.test(inputValue.trim()) && parseInt(inputValue) > 0;
            if (!validNumber && !validString) {
                throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} \`${inputName}\` has an invalid value (\`${inputValue}\`). To fix this, provide \`${inputName}\` as a number greater than 0.`);
            }
        }
        function assertNoImageDistortion(dir, img, renderer) {
            const removeListenerFn = renderer.listen(img, "load", () => {
                removeListenerFn();
                const renderedWidth = img.clientWidth;
                const renderedHeight = img.clientHeight;
                const renderedAspectRatio = renderedWidth / renderedHeight;
                const nonZeroRenderedDimensions = renderedWidth !== 0 && renderedHeight !== 0;
                const intrinsicWidth = img.naturalWidth;
                const intrinsicHeight = img.naturalHeight;
                const intrinsicAspectRatio = intrinsicWidth / intrinsicHeight;
                const suppliedWidth = dir.width;
                const suppliedHeight = dir.height;
                const suppliedAspectRatio = suppliedWidth / suppliedHeight;
                const inaccurateDimensions = Math.abs(suppliedAspectRatio - intrinsicAspectRatio) > ASPECT_RATIO_TOLERANCE;
                const stylingDistortion = nonZeroRenderedDimensions && Math.abs(intrinsicAspectRatio - renderedAspectRatio) > ASPECT_RATIO_TOLERANCE;
                if (inaccurateDimensions) {
                    console.warn(formatRuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the aspect ratio of the image does not match the aspect ratio indicated by the width and height attributes. \nIntrinsic image size: ${intrinsicWidth}w x ${intrinsicHeight}h (aspect-ratio: ${intrinsicAspectRatio}). \nSupplied width and height attributes: ${suppliedWidth}w x ${suppliedHeight}h (aspect-ratio: ${suppliedAspectRatio}). \nTo fix this, update the width and height attributes.`));
                } else if (stylingDistortion) {
                    console.warn(formatRuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the aspect ratio of the rendered image does not match the image's intrinsic aspect ratio. \nIntrinsic image size: ${intrinsicWidth}w x ${intrinsicHeight}h (aspect-ratio: ${intrinsicAspectRatio}). \nRendered image size: ${renderedWidth}w x ${renderedHeight}h (aspect-ratio: ${renderedAspectRatio}). \nThis issue can occur if "width" and "height" attributes are added to an image without updating the corresponding image styling. To fix this, adjust image styling. In most cases, adding "height: auto" or "width: auto" to the image styling will fix this issue.`));
                } else if (!dir.ngSrcset && nonZeroRenderedDimensions) {
                    const recommendedWidth = RECOMMENDED_SRCSET_DENSITY_CAP * renderedWidth;
                    const recommendedHeight = RECOMMENDED_SRCSET_DENSITY_CAP * renderedHeight;
                    const oversizedWidth = intrinsicWidth - recommendedWidth >= OVERSIZED_IMAGE_TOLERANCE;
                    const oversizedHeight = intrinsicHeight - recommendedHeight >= OVERSIZED_IMAGE_TOLERANCE;
                    if (oversizedWidth || oversizedHeight) {
                        console.warn(formatRuntimeError(2960, `${imgDirectiveDetails(dir.ngSrc)} the intrinsic image is significantly larger than necessary. \nRendered image size: ${renderedWidth}w x ${renderedHeight}h. \nIntrinsic image size: ${intrinsicWidth}w x ${intrinsicHeight}h. \nRecommended intrinsic image size: ${recommendedWidth}w x ${recommendedHeight}h. \nNote: Recommended intrinsic image size is calculated assuming a maximum DPR of ${RECOMMENDED_SRCSET_DENSITY_CAP}. To improve loading time, resize the image or consider using the "ngSrcset" and "sizes" attributes.`));
                    }
                }
            });
        }
        function assertNonEmptyWidthAndHeight(dir) {
            let missingAttributes = [];
            if (dir.width === void 0) {
                missingAttributes.push("width");
            }
            if (dir.height === void 0) {
                missingAttributes.push("height");
            }
            if (missingAttributes.length > 0) {
                throw new RuntimeError(2954, `${imgDirectiveDetails(dir.ngSrc)} these required attributes are missing: ${missingAttributes.map(attr => `"${attr}"`).join(", ")}. Including "width" and "height" attributes will prevent image-related layout shifts. To fix this, include "width" and "height" attributes on the image tag or turn on "fill" mode with the \`fill\` attribute.`);
            }
        }
        function assertEmptyWidthAndHeight(dir) {
            if (dir.width || dir.height) {
                throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the attributes \`height\` and/or \`width\` are present along with the \`fill\` attribute. Because \`fill\` mode causes an image to fill its containing element, the size attributes have no effect and should be removed.`);
            }
        }
        function assertNonZeroRenderedHeight(dir, img, renderer) {
            const removeListenerFn = renderer.listen(img, "load", () => {
                removeListenerFn();
                const renderedHeight = img.clientHeight;
                if (dir.fill && renderedHeight === 0) {
                    console.warn(formatRuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the height of the fill-mode image is zero. This is likely because the containing element does not have the CSS 'position' property set to one of the following: "relative", "fixed", or "absolute". To fix this problem, make sure the container element has the CSS 'position' property defined and the height of the element is not zero.`));
                }
            });
        }
        function assertValidLoadingInput(dir) {
            if (dir.loading && dir.priority) {
                throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the \`loading\` attribute was used on an image that was marked "priority". Setting \`loading\` on priority images is not allowed because these images will always be eagerly loaded. To fix this, remove the loading attribute from the priority image.`);
            }
            const validInputs = [ "auto", "eager", "lazy" ];
            if (typeof dir.loading === "string" && !validInputs.includes(dir.loading)) {
                throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the \`loading\` attribute has an invalid value (\`${dir.loading}\`). To fix this, provide a valid value ("lazy", "eager", or "auto").`);
            }
        }
        function assertNotMissingBuiltInLoader(ngSrc, imageLoader) {
            if (imageLoader === noopImageLoader) {
                let builtInLoaderName = "";
                for (const loader of BUILT_IN_LOADERS) {
                    if (loader.testUrl(ngSrc)) {
                        builtInLoaderName = loader.name;
                        break;
                    }
                }
                if (builtInLoaderName) {
                    console.warn(formatRuntimeError(2962, `NgOptimizedImage: It looks like your images may be hosted on the ${builtInLoaderName} CDN, but your app is not using Angular's built-in loader for that CDN. We recommend switching to use the built-in by calling \`provide${builtInLoaderName}Loader()\` in your \`providers\` and passing it your instance's base URL. If you don't want to use the built-in loader, define a custom loader function using IMAGE_LOADER to silence this warning.`));
                }
            }
        }
        function assertNoNgSrcsetWithoutLoader(dir, imageLoader) {
            if (dir.ngSrcset && imageLoader === noopImageLoader) {
                console.warn(formatRuntimeError(2963, `${imgDirectiveDetails(dir.ngSrc)} the \`ngSrcset\` attribute is present but no image loader is configured (i.e. the default one is being used), which would result in the same image being used for all configured sizes. To fix this, provide a loader or remove the \`ngSrcset\` attribute from the image.`));
            }
        }
        function assertNoLoaderParamsWithoutLoader(dir, imageLoader) {
            if (dir.loaderParams && imageLoader === noopImageLoader) {
                console.warn(formatRuntimeError(2963, `${imgDirectiveDetails(dir.ngSrc)} the \`loaderParams\` attribute is present but no image loader is configured (i.e. the default one is being used), which means that the loaderParams data will not be consumed and will not affect the URL. To fix this, provide a custom loader or remove the \`loaderParams\` attribute from the image.`));
            }
        }
        class GenericBrowserDomAdapter extends DomAdapter {
            constructor() {
                super(...arguments);
                this.supportsDOMEvents = true;
            }
        }
        class BrowserDomAdapter extends GenericBrowserDomAdapter {
            static makeCurrent() {
                setRootDomAdapter(new BrowserDomAdapter);
            }
            onAndCancel(el, evt, listener) {
                el.addEventListener(evt, listener, false);
                return () => {
                    el.removeEventListener(evt, listener, false);
                };
            }
            dispatchEvent(el, evt) {
                el.dispatchEvent(evt);
            }
            remove(node) {
                if (node.parentNode) {
                    node.parentNode.removeChild(node);
                }
            }
            createElement(tagName, doc) {
                doc = doc || this.getDefaultDocument();
                return doc.createElement(tagName);
            }
            createHtmlDocument() {
                return document.implementation.createHTMLDocument("fakeTitle");
            }
            getDefaultDocument() {
                return document;
            }
            isElementNode(node) {
                return node.nodeType === Node.ELEMENT_NODE;
            }
            isShadowRoot(node) {
                return node instanceof DocumentFragment;
            }
            getGlobalEventTarget(doc, target) {
                if (target === "window") {
                    return window;
                }
                if (target === "document") {
                    return doc;
                }
                if (target === "body") {
                    return doc.body;
                }
                return null;
            }
            getBaseHref(doc) {
                const href = getBaseElementHref();
                return href == null ? null : relativePath(href);
            }
            resetBaseElement() {
                baseElement = null;
            }
            getUserAgent() {
                return window.navigator.userAgent;
            }
            getCookie(name) {
                return parseCookieValue(document.cookie, name);
            }
        }
        let baseElement = null;
        function getBaseElementHref() {
            baseElement = baseElement || document.querySelector("base");
            return baseElement ? baseElement.getAttribute("href") : null;
        }
        let urlParsingNode;
        function relativePath(url) {
            urlParsingNode = urlParsingNode || document.createElement("a");
            urlParsingNode.setAttribute("href", url);
            const pathName = urlParsingNode.pathname;
            return pathName.charAt(0) === "/" ? pathName : `/${pathName}`;
        }
        const TRANSITION_ID = new InjectionToken("TRANSITION_ID");
        function appInitializerFactory(transitionId, document2, injector) {
            return () => {
                injector.get(ApplicationInitStatus).donePromise.then(() => {
                    const dom = getDOM();
                    const styles = document2.querySelectorAll(`style[ng-transition="${transitionId}"]`);
                    for (let i = 0; i < styles.length; i++) {
                        dom.remove(styles[i]);
                    }
                });
            };
        }
        const SERVER_TRANSITION_PROVIDERS = [ {
            provide: APP_INITIALIZER,
            useFactory: appInitializerFactory,
            deps: [ TRANSITION_ID, common_DOCUMENT, core_Injector ],
            multi: true
        } ];
        class BrowserGetTestability {
            addToWindow(registry) {
                _global.getAngularTestability = (elem, findInAncestors = true) => {
                    const testability = registry.findTestabilityInTree(elem, findInAncestors);
                    if (testability == null) {
                        throw new Error("Could not find testability for element.");
                    }
                    return testability;
                };
                _global.getAllAngularTestabilities = () => registry.getAllTestabilities();
                _global.getAllAngularRootElements = () => registry.getAllRootElements();
                const whenAllStable = callback => {
                    const testabilities = _global.getAllAngularTestabilities();
                    let count = testabilities.length;
                    let didWork = false;
                    const decrement = function(didWork_) {
                        didWork = didWork || didWork_;
                        count--;
                        if (count == 0) {
                            callback(didWork);
                        }
                    };
                    testabilities.forEach(function(testability) {
                        testability.whenStable(decrement);
                    });
                };
                if (!_global.frameworkStabilizers) {
                    _global.frameworkStabilizers = [];
                }
                _global.frameworkStabilizers.push(whenAllStable);
            }
            findTestabilityInTree(registry, elem, findInAncestors) {
                if (elem == null) {
                    return null;
                }
                const t = registry.getTestability(elem);
                if (t != null) {
                    return t;
                } else if (!findInAncestors) {
                    return null;
                }
                if (getDOM().isShadowRoot(elem)) {
                    return this.findTestabilityInTree(registry, elem.host, true);
                }
                return this.findTestabilityInTree(registry, elem.parentElement, true);
            }
        }
        let BrowserXhr = (() => {
            class BrowserXhr2 {
                build() {
                    return new XMLHttpRequest;
                }
            }
            BrowserXhr2.fac = function BrowserXhr_Factory(t) {
                return new (t || BrowserXhr2);
            };
            BrowserXhr2.prov = defineInjectable({
                token: BrowserXhr2,
                factory: BrowserXhr2.fac
            });
            return BrowserXhr2;
        })();
        (function() {})();
        const EVENT_MANAGER_PLUGINS = new InjectionToken("EventManagerPlugins");
        let EventManager = (() => {
            class EventManager2 {
                constructor(plugins, _zone) {
                    this._zone = _zone;
                    this._eventNameToPlugin = new Map;
                    plugins.forEach(p => p.manager = this);
                    this._plugins = plugins.slice().reverse();
                }
                addEventListener(element, eventName, handler) {
                    const plugin = this._findPluginFor(eventName);
                    return plugin.addEventListener(element, eventName, handler);
                }
                addGlobalEventListener(target, eventName, handler) {
                    const plugin = this._findPluginFor(eventName);
                    return plugin.addGlobalEventListener(target, eventName, handler);
                }
                getZone() {
                    return this._zone;
                }
                _findPluginFor(eventName) {
                    const plugin = this._eventNameToPlugin.get(eventName);
                    if (plugin) {
                        return plugin;
                    }
                    const plugins = this._plugins;
                    for (let i = 0; i < plugins.length; i++) {
                        const plugin2 = plugins[i];
                        if (plugin2.supports(eventName)) {
                            this._eventNameToPlugin.set(eventName, plugin2);
                            return plugin2;
                        }
                    }
                    throw new Error(`No event manager plugin found for event ${eventName}`);
                }
            }
            EventManager2.fac = function EventManager_Factory(t) {
                return new (t || EventManager2)(core_inject(EVENT_MANAGER_PLUGINS), core_inject(core_NgZone));
            };
            EventManager2.prov = defineInjectable({
                token: EventManager2,
                factory: EventManager2.fac
            });
            return EventManager2;
        })();
        (function() {})();
        class EventManagerPlugin {
            constructor(_doc) {
                this._doc = _doc;
            }
            addGlobalEventListener(element, eventName, handler) {
                const target = getDOM().getGlobalEventTarget(this._doc, element);
                if (!target) {
                    throw new Error(`Unsupported event target ${target} for event ${eventName}`);
                }
                return this.addEventListener(target, eventName, handler);
            }
        }
        let SharedStylesHost = (() => {
            class SharedStylesHost2 {
                constructor() {
                    this._stylesSet = new Set;
                }
                addStyles(styles) {
                    const additions = new Set;
                    styles.forEach(style => {
                        if (!this._stylesSet.has(style)) {
                            this._stylesSet.add(style);
                            additions.add(style);
                        }
                    });
                    this.onStylesAdded(additions);
                }
                onStylesAdded(additions) {}
                getAllStyles() {
                    return Array.from(this._stylesSet);
                }
            }
            SharedStylesHost2.fac = function SharedStylesHost_Factory(t) {
                return new (t || SharedStylesHost2);
            };
            SharedStylesHost2.prov = defineInjectable({
                token: SharedStylesHost2,
                factory: SharedStylesHost2.fac
            });
            return SharedStylesHost2;
        })();
        (function() {})();
        let DomSharedStylesHost = (() => {
            class DomSharedStylesHost2 extends SharedStylesHost {
                constructor(_doc) {
                    super();
                    this._doc = _doc;
                    this._hostNodes = new Map;
                    this._hostNodes.set(_doc.head, []);
                }
                _addStylesToHost(styles, host, styleNodes) {
                    styles.forEach(style => {
                        const styleEl = this._doc.createElement("style");
                        styleEl.textContent = style;
                        styleNodes.push(host.appendChild(styleEl));
                    });
                }
                addHost(hostNode) {
                    const styleNodes = [];
                    this._addStylesToHost(this._stylesSet, hostNode, styleNodes);
                    this._hostNodes.set(hostNode, styleNodes);
                }
                removeHost(hostNode) {
                    const styleNodes = this._hostNodes.get(hostNode);
                    if (styleNodes) {
                        styleNodes.forEach(removeStyle);
                    }
                    this._hostNodes.delete(hostNode);
                }
                onStylesAdded(additions) {
                    this._hostNodes.forEach((styleNodes, hostNode) => {
                        this._addStylesToHost(additions, hostNode, styleNodes);
                    });
                }
                ngOnDestroy() {
                    this._hostNodes.forEach(styleNodes => styleNodes.forEach(removeStyle));
                }
            }
            DomSharedStylesHost2.fac = function DomSharedStylesHost_Factory(t) {
                return new (t || DomSharedStylesHost2)(core_inject(common_DOCUMENT));
            };
            DomSharedStylesHost2.prov = defineInjectable({
                token: DomSharedStylesHost2,
                factory: DomSharedStylesHost2.fac
            });
            return DomSharedStylesHost2;
        })();
        (function() {})();
        function removeStyle(styleNode) {
            getDOM().remove(styleNode);
        }
        const NAMESPACE_URIS = {
            svg: "http://www.w3.org/2000/svg",
            xhtml: "http://www.w3.org/1999/xhtml",
            xlink: "http://www.w3.org/1999/xlink",
            xml: "http://www.w3.org/XML/1998/namespace",
            xmlns: "http://www.w3.org/2000/xmlns/",
            math: "http://www.w3.org/1998/MathML/"
        };
        const COMPONENT_REGEX = /%COMP%/g;
        const NG_DEV_MODE$1 = false;
        const COMPONENT_VARIABLE = "%COMP%";
        const HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;
        const CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;
        function shimContentAttribute(componentShortId) {
            return CONTENT_ATTR.replace(COMPONENT_REGEX, componentShortId);
        }
        function shimHostAttribute(componentShortId) {
            return HOST_ATTR.replace(COMPONENT_REGEX, componentShortId);
        }
        function flattenStyles(compId, styles, target) {
            for (let i = 0; i < styles.length; i++) {
                let style = styles[i];
                if (Array.isArray(style)) {
                    flattenStyles(compId, style, target);
                } else {
                    style = style.replace(COMPONENT_REGEX, compId);
                    target.push(style);
                }
            }
            return target;
        }
        function decoratePreventDefault(eventHandler) {
            return event => {
                if (event === "__ngUnwrap__") {
                    return eventHandler;
                }
                const allowDefaultBehavior = eventHandler(event);
                if (allowDefaultBehavior === false) {
                    event.preventDefault();
                    event.returnValue = false;
                }
                return void 0;
            };
        }
        let hasLoggedNativeEncapsulationWarning = false;
        let DomRendererFactory2 = (() => {
            class DomRendererFactory22 {
                constructor(eventManager, sharedStylesHost, appId) {
                    this.eventManager = eventManager;
                    this.sharedStylesHost = sharedStylesHost;
                    this.appId = appId;
                    this.rendererByCompId = new Map;
                    this.defaultRenderer = new DefaultDomRenderer2(eventManager);
                }
                createRenderer(element, type) {
                    if (!element || !type) {
                        return this.defaultRenderer;
                    }
                    switch (type.encapsulation) {
                      case ViewEncapsulation$1.Emulated:
                        {
                            let renderer = this.rendererByCompId.get(type.id);
                            if (!renderer) {
                                renderer = new EmulatedEncapsulationDomRenderer2(this.eventManager, this.sharedStylesHost, type, this.appId);
                                this.rendererByCompId.set(type.id, renderer);
                            }
                            renderer.applyToHost(element);
                            return renderer;
                        }

                      case 1:
                      case ViewEncapsulation$1.ShadowDom:
                        if (false) {
                            hasLoggedNativeEncapsulationWarning = true;
                            console.warn("ViewEncapsulation.Native is no longer supported. Falling back to ViewEncapsulation.ShadowDom. The fallback will be removed in v12.");
                        }
                        return new ShadowDomRenderer(this.eventManager, this.sharedStylesHost, element, type);

                      default:
                        {
                            if (!this.rendererByCompId.has(type.id)) {
                                const styles = flattenStyles(type.id, type.styles, []);
                                this.sharedStylesHost.addStyles(styles);
                                this.rendererByCompId.set(type.id, this.defaultRenderer);
                            }
                            return this.defaultRenderer;
                        }
                    }
                }
                begin() {}
                end() {}
            }
            DomRendererFactory22.fac = function DomRendererFactory2_Factory(t) {
                return new (t || DomRendererFactory22)(core_inject(EventManager), core_inject(DomSharedStylesHost), core_inject(core_APP_ID));
            };
            DomRendererFactory22.prov = defineInjectable({
                token: DomRendererFactory22,
                factory: DomRendererFactory22.fac
            });
            return DomRendererFactory22;
        })();
        (function() {})();
        class DefaultDomRenderer2 {
            constructor(eventManager) {
                this.eventManager = eventManager;
                this.data = Object.create(null);
                this.destroyNode = null;
            }
            destroy() {}
            createElement(name, namespace) {
                if (namespace) {
                    return document.createElementNS(NAMESPACE_URIS[namespace] || namespace, name);
                }
                return document.createElement(name);
            }
            createComment(value) {
                return document.createComment(value);
            }
            createText(value) {
                return document.createTextNode(value);
            }
            appendChild(parent, newChild) {
                const targetParent = platform_browser_isTemplateNode(parent) ? parent.content : parent;
                targetParent.appendChild(newChild);
            }
            insertBefore(parent, newChild, refChild) {
                if (parent) {
                    const targetParent = platform_browser_isTemplateNode(parent) ? parent.content : parent;
                    targetParent.insertBefore(newChild, refChild);
                }
            }
            removeChild(parent, oldChild) {
                if (parent) {
                    parent.removeChild(oldChild);
                }
            }
            selectRootElement(selectorOrNode, preserveContent) {
                let el = typeof selectorOrNode === "string" ? document.querySelector(selectorOrNode) : selectorOrNode;
                if (!el) {
                    throw new Error(`The selector "${selectorOrNode}" did not match any elements`);
                }
                if (!preserveContent) {
                    el.textContent = "";
                }
                return el;
            }
            parentNode(node) {
                return node.parentNode;
            }
            nextSibling(node) {
                return node.nextSibling;
            }
            setAttribute(el, name, value, namespace) {
                if (namespace) {
                    name = namespace + ":" + name;
                    const namespaceUri = NAMESPACE_URIS[namespace];
                    if (namespaceUri) {
                        el.setAttributeNS(namespaceUri, name, value);
                    } else {
                        el.setAttribute(name, value);
                    }
                } else {
                    el.setAttribute(name, value);
                }
            }
            removeAttribute(el, name, namespace) {
                if (namespace) {
                    const namespaceUri = NAMESPACE_URIS[namespace];
                    if (namespaceUri) {
                        el.removeAttributeNS(namespaceUri, name);
                    } else {
                        el.removeAttribute(`${namespace}:${name}`);
                    }
                } else {
                    el.removeAttribute(name);
                }
            }
            addClass(el, name) {
                el.classList.add(name);
            }
            removeClass(el, name) {
                el.classList.remove(name);
            }
            setStyle(el, style, value, flags) {
                if (flags & (RendererStyleFlags2.DashCase | RendererStyleFlags2.Important)) {
                    el.style.setProperty(style, value, flags & RendererStyleFlags2.Important ? "important" : "");
                } else {
                    el.style[style] = value;
                }
            }
            removeStyle(el, style, flags) {
                if (flags & RendererStyleFlags2.DashCase) {
                    el.style.removeProperty(style);
                } else {
                    el.style[style] = "";
                }
            }
            setProperty(el, name, value) {
                NG_DEV_MODE$1 && checkNoSyntheticProp(name, "property");
                el[name] = value;
            }
            setValue(node, value) {
                node.nodeValue = value;
            }
            listen(target, event, callback) {
                NG_DEV_MODE$1 && checkNoSyntheticProp(event, "listener");
                if (typeof target === "string") {
                    return this.eventManager.addGlobalEventListener(target, event, decoratePreventDefault(callback));
                }
                return this.eventManager.addEventListener(target, event, decoratePreventDefault(callback));
            }
        }
        const AT_CHARCODE = (() => "@".charCodeAt(0))();
        function checkNoSyntheticProp(name, nameKind) {
            if (name.charCodeAt(0) === AT_CHARCODE) {
                throw new Error(`Unexpected synthetic ${nameKind} ${name} found. Please make sure that:\n  - Either \`BrowserAnimationsModule\` or \`NoopAnimationsModule\` are imported in your application.\n  - There is corresponding configuration for the animation named \`${name}\` defined in the \`animations\` field of the \`@Component\` decorator (see https://angular.io/api/core/Component#animations).`);
            }
        }
        function platform_browser_isTemplateNode(node) {
            return node.tagName === "TEMPLATE" && node.content !== void 0;
        }
        class EmulatedEncapsulationDomRenderer2 extends DefaultDomRenderer2 {
            constructor(eventManager, sharedStylesHost, component, appId) {
                super(eventManager);
                this.component = component;
                const styles = flattenStyles(appId + "-" + component.id, component.styles, []);
                sharedStylesHost.addStyles(styles);
                this.contentAttr = shimContentAttribute(appId + "-" + component.id);
                this.hostAttr = shimHostAttribute(appId + "-" + component.id);
            }
            applyToHost(element) {
                super.setAttribute(element, this.hostAttr, "");
            }
            createElement(parent, name) {
                const el = super.createElement(parent, name);
                super.setAttribute(el, this.contentAttr, "");
                return el;
            }
        }
        class ShadowDomRenderer extends DefaultDomRenderer2 {
            constructor(eventManager, sharedStylesHost, hostEl, component) {
                super(eventManager);
                this.sharedStylesHost = sharedStylesHost;
                this.hostEl = hostEl;
                this.shadowRoot = hostEl.attachShadow({
                    mode: "open"
                });
                this.sharedStylesHost.addHost(this.shadowRoot);
                const styles = flattenStyles(component.id, component.styles, []);
                for (let i = 0; i < styles.length; i++) {
                    const styleEl = document.createElement("style");
                    styleEl.textContent = styles[i];
                    this.shadowRoot.appendChild(styleEl);
                }
            }
            nodeOrShadowRoot(node) {
                return node === this.hostEl ? this.shadowRoot : node;
            }
            destroy() {
                this.sharedStylesHost.removeHost(this.shadowRoot);
            }
            appendChild(parent, newChild) {
                return super.appendChild(this.nodeOrShadowRoot(parent), newChild);
            }
            insertBefore(parent, newChild, refChild) {
                return super.insertBefore(this.nodeOrShadowRoot(parent), newChild, refChild);
            }
            removeChild(parent, oldChild) {
                return super.removeChild(this.nodeOrShadowRoot(parent), oldChild);
            }
            parentNode(node) {
                return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(node)));
            }
        }
        let DomEventsPlugin = (() => {
            class DomEventsPlugin2 extends EventManagerPlugin {
                constructor(doc) {
                    super(doc);
                }
                supports(eventName) {
                    return true;
                }
                addEventListener(element, eventName, handler) {
                    element.addEventListener(eventName, handler, false);
                    return () => this.removeEventListener(element, eventName, handler);
                }
                removeEventListener(target, eventName, callback) {
                    return target.removeEventListener(eventName, callback);
                }
            }
            DomEventsPlugin2.fac = function DomEventsPlugin_Factory(t) {
                return new (t || DomEventsPlugin2)(core_inject(common_DOCUMENT));
            };
            DomEventsPlugin2.prov = defineInjectable({
                token: DomEventsPlugin2,
                factory: DomEventsPlugin2.fac
            });
            return DomEventsPlugin2;
        })();
        (function() {})();
        const MODIFIER_KEYS = [ "alt", "control", "meta", "shift" ];
        const _keyMap = {
            "\b": "Backspace",
            "\t": "Tab",
            "": "Delete",
            "": "Escape",
            Del: "Delete",
            Esc: "Escape",
            Left: "ArrowLeft",
            Right: "ArrowRight",
            Up: "ArrowUp",
            Down: "ArrowDown",
            Menu: "ContextMenu",
            Scroll: "ScrollLock",
            Win: "OS"
        };
        const MODIFIER_KEY_GETTERS = {
            alt: event => event.altKey,
            control: event => event.ctrlKey,
            meta: event => event.metaKey,
            shift: event => event.shiftKey
        };
        let KeyEventsPlugin = (() => {
            class KeyEventsPlugin2 extends EventManagerPlugin {
                constructor(doc) {
                    super(doc);
                }
                supports(eventName) {
                    return KeyEventsPlugin2.parseEventName(eventName) != null;
                }
                addEventListener(element, eventName, handler) {
                    const parsedEvent = KeyEventsPlugin2.parseEventName(eventName);
                    const outsideHandler = KeyEventsPlugin2.eventCallback(parsedEvent["fullKey"], handler, this.manager.getZone());
                    return this.manager.getZone().runOutsideAngular(() => getDOM().onAndCancel(element, parsedEvent["domEventName"], outsideHandler));
                }
                static parseEventName(eventName) {
                    const parts = eventName.toLowerCase().split(".");
                    const domEventName = parts.shift();
                    if (parts.length === 0 || !(domEventName === "keydown" || domEventName === "keyup")) {
                        return null;
                    }
                    const key = KeyEventsPlugin2._normalizeKey(parts.pop());
                    let fullKey = "";
                    let codeIX = parts.indexOf("code");
                    if (codeIX > -1) {
                        parts.splice(codeIX, 1);
                        fullKey = "code.";
                    }
                    MODIFIER_KEYS.forEach(modifierName => {
                        const index = parts.indexOf(modifierName);
                        if (index > -1) {
                            parts.splice(index, 1);
                            fullKey += modifierName + ".";
                        }
                    });
                    fullKey += key;
                    if (parts.length != 0 || key.length === 0) {
                        return null;
                    }
                    const result = {};
                    result["domEventName"] = domEventName;
                    result["fullKey"] = fullKey;
                    return result;
                }
                static matchEventFullKeyCode(event, fullKeyCode) {
                    let keycode = _keyMap[event.key] || event.key;
                    let key = "";
                    if (fullKeyCode.indexOf("code.") > -1) {
                        keycode = event.code;
                        key = "code.";
                    }
                    if (keycode == null || !keycode) {
                        return false;
                    }
                    keycode = keycode.toLowerCase();
                    if (keycode === " ") {
                        keycode = "space";
                    } else if (keycode === ".") {
                        keycode = "dot";
                    }
                    MODIFIER_KEYS.forEach(modifierName => {
                        if (modifierName !== keycode) {
                            const modifierGetter = MODIFIER_KEY_GETTERS[modifierName];
                            if (modifierGetter(event)) {
                                key += modifierName + ".";
                            }
                        }
                    });
                    key += keycode;
                    return key === fullKeyCode;
                }
                static eventCallback(fullKey, handler, zone) {
                    return event => {
                        if (KeyEventsPlugin2.matchEventFullKeyCode(event, fullKey)) {
                            zone.runGuarded(() => handler(event));
                        }
                    };
                }
                static _normalizeKey(keyName) {
                    switch (keyName) {
                      case "esc":
                        return "escape";

                      default:
                        return keyName;
                    }
                }
            }
            KeyEventsPlugin2.fac = function KeyEventsPlugin_Factory(t) {
                return new (t || KeyEventsPlugin2)(core_inject(common_DOCUMENT));
            };
            KeyEventsPlugin2.prov = defineInjectable({
                token: KeyEventsPlugin2,
                factory: KeyEventsPlugin2.fac
            });
            return KeyEventsPlugin2;
        })();
        (function() {})();
        const platform_browser_NG_DEV_MODE = false;
        function bootstrapApplication(rootComponent, options) {
            return internalCreateApplication({
                rootComponent,
                ...createProvidersConfig(options)
            });
        }
        function createApplication(options) {
            return internalCreateApplication(createProvidersConfig(options));
        }
        function createProvidersConfig(options) {
            return {
                appProviders: [ ...BROWSER_MODULE_PROVIDERS, ...options?.providers ?? [] ],
                platformProviders: INTERNAL_BROWSER_PLATFORM_PROVIDERS
            };
        }
        function provideProtractorTestingSupport() {
            return [ ...TESTABILITY_PROVIDERS ];
        }
        function initDomAdapter() {
            BrowserDomAdapter.makeCurrent();
        }
        function errorHandler() {
            return new ErrorHandler;
        }
        function _document() {
            setDocument(document);
            return document;
        }
        const INTERNAL_BROWSER_PLATFORM_PROVIDERS = [ {
            provide: core_PLATFORM_ID,
            useValue: PLATFORM_BROWSER_ID
        }, {
            provide: PLATFORM_INITIALIZER,
            useValue: initDomAdapter,
            multi: true
        }, {
            provide: common_DOCUMENT,
            useFactory: _document,
            deps: []
        } ];
        const platformBrowser = createPlatformFactory(platformCore, "browser", INTERNAL_BROWSER_PLATFORM_PROVIDERS);
        const BROWSER_MODULE_PROVIDERS_MARKER = new InjectionToken(platform_browser_NG_DEV_MODE ? "BrowserModule Providers Marker" : "");
        const TESTABILITY_PROVIDERS = [ {
            provide: TESTABILITY_GETTER,
            useClass: BrowserGetTestability,
            deps: []
        }, {
            provide: TESTABILITY,
            useClass: Testability,
            deps: [ core_NgZone, TestabilityRegistry, TESTABILITY_GETTER ]
        }, {
            provide: Testability,
            useClass: Testability,
            deps: [ core_NgZone, TestabilityRegistry, TESTABILITY_GETTER ]
        } ];
        const BROWSER_MODULE_PROVIDERS = [ {
            provide: INJECTOR_SCOPE,
            useValue: "root"
        }, {
            provide: ErrorHandler,
            useFactory: errorHandler,
            deps: []
        }, {
            provide: EVENT_MANAGER_PLUGINS,
            useClass: DomEventsPlugin,
            multi: true,
            deps: [ common_DOCUMENT, core_NgZone, core_PLATFORM_ID ]
        }, {
            provide: EVENT_MANAGER_PLUGINS,
            useClass: KeyEventsPlugin,
            multi: true,
            deps: [ common_DOCUMENT ]
        }, {
            provide: DomRendererFactory2,
            useClass: DomRendererFactory2,
            deps: [ EventManager, DomSharedStylesHost, core_APP_ID ]
        }, {
            provide: RendererFactory2,
            useExisting: DomRendererFactory2
        }, {
            provide: SharedStylesHost,
            useExisting: DomSharedStylesHost
        }, {
            provide: DomSharedStylesHost,
            useClass: DomSharedStylesHost,
            deps: [ common_DOCUMENT ]
        }, {
            provide: EventManager,
            useClass: EventManager,
            deps: [ EVENT_MANAGER_PLUGINS, core_NgZone ]
        }, {
            provide: XhrFactory,
            useClass: BrowserXhr,
            deps: []
        }, platform_browser_NG_DEV_MODE ? {
            provide: BROWSER_MODULE_PROVIDERS_MARKER,
            useValue: true
        } : [] ];
        let BrowserModule = (() => {
            class BrowserModule2 {
                constructor(providersAlreadyPresent) {
                    if (platform_browser_NG_DEV_MODE && providersAlreadyPresent) {
                        throw new Error(`Providers from the \`BrowserModule\` have already been loaded. If you need access to common directives such as NgIf and NgFor, import the \`CommonModule\` instead.`);
                    }
                }
                static withServerTransition(params) {
                    return {
                        ngModule: BrowserModule2,
                        providers: [ {
                            provide: core_APP_ID,
                            useValue: params.appId
                        }, {
                            provide: TRANSITION_ID,
                            useExisting: core_APP_ID
                        }, SERVER_TRANSITION_PROVIDERS ]
                    };
                }
            }
            BrowserModule2.fac = function BrowserModule_Factory(t) {
                return new (t || BrowserModule2)(core_inject(BROWSER_MODULE_PROVIDERS_MARKER, 12));
            };
            BrowserModule2.mod = defineNgModule({
                type: BrowserModule2
            });
            BrowserModule2.inj = defineInjector({
                providers: [ ...BROWSER_MODULE_PROVIDERS, ...TESTABILITY_PROVIDERS ],
                imports: [ CommonModule, ApplicationModule ]
            });
            return BrowserModule2;
        })();
        (function() {})();
        function createMeta() {
            return new Meta(inject(DOCUMENT));
        }
        let Meta = null;
        (function() {})();
        const META_KEYS_MAP = {
            httpEquiv: "http-equiv"
        };
        function createTitle() {
            return new Title(core_inject(common_DOCUMENT));
        }
        let Title = (() => {
            class Title2 {
                constructor(_doc) {
                    this._doc = _doc;
                }
                getTitle() {
                    return this._doc.title;
                }
                setTitle(newTitle) {
                    this._doc.title = newTitle || "";
                }
            }
            Title2.fac = function Title_Factory(t) {
                return new (t || Title2)(core_inject(common_DOCUMENT));
            };
            Title2.prov = defineInjectable({
                token: Title2,
                factory: function Title_Factory(t) {
                    let r = null;
                    if (t) {
                        r = new t;
                    } else {
                        r = createTitle();
                    }
                    return r;
                },
                providedIn: "root"
            });
            return Title2;
        })();
        (function() {})();
        const platform_browser_CAMEL_CASE_REGEXP = /([A-Z])/g;
        const DASH_CASE_REGEXP = /-([a-z])/g;
        function platform_browser_camelCaseToDashCase(input) {
            return input.replace(platform_browser_CAMEL_CASE_REGEXP, (...m) => "-" + m[1].toLowerCase());
        }
        function dashCaseToCamelCase(input) {
            return input.replace(DASH_CASE_REGEXP, (...m) => m[1].toUpperCase());
        }
        function exportNgVar(name, value) {
            if (typeof COMPILED === "undefined" || !COMPILED) {
                const ng = global["ng"] = global["ng"] || {};
                ng[name] = value;
            }
        }
        const win = typeof window !== "undefined" && window || {};
        class ChangeDetectionPerfRecord {
            constructor(msPerTick, numTicks) {
                this.msPerTick = msPerTick;
                this.numTicks = numTicks;
            }
        }
        class AngularProfiler {
            constructor(ref) {
                this.appRef = ref.injector.get(ApplicationRef);
            }
            timeChangeDetection(config2) {
                const record = config2 && config2["record"];
                const profileName = "Change Detection";
                const isProfilerAvailable = win.console.profile != null;
                if (record && isProfilerAvailable) {
                    win.console.profile(profileName);
                }
                const start = performanceNow();
                let numTicks = 0;
                while (numTicks < 5 || performanceNow() - start < 500) {
                    this.appRef.tick();
                    numTicks++;
                }
                const end = performanceNow();
                if (record && isProfilerAvailable) {
                    win.console.profileEnd(profileName);
                }
                const msPerTick = (end - start) / numTicks;
                win.console.log(`ran ${numTicks} change detection cycles`);
                win.console.log(`${msPerTick.toFixed(2)} ms per check`);
                return new ChangeDetectionPerfRecord(msPerTick, numTicks);
            }
        }
        function performanceNow() {
            return win.performance && win.performance.now ? win.performance.now() : (new Date).getTime();
        }
        const PROFILER_GLOBAL_NAME = "profiler";
        function enableDebugTools(ref) {
            exportNgVar(PROFILER_GLOBAL_NAME, new AngularProfiler(ref));
            return ref;
        }
        function disableDebugTools() {
            exportNgVar(PROFILER_GLOBAL_NAME, null);
        }
        function escapeHtml(text) {
            const escapedText = {
                "&": "&a;",
                '"': "&q;",
                "'": "&s;",
                "<": "&l;",
                ">": "&g;"
            };
            return text.replace(/[&"'<>]/g, s => escapedText[s]);
        }
        function unescapeHtml(text) {
            const unescapedText = {
                "&a;": "&",
                "&q;": '"',
                "&s;": "'",
                "&l;": "<",
                "&g;": ">"
            };
            return text.replace(/&[^;]+;/g, s => unescapedText[s]);
        }
        function makeStateKey(key) {
            return key;
        }
        let TransferState = null;
        (function() {})();
        function retrieveTransferredState(doc, appId) {
            const script = doc.getElementById(appId + "-state");
            let initialState = {};
            if (script && script.textContent) {
                try {
                    initialState = JSON.parse(unescapeHtml(script.textContent));
                } catch (e) {
                    console.warn("Exception while restoring TransferState for app " + appId, e);
                }
            }
            return initialState;
        }
        let BrowserTransferStateModule = null;
        (function() {})();
        class By {
            static all() {
                return () => true;
            }
            static css(selector) {
                return debugElement => debugElement.nativeElement != null ? elementMatches(debugElement.nativeElement, selector) : false;
            }
            static directive(type) {
                return debugNode => debugNode.providerTokens.indexOf(type) !== -1;
            }
        }
        function elementMatches(n, selector) {
            if (getDOM().isElementNode(n)) {
                return n.matches && n.matches(selector) || n.msMatchesSelector && n.msMatchesSelector(selector) || n.webkitMatchesSelector && n.webkitMatchesSelector(selector);
            }
            return false;
        }
        const EVENT_NAMES = {
            pan: true,
            panstart: true,
            panmove: true,
            panend: true,
            pancancel: true,
            panleft: true,
            panright: true,
            panup: true,
            pandown: true,
            pinch: true,
            pinchstart: true,
            pinchmove: true,
            pinchend: true,
            pinchcancel: true,
            pinchin: true,
            pinchout: true,
            press: true,
            pressup: true,
            rotate: true,
            rotatestart: true,
            rotatemove: true,
            rotateend: true,
            rotatecancel: true,
            swipe: true,
            swipeleft: true,
            swiperight: true,
            swipeup: true,
            swipedown: true,
            tap: true,
            doubletap: true
        };
        const HAMMER_GESTURE_CONFIG = new InjectionToken("HammerGestureConfig");
        const HAMMER_LOADER = new InjectionToken("HammerLoader");
        let HammerGestureConfig = null;
        (function() {})();
        let HammerGesturesPlugin = null;
        (function() {})();
        let HammerModule = null;
        (function() {})();
        let DomSanitizer = null;
        (function() {})();
        function domSanitizerImplFactory(injector) {
            return new DomSanitizerImpl(injector.get(DOCUMENT));
        }
        let DomSanitizerImpl = null;
        (function() {})();
        const platform_browser_VERSION = new Version("14.3.0");
        const {isArray} = Array;
        const {getPrototypeOf, prototype: objectProto, keys: getKeys} = Object;
        function argsArgArrayOrObject(args) {
            if (args.length === 1) {
                const first2 = args[0];
                if (isArray(first2)) {
                    return {
                        args: first2,
                        keys: null
                    };
                }
                if (isPOJO(first2)) {
                    const keys = getKeys(first2);
                    return {
                        args: keys.map(key => first2[key]),
                        keys
                    };
                }
            }
            return {
                args,
                keys: null
            };
        }
        function isPOJO(obj) {
            return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto;
        }
        const {isArray: mapOneOrManyArgs_isArray} = Array;
        function callOrApply(fn, args) {
            return mapOneOrManyArgs_isArray(args) ? fn(...args) : fn(args);
        }
        function mapOneOrManyArgs(fn) {
            return map(args => callOrApply(fn, args));
        }
        function createObject(keys, values) {
            return keys.reduce((result, key, i) => (result[key] = values[i], result), {});
        }
        function forkJoin(...args) {
            const resultSelector = popResultSelector(args);
            const {args: sources, keys} = argsArgArrayOrObject(args);
            const result = new Observable_Observable(subscriber => {
                const {length} = sources;
                if (!length) {
                    subscriber.complete();
                    return;
                }
                const values = new Array(length);
                let remainingCompletions = length;
                let remainingEmissions = length;
                for (let sourceIndex = 0; sourceIndex < length; sourceIndex++) {
                    let hasValue = false;
                    innerFrom(sources[sourceIndex]).subscribe(createOperatorSubscriber(subscriber, value => {
                        if (!hasValue) {
                            hasValue = true;
                            remainingEmissions--;
                        }
                        values[sourceIndex] = value;
                    }, () => remainingCompletions--, void 0, () => {
                        if (!remainingCompletions || !hasValue) {
                            if (!remainingEmissions) {
                                subscriber.next(keys ? createObject(keys, values) : values);
                            }
                            subscriber.complete();
                        }
                    }));
                }
            });
            return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
        }
        let BaseControlValueAccessor = (() => {
            class BaseControlValueAccessor2 {
                constructor(_renderer, _elementRef) {
                    this._renderer = _renderer;
                    this._elementRef = _elementRef;
                    this.onChange = _ => {};
                    this.onTouched = () => {};
                }
                setProperty(key, value) {
                    this._renderer.setProperty(this._elementRef.nativeElement, key, value);
                }
                registerOnTouched(fn) {
                    this.onTouched = fn;
                }
                registerOnChange(fn) {
                    this.onChange = fn;
                }
                setDisabledState(isDisabled) {
                    this.setProperty("disabled", isDisabled);
                }
            }
            BaseControlValueAccessor2.fac = function BaseControlValueAccessor_Factory(t) {
                return new (t || BaseControlValueAccessor2)(directiveInject(core_Renderer2), directiveInject(core_ElementRef));
            };
            BaseControlValueAccessor2.dir = defineDirective({
                type: BaseControlValueAccessor2
            });
            return BaseControlValueAccessor2;
        })();
        (function() {})();
        let BuiltInControlValueAccessor = (() => {
            class BuiltInControlValueAccessor2 extends BaseControlValueAccessor {}
            BuiltInControlValueAccessor2.fac = function() {
                let BuiltInControlValueAccessor_BaseFactory;
                return function BuiltInControlValueAccessor_Factory(t) {
                    return (BuiltInControlValueAccessor_BaseFactory || (BuiltInControlValueAccessor_BaseFactory = getInheritedFactory(BuiltInControlValueAccessor2)))(t || BuiltInControlValueAccessor2);
                };
            }();
            BuiltInControlValueAccessor2.dir = defineDirective({
                type: BuiltInControlValueAccessor2,
                features: [ InheritDefinitionFeature ]
            });
            return BuiltInControlValueAccessor2;
        })();
        (function() {})();
        const NG_VALUE_ACCESSOR = new InjectionToken("NgValueAccessor");
        const CHECKBOX_VALUE_ACCESSOR = {
            provide: NG_VALUE_ACCESSOR,
            useExisting: forwardRef(() => CheckboxControlValueAccessor),
            multi: true
        };
        let CheckboxControlValueAccessor = (() => {
            class CheckboxControlValueAccessor2 extends BuiltInControlValueAccessor {
                writeValue(value) {
                    this.setProperty("checked", value);
                }
            }
            CheckboxControlValueAccessor2.fac = function() {
                let CheckboxControlValueAccessor_BaseFactory;
                return function CheckboxControlValueAccessor_Factory(t) {
                    return (CheckboxControlValueAccessor_BaseFactory || (CheckboxControlValueAccessor_BaseFactory = getInheritedFactory(CheckboxControlValueAccessor2)))(t || CheckboxControlValueAccessor2);
                };
            }();
            CheckboxControlValueAccessor2.dir = defineDirective({
                type: CheckboxControlValueAccessor2,
                selectors: [ [ "input", "type", "checkbox", "formControlName", "" ], [ "input", "type", "checkbox", "formControl", "" ], [ "input", "type", "checkbox", "ngModel", "" ] ],
                hostBindings: function CheckboxControlValueAccessor_HostBindings(rf, ctx) {
                    if (rf & 1) {
                        listener("change", function CheckboxControlValueAccessor_change_HostBindingHandler($event) {
                            return ctx.onChange($event.target.checked);
                        })("blur", function CheckboxControlValueAccessor_blur_HostBindingHandler() {
                            return ctx.onTouched();
                        });
                    }
                },
                features: [ ProvidersFeature([ CHECKBOX_VALUE_ACCESSOR ]), InheritDefinitionFeature ]
            });
            return CheckboxControlValueAccessor2;
        })();
        (function() {})();
        const DEFAULT_VALUE_ACCESSOR = {
            provide: NG_VALUE_ACCESSOR,
            useExisting: forwardRef(() => DefaultValueAccessor),
            multi: true
        };
        function _isAndroid() {
            const userAgent = getDOM() ? getDOM().getUserAgent() : "";
            return /android (\d+)/.test(userAgent.toLowerCase());
        }
        const COMPOSITION_BUFFER_MODE = new InjectionToken("CompositionEventMode");
        let DefaultValueAccessor = (() => {
            class DefaultValueAccessor2 extends BaseControlValueAccessor {
                constructor(renderer, elementRef, _compositionMode) {
                    super(renderer, elementRef);
                    this._compositionMode = _compositionMode;
                    this._composing = false;
                    if (this._compositionMode == null) {
                        this._compositionMode = !_isAndroid();
                    }
                }
                writeValue(value) {
                    const normalizedValue = value == null ? "" : value;
                    this.setProperty("value", normalizedValue);
                }
                _handleInput(value) {
                    if (!this._compositionMode || this._compositionMode && !this._composing) {
                        this.onChange(value);
                    }
                }
                _compositionStart() {
                    this._composing = true;
                }
                _compositionEnd(value) {
                    this._composing = false;
                    this._compositionMode && this.onChange(value);
                }
            }
            DefaultValueAccessor2.fac = function DefaultValueAccessor_Factory(t) {
                return new (t || DefaultValueAccessor2)(directiveInject(core_Renderer2), directiveInject(core_ElementRef), directiveInject(COMPOSITION_BUFFER_MODE, 8));
            };
            DefaultValueAccessor2.dir = defineDirective({
                type: DefaultValueAccessor2,
                selectors: [ [ "input", "formControlName", "", 3, "type", "checkbox" ], [ "textarea", "formControlName", "" ], [ "input", "formControl", "", 3, "type", "checkbox" ], [ "textarea", "formControl", "" ], [ "input", "ngModel", "", 3, "type", "checkbox" ], [ "textarea", "ngModel", "" ], [ "", "ngDefaultControl", "" ] ],
                hostBindings: function DefaultValueAccessor_HostBindings(rf, ctx) {
                    if (rf & 1) {
                        listener("input", function DefaultValueAccessor_input_HostBindingHandler($event) {
                            return ctx._handleInput($event.target.value);
                        })("blur", function DefaultValueAccessor_blur_HostBindingHandler() {
                            return ctx.onTouched();
                        })("compositionstart", function DefaultValueAccessor_compositionstart_HostBindingHandler() {
                            return ctx._compositionStart();
                        })("compositionend", function DefaultValueAccessor_compositionend_HostBindingHandler($event) {
                            return ctx._compositionEnd($event.target.value);
                        });
                    }
                },
                features: [ ProvidersFeature([ DEFAULT_VALUE_ACCESSOR ]), InheritDefinitionFeature ]
            });
            return DefaultValueAccessor2;
        })();
        (function() {})();
        const forms_NG_DEV_MODE$1 = false;
        function isEmptyInputValue(value) {
            return value == null || (typeof value === "string" || Array.isArray(value)) && value.length === 0;
        }
        function hasValidLength(value) {
            return value != null && typeof value.length === "number";
        }
        const NG_VALIDATORS = new InjectionToken("NgValidators");
        const NG_ASYNC_VALIDATORS = new InjectionToken("NgAsyncValidators");
        const EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
        class Validators {
            static min(min) {
                return minValidator(min);
            }
            static max(max) {
                return maxValidator(max);
            }
            static required(control) {
                return requiredValidator(control);
            }
            static requiredTrue(control) {
                return requiredTrueValidator(control);
            }
            static email(control) {
                return emailValidator(control);
            }
            static minLength(minLength) {
                return minLengthValidator(minLength);
            }
            static maxLength(maxLength) {
                return maxLengthValidator(maxLength);
            }
            static pattern(pattern) {
                return patternValidator(pattern);
            }
            static nullValidator(control) {
                return nullValidator(control);
            }
            static compose(validators) {
                return compose(validators);
            }
            static composeAsync(validators) {
                return composeAsync(validators);
            }
        }
        function minValidator(min) {
            return control => {
                if (isEmptyInputValue(control.value) || isEmptyInputValue(min)) {
                    return null;
                }
                const value = parseFloat(control.value);
                return !isNaN(value) && value < min ? {
                    min: {
                        min,
                        actual: control.value
                    }
                } : null;
            };
        }
        function maxValidator(max) {
            return control => {
                if (isEmptyInputValue(control.value) || isEmptyInputValue(max)) {
                    return null;
                }
                const value = parseFloat(control.value);
                return !isNaN(value) && value > max ? {
                    max: {
                        max,
                        actual: control.value
                    }
                } : null;
            };
        }
        function requiredValidator(control) {
            return isEmptyInputValue(control.value) ? {
                required: true
            } : null;
        }
        function requiredTrueValidator(control) {
            return control.value === true ? null : {
                required: true
            };
        }
        function emailValidator(control) {
            if (isEmptyInputValue(control.value)) {
                return null;
            }
            return EMAIL_REGEXP.test(control.value) ? null : {
                email: true
            };
        }
        function minLengthValidator(minLength) {
            return control => {
                if (isEmptyInputValue(control.value) || !hasValidLength(control.value)) {
                    return null;
                }
                return control.value.length < minLength ? {
                    minlength: {
                        requiredLength: minLength,
                        actualLength: control.value.length
                    }
                } : null;
            };
        }
        function maxLengthValidator(maxLength) {
            return control => hasValidLength(control.value) && control.value.length > maxLength ? {
                maxlength: {
                    requiredLength: maxLength,
                    actualLength: control.value.length
                }
            } : null;
        }
        function patternValidator(pattern) {
            if (!pattern) {
                return nullValidator;
            }
            let regex;
            let regexStr;
            if (typeof pattern === "string") {
                regexStr = "";
                if (pattern.charAt(0) !== "^") {
                    regexStr += "^";
                }
                regexStr += pattern;
                if (pattern.charAt(pattern.length - 1) !== "$") {
                    regexStr += "$";
                }
                regex = new RegExp(regexStr);
            } else {
                regexStr = pattern.toString();
                regex = pattern;
            }
            return control => {
                if (isEmptyInputValue(control.value)) {
                    return null;
                }
                const value = control.value;
                return regex.test(value) ? null : {
                    pattern: {
                        requiredPattern: regexStr,
                        actualValue: value
                    }
                };
            };
        }
        function nullValidator(control) {
            return null;
        }
        function isPresent(o) {
            return o != null;
        }
        function toObservable(value) {
            const obs = core_isPromise(value) ? from(value) : value;
            if (forms_NG_DEV_MODE$1 && !isObservable(obs)) {
                let errorMessage = `Expected async validator to return Promise or Observable.`;
                if (typeof value === "object") {
                    errorMessage += " Are you using a synchronous validator where an async validator is expected?";
                }
                throw new RuntimeError(-1101, errorMessage);
            }
            return obs;
        }
        function mergeErrors(arrayOfErrors) {
            let res = {};
            arrayOfErrors.forEach(errors => {
                res = errors != null ? {
                    ...res,
                    ...errors
                } : res;
            });
            return Object.keys(res).length === 0 ? null : res;
        }
        function executeValidators(control, validators) {
            return validators.map(validator => validator(control));
        }
        function isValidatorFn(validator) {
            return !validator.validate;
        }
        function normalizeValidators(validators) {
            return validators.map(validator => isValidatorFn(validator) ? validator : c => validator.validate(c));
        }
        function compose(validators) {
            if (!validators) {
                return null;
            }
            const presentValidators = validators.filter(isPresent);
            if (presentValidators.length == 0) {
                return null;
            }
            return function(control) {
                return mergeErrors(executeValidators(control, presentValidators));
            };
        }
        function composeValidators(validators) {
            return validators != null ? compose(normalizeValidators(validators)) : null;
        }
        function composeAsync(validators) {
            if (!validators) {
                return null;
            }
            const presentValidators = validators.filter(isPresent);
            if (presentValidators.length == 0) {
                return null;
            }
            return function(control) {
                const observables = executeValidators(control, presentValidators).map(toObservable);
                return forkJoin(observables).pipe(map(mergeErrors));
            };
        }
        function composeAsyncValidators(validators) {
            return validators != null ? composeAsync(normalizeValidators(validators)) : null;
        }
        function mergeValidators(controlValidators, dirValidator) {
            if (controlValidators === null) {
                return [ dirValidator ];
            }
            return Array.isArray(controlValidators) ? [ ...controlValidators, dirValidator ] : [ controlValidators, dirValidator ];
        }
        function getControlValidators(control) {
            return control._rawValidators;
        }
        function getControlAsyncValidators(control) {
            return control._rawAsyncValidators;
        }
        function makeValidatorsArray(validators) {
            if (!validators) {
                return [];
            }
            return Array.isArray(validators) ? validators : [ validators ];
        }
        function hasValidator(validators, validator) {
            return Array.isArray(validators) ? validators.includes(validator) : validators === validator;
        }
        function addValidators(validators, currentValidators) {
            const current = makeValidatorsArray(currentValidators);
            const validatorsToAdd = makeValidatorsArray(validators);
            validatorsToAdd.forEach(v => {
                if (!hasValidator(current, v)) {
                    current.push(v);
                }
            });
            return current;
        }
        function removeValidators(validators, currentValidators) {
            return makeValidatorsArray(currentValidators).filter(v => !hasValidator(validators, v));
        }
        class AbstractControlDirective {
            constructor() {
                this._rawValidators = [];
                this._rawAsyncValidators = [];
                this._onDestroyCallbacks = [];
            }
            get value() {
                return this.control ? this.control.value : null;
            }
            get valid() {
                return this.control ? this.control.valid : null;
            }
            get invalid() {
                return this.control ? this.control.invalid : null;
            }
            get pending() {
                return this.control ? this.control.pending : null;
            }
            get disabled() {
                return this.control ? this.control.disabled : null;
            }
            get enabled() {
                return this.control ? this.control.enabled : null;
            }
            get errors() {
                return this.control ? this.control.errors : null;
            }
            get pristine() {
                return this.control ? this.control.pristine : null;
            }
            get dirty() {
                return this.control ? this.control.dirty : null;
            }
            get touched() {
                return this.control ? this.control.touched : null;
            }
            get status() {
                return this.control ? this.control.status : null;
            }
            get untouched() {
                return this.control ? this.control.untouched : null;
            }
            get statusChanges() {
                return this.control ? this.control.statusChanges : null;
            }
            get valueChanges() {
                return this.control ? this.control.valueChanges : null;
            }
            get path() {
                return null;
            }
            _setValidators(validators) {
                this._rawValidators = validators || [];
                this._composedValidatorFn = composeValidators(this._rawValidators);
            }
            _setAsyncValidators(validators) {
                this._rawAsyncValidators = validators || [];
                this._composedAsyncValidatorFn = composeAsyncValidators(this._rawAsyncValidators);
            }
            get validator() {
                return this._composedValidatorFn || null;
            }
            get asyncValidator() {
                return this._composedAsyncValidatorFn || null;
            }
            _registerOnDestroy(fn) {
                this._onDestroyCallbacks.push(fn);
            }
            _invokeOnDestroyCallbacks() {
                this._onDestroyCallbacks.forEach(fn => fn());
                this._onDestroyCallbacks = [];
            }
            reset(value = void 0) {
                if (this.control) {
                    this.control.reset(value);
                }
            }
            hasError(errorCode, path) {
                return this.control ? this.control.hasError(errorCode, path) : false;
            }
            getError(errorCode, path) {
                return this.control ? this.control.getError(errorCode, path) : null;
            }
        }
        class ControlContainer extends AbstractControlDirective {
            get formDirective() {
                return null;
            }
            get path() {
                return null;
            }
        }
        class NgControl extends AbstractControlDirective {
            constructor() {
                super(...arguments);
                this._parent = null;
                this.name = null;
                this.valueAccessor = null;
            }
        }
        class AbstractControlStatus {
            constructor(cd) {
                this._cd = cd;
            }
            get isTouched() {
                return !!this._cd?.control?.touched;
            }
            get isUntouched() {
                return !!this._cd?.control?.untouched;
            }
            get isPristine() {
                return !!this._cd?.control?.pristine;
            }
            get isDirty() {
                return !!this._cd?.control?.dirty;
            }
            get isValid() {
                return !!this._cd?.control?.valid;
            }
            get isInvalid() {
                return !!this._cd?.control?.invalid;
            }
            get isPending() {
                return !!this._cd?.control?.pending;
            }
            get isSubmitted() {
                return !!this._cd?.submitted;
            }
        }
        const ngControlStatusHost = {
            "[class.ng-untouched]": "isUntouched",
            "[class.ng-touched]": "isTouched",
            "[class.ng-pristine]": "isPristine",
            "[class.ng-dirty]": "isDirty",
            "[class.ng-valid]": "isValid",
            "[class.ng-invalid]": "isInvalid",
            "[class.ng-pending]": "isPending"
        };
        const ngGroupStatusHost = {
            ...ngControlStatusHost,
            "[class.ng-submitted]": "isSubmitted"
        };
        let NgControlStatus = (() => {
            class NgControlStatus2 extends AbstractControlStatus {
                constructor(cd) {
                    super(cd);
                }
            }
            NgControlStatus2.fac = function NgControlStatus_Factory(t) {
                return new (t || NgControlStatus2)(directiveInject(NgControl, 2));
            };
            NgControlStatus2.dir = defineDirective({
                type: NgControlStatus2,
                selectors: [ [ "", "formControlName", "" ], [ "", "ngModel", "" ], [ "", "formControl", "" ] ],
                hostVars: 14,
                hostBindings: function NgControlStatus_HostBindings(rf, ctx) {
                    if (rf & 2) {
                        classProp("ng-untouched", ctx.isUntouched)("ng-touched", ctx.isTouched)("ng-pristine", ctx.isPristine)("ng-dirty", ctx.isDirty)("ng-valid", ctx.isValid)("ng-invalid", ctx.isInvalid)("ng-pending", ctx.isPending);
                    }
                },
                features: [ InheritDefinitionFeature ]
            });
            return NgControlStatus2;
        })();
        (function() {})();
        let NgControlStatusGroup = (() => {
            class NgControlStatusGroup2 extends AbstractControlStatus {
                constructor(cd) {
                    super(cd);
                }
            }
            NgControlStatusGroup2.fac = function NgControlStatusGroup_Factory(t) {
                return new (t || NgControlStatusGroup2)(directiveInject(ControlContainer, 10));
            };
            NgControlStatusGroup2.dir = defineDirective({
                type: NgControlStatusGroup2,
                selectors: [ [ "", "formGroupName", "" ], [ "", "formArrayName", "" ], [ "", "ngModelGroup", "" ], [ "", "formGroup", "" ], [ "form", 3, "ngNoForm", "" ], [ "", "ngForm", "" ] ],
                hostVars: 16,
                hostBindings: function NgControlStatusGroup_HostBindings(rf, ctx) {
                    if (rf & 2) {
                        classProp("ng-untouched", ctx.isUntouched)("ng-touched", ctx.isTouched)("ng-pristine", ctx.isPristine)("ng-dirty", ctx.isDirty)("ng-valid", ctx.isValid)("ng-invalid", ctx.isInvalid)("ng-pending", ctx.isPending)("ng-submitted", ctx.isSubmitted);
                    }
                },
                features: [ InheritDefinitionFeature ]
            });
            return NgControlStatusGroup2;
        })();
        (function() {})();
        const formControlNameExample = `\n  <div [formGroup]="myGroup">\n    <input formControlName="firstName">\n  </div>\n\n  In your class:\n\n  this.myGroup = new FormGroup({\n      firstName: new FormControl()\n  });`;
        const formGroupNameExample = `\n  <div [formGroup]="myGroup">\n      <div formGroupName="person">\n        <input formControlName="firstName">\n      </div>\n  </div>\n\n  In your class:\n\n  this.myGroup = new FormGroup({\n      person: new FormGroup({ firstName: new FormControl() })\n  });`;
        const formArrayNameExample = `\n  <div [formGroup]="myGroup">\n    <div formArrayName="cities">\n      <div *ngFor="let city of cityArray.controls; index as i">\n        <input [formControlName]="i">\n      </div>\n    </div>\n  </div>\n\n  In your class:\n\n  this.cityArray = new FormArray([new FormControl('SF')]);\n  this.myGroup = new FormGroup({\n    cities: this.cityArray\n  });`;
        const ngModelGroupExample = `\n  <form>\n      <div ngModelGroup="person">\n        <input [(ngModel)]="person.name" name="firstName">\n      </div>\n  </form>`;
        const ngModelWithFormGroupExample = `\n  <div [formGroup]="myGroup">\n      <input formControlName="firstName">\n      <input [(ngModel)]="showMoreControls" [ngModelOptions]="{standalone: true}">\n  </div>\n`;
        function controlParentException() {
            return new RuntimeError(1050, `formControlName must be used with a parent formGroup directive.  You'll want to add a formGroup\n      directive and pass it an existing FormGroup instance (you can create one in your class).\n\n    Example:\n\n    ${formControlNameExample}`);
        }
        function ngModelGroupException() {
            return new RuntimeError(1051, `formControlName cannot be used with an ngModelGroup parent. It is only compatible with parents\n      that also have a "form" prefix: formGroupName, formArrayName, or formGroup.\n\n      Option 1:  Update the parent to be formGroupName (reactive form strategy)\n\n      ${formGroupNameExample}\n\n      Option 2: Use ngModel instead of formControlName (template-driven strategy)\n\n      ${ngModelGroupExample}`);
        }
        function missingFormException() {
            return new RuntimeError(1052, `formGroup expects a FormGroup instance. Please pass one in.\n\n      Example:\n\n      ${formControlNameExample}`);
        }
        function groupParentException() {
            return new RuntimeError(1053, `formGroupName must be used with a parent formGroup directive.  You'll want to add a formGroup\n    directive and pass it an existing FormGroup instance (you can create one in your class).\n\n    Example:\n\n    ${formGroupNameExample}`);
        }
        function arrayParentException() {
            return new RuntimeError(1054, `formArrayName must be used with a parent formGroup directive.  You'll want to add a formGroup\n      directive and pass it an existing FormGroup instance (you can create one in your class).\n\n      Example:\n\n      ${formArrayNameExample}`);
        }
        const disabledAttrWarning = `\n  It looks like you're using the disabled attribute with a reactive form directive. If you set disabled to true\n  when you set up this control in your component class, the disabled attribute will actually be set in the DOM for\n  you. We recommend using this approach to avoid 'changed after checked' errors.\n\n  Example:\n  // Specify the \`disabled\` property at control creation time:\n  form = new FormGroup({\n    first: new FormControl({value: 'Nancy', disabled: true}, Validators.required),\n    last: new FormControl('Drew', Validators.required)\n  });\n\n  // Controls can also be enabled/disabled after creation:\n  form.get('first')?.enable();\n  form.get('last')?.disable();\n`;
        const asyncValidatorsDroppedWithOptsWarning = `\n  It looks like you're constructing using a FormControl with both an options argument and an\n  async validators argument. Mixing these arguments will cause your async validators to be dropped.\n  You should either put all your validators in the options object, or in separate validators\n  arguments. For example:\n\n  // Using validators arguments\n  fc = new FormControl(42, Validators.required, myAsyncValidator);\n\n  // Using AbstractControlOptions\n  fc = new FormControl(42, {validators: Validators.required, asyncValidators: myAV});\n\n  // Do NOT mix them: async validators will be dropped!\n  fc = new FormControl(42, {validators: Validators.required}, /* Oops! */ myAsyncValidator);\n`;
        function ngModelWarning(directiveName) {
            return `\n  It looks like you're using ngModel on the same form field as ${directiveName}.\n  Support for using the ngModel input property and ngModelChange event with\n  reactive form directives has been deprecated in Angular v6 and will be removed\n  in a future version of Angular.\n\n  For more information on this, see our API docs here:\n  https://angular.io/api/forms/${directiveName === "formControl" ? "FormControlDirective" : "FormControlName"}#use-with-ngmodel\n  `;
        }
        function describeKey(isFormGroup2, key) {
            return isFormGroup2 ? `with name: '${key}'` : `at index: ${key}`;
        }
        function noControlsError(isFormGroup2) {
            return `\n    There are no form controls registered with this ${isFormGroup2 ? "group" : "array"} yet. If you're using ngModel,\n    you may want to check next tick (e.g. use setTimeout).\n  `;
        }
        function missingControlError(isFormGroup2, key) {
            return `Cannot find form control ${describeKey(isFormGroup2, key)}`;
        }
        function missingControlValueError(isFormGroup2, key) {
            return `Must supply a value for form control ${describeKey(isFormGroup2, key)}`;
        }
        const forms_NG_DEV_MODE = false;
        const VALID = "VALID";
        const INVALID = "INVALID";
        const PENDING = "PENDING";
        const DISABLED = "DISABLED";
        function pickValidators(validatorOrOpts) {
            return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.validators : validatorOrOpts) || null;
        }
        function coerceToValidator(validator) {
            return Array.isArray(validator) ? composeValidators(validator) : validator || null;
        }
        function pickAsyncValidators(asyncValidator, validatorOrOpts) {
            if (false) {
                if (isOptionsObj(validatorOrOpts) && asyncValidator) {
                    console.warn(asyncValidatorsDroppedWithOptsWarning);
                }
            }
            return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.asyncValidators : asyncValidator) || null;
        }
        function coerceToAsyncValidator(asyncValidator) {
            return Array.isArray(asyncValidator) ? composeAsyncValidators(asyncValidator) : asyncValidator || null;
        }
        function isOptionsObj(validatorOrOpts) {
            return validatorOrOpts != null && !Array.isArray(validatorOrOpts) && typeof validatorOrOpts === "object";
        }
        function assertControlPresent(parent, isGroup, key) {
            const controls = parent.controls;
            const collection = isGroup ? Object.keys(controls) : controls;
            if (!collection.length) {
                throw new RuntimeError(1e3, forms_NG_DEV_MODE ? noControlsError(isGroup) : "");
            }
            if (!controls[key]) {
                throw new RuntimeError(1001, forms_NG_DEV_MODE ? missingControlError(isGroup, key) : "");
            }
        }
        function assertAllValuesPresent(control, isGroup, value) {
            control._forEachChild((_, key) => {
                if (value[key] === void 0) {
                    throw new RuntimeError(1002, forms_NG_DEV_MODE ? missingControlValueError(isGroup, key) : "");
                }
            });
        }
        class AbstractControl {
            constructor(validators, asyncValidators) {
                this._pendingDirty = false;
                this._hasOwnPendingAsyncValidator = false;
                this._pendingTouched = false;
                this._onCollectionChange = () => {};
                this._parent = null;
                this.pristine = true;
                this.touched = false;
                this._onDisabledChange = [];
                this._rawValidators = validators;
                this._rawAsyncValidators = asyncValidators;
                this._composedValidatorFn = coerceToValidator(this._rawValidators);
                this._composedAsyncValidatorFn = coerceToAsyncValidator(this._rawAsyncValidators);
            }
            get validator() {
                return this._composedValidatorFn;
            }
            set validator(validatorFn) {
                this._rawValidators = this._composedValidatorFn = validatorFn;
            }
            get asyncValidator() {
                return this._composedAsyncValidatorFn;
            }
            set asyncValidator(asyncValidatorFn) {
                this._rawAsyncValidators = this._composedAsyncValidatorFn = asyncValidatorFn;
            }
            get parent() {
                return this._parent;
            }
            get valid() {
                return this.status === VALID;
            }
            get invalid() {
                return this.status === INVALID;
            }
            get pending() {
                return this.status == PENDING;
            }
            get disabled() {
                return this.status === DISABLED;
            }
            get enabled() {
                return this.status !== DISABLED;
            }
            get dirty() {
                return !this.pristine;
            }
            get untouched() {
                return !this.touched;
            }
            get updateOn() {
                return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : "change";
            }
            setValidators(validators) {
                this._rawValidators = validators;
                this._composedValidatorFn = coerceToValidator(validators);
            }
            setAsyncValidators(validators) {
                this._rawAsyncValidators = validators;
                this._composedAsyncValidatorFn = coerceToAsyncValidator(validators);
            }
            addValidators(validators) {
                this.setValidators(addValidators(validators, this._rawValidators));
            }
            addAsyncValidators(validators) {
                this.setAsyncValidators(addValidators(validators, this._rawAsyncValidators));
            }
            removeValidators(validators) {
                this.setValidators(removeValidators(validators, this._rawValidators));
            }
            removeAsyncValidators(validators) {
                this.setAsyncValidators(removeValidators(validators, this._rawAsyncValidators));
            }
            hasValidator(validator) {
                return hasValidator(this._rawValidators, validator);
            }
            hasAsyncValidator(validator) {
                return hasValidator(this._rawAsyncValidators, validator);
            }
            clearValidators() {
                this.validator = null;
            }
            clearAsyncValidators() {
                this.asyncValidator = null;
            }
            markAsTouched(opts = {}) {
                this.touched = true;
                if (this._parent && !opts.onlySelf) {
                    this._parent.markAsTouched(opts);
                }
            }
            markAllAsTouched() {
                this.markAsTouched({
                    onlySelf: true
                });
                this._forEachChild(control => control.markAllAsTouched());
            }
            markAsUntouched(opts = {}) {
                this.touched = false;
                this._pendingTouched = false;
                this._forEachChild(control => {
                    control.markAsUntouched({
                        onlySelf: true
                    });
                });
                if (this._parent && !opts.onlySelf) {
                    this._parent._updateTouched(opts);
                }
            }
            markAsDirty(opts = {}) {
                this.pristine = false;
                if (this._parent && !opts.onlySelf) {
                    this._parent.markAsDirty(opts);
                }
            }
            markAsPristine(opts = {}) {
                this.pristine = true;
                this._pendingDirty = false;
                this._forEachChild(control => {
                    control.markAsPristine({
                        onlySelf: true
                    });
                });
                if (this._parent && !opts.onlySelf) {
                    this._parent._updatePristine(opts);
                }
            }
            markAsPending(opts = {}) {
                this.status = PENDING;
                if (opts.emitEvent !== false) {
                    this.statusChanges.emit(this.status);
                }
                if (this._parent && !opts.onlySelf) {
                    this._parent.markAsPending(opts);
                }
            }
            disable(opts = {}) {
                const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);
                this.status = DISABLED;
                this.errors = null;
                this._forEachChild(control => {
                    control.disable({
                        ...opts,
                        onlySelf: true
                    });
                });
                this._updateValue();
                if (opts.emitEvent !== false) {
                    this.valueChanges.emit(this.value);
                    this.statusChanges.emit(this.status);
                }
                this._updateAncestors({
                    ...opts,
                    skipPristineCheck
                });
                this._onDisabledChange.forEach(changeFn => changeFn(true));
            }
            enable(opts = {}) {
                const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);
                this.status = VALID;
                this._forEachChild(control => {
                    control.enable({
                        ...opts,
                        onlySelf: true
                    });
                });
                this.updateValueAndValidity({
                    onlySelf: true,
                    emitEvent: opts.emitEvent
                });
                this._updateAncestors({
                    ...opts,
                    skipPristineCheck
                });
                this._onDisabledChange.forEach(changeFn => changeFn(false));
            }
            _updateAncestors(opts) {
                if (this._parent && !opts.onlySelf) {
                    this._parent.updateValueAndValidity(opts);
                    if (!opts.skipPristineCheck) {
                        this._parent._updatePristine();
                    }
                    this._parent._updateTouched();
                }
            }
            setParent(parent) {
                this._parent = parent;
            }
            getRawValue() {
                return this.value;
            }
            updateValueAndValidity(opts = {}) {
                this._setInitialStatus();
                this._updateValue();
                if (this.enabled) {
                    this._cancelExistingSubscription();
                    this.errors = this._runValidator();
                    this.status = this._calculateStatus();
                    if (this.status === VALID || this.status === PENDING) {
                        this._runAsyncValidator(opts.emitEvent);
                    }
                }
                if (opts.emitEvent !== false) {
                    this.valueChanges.emit(this.value);
                    this.statusChanges.emit(this.status);
                }
                if (this._parent && !opts.onlySelf) {
                    this._parent.updateValueAndValidity(opts);
                }
            }
            _updateTreeValidity(opts = {
                emitEvent: true
            }) {
                this._forEachChild(ctrl => ctrl._updateTreeValidity(opts));
                this.updateValueAndValidity({
                    onlySelf: true,
                    emitEvent: opts.emitEvent
                });
            }
            _setInitialStatus() {
                this.status = this._allControlsDisabled() ? DISABLED : VALID;
            }
            _runValidator() {
                return this.validator ? this.validator(this) : null;
            }
            _runAsyncValidator(emitEvent) {
                if (this.asyncValidator) {
                    this.status = PENDING;
                    this._hasOwnPendingAsyncValidator = true;
                    const obs = toObservable(this.asyncValidator(this));
                    this._asyncValidationSubscription = obs.subscribe(errors => {
                        this._hasOwnPendingAsyncValidator = false;
                        this.setErrors(errors, {
                            emitEvent
                        });
                    });
                }
            }
            _cancelExistingSubscription() {
                if (this._asyncValidationSubscription) {
                    this._asyncValidationSubscription.unsubscribe();
                    this._hasOwnPendingAsyncValidator = false;
                }
            }
            setErrors(errors, opts = {}) {
                this.errors = errors;
                this._updateControlsErrors(opts.emitEvent !== false);
            }
            get(path) {
                let currPath = path;
                if (currPath == null) {
                    return null;
                }
                if (!Array.isArray(currPath)) {
                    currPath = currPath.split(".");
                }
                if (currPath.length === 0) {
                    return null;
                }
                return currPath.reduce((control, name) => control && control._find(name), this);
            }
            getError(errorCode, path) {
                const control = path ? this.get(path) : this;
                return control && control.errors ? control.errors[errorCode] : null;
            }
            hasError(errorCode, path) {
                return !!this.getError(errorCode, path);
            }
            get root() {
                let x = this;
                while (x._parent) {
                    x = x._parent;
                }
                return x;
            }
            _updateControlsErrors(emitEvent) {
                this.status = this._calculateStatus();
                if (emitEvent) {
                    this.statusChanges.emit(this.status);
                }
                if (this._parent) {
                    this._parent._updateControlsErrors(emitEvent);
                }
            }
            _initObservables() {
                this.valueChanges = new EventEmitter;
                this.statusChanges = new EventEmitter;
            }
            _calculateStatus() {
                if (this._allControlsDisabled()) {
                    return DISABLED;
                }
                if (this.errors) {
                    return INVALID;
                }
                if (this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(PENDING)) {
                    return PENDING;
                }
                if (this._anyControlsHaveStatus(INVALID)) {
                    return INVALID;
                }
                return VALID;
            }
            _anyControlsHaveStatus(status) {
                return this._anyControls(control => control.status === status);
            }
            _anyControlsDirty() {
                return this._anyControls(control => control.dirty);
            }
            _anyControlsTouched() {
                return this._anyControls(control => control.touched);
            }
            _updatePristine(opts = {}) {
                this.pristine = !this._anyControlsDirty();
                if (this._parent && !opts.onlySelf) {
                    this._parent._updatePristine(opts);
                }
            }
            _updateTouched(opts = {}) {
                this.touched = this._anyControlsTouched();
                if (this._parent && !opts.onlySelf) {
                    this._parent._updateTouched(opts);
                }
            }
            _registerOnCollectionChange(fn) {
                this._onCollectionChange = fn;
            }
            _setUpdateStrategy(opts) {
                if (isOptionsObj(opts) && opts.updateOn != null) {
                    this._updateOn = opts.updateOn;
                }
            }
            _parentMarkedDirty(onlySelf) {
                const parentDirty = this._parent && this._parent.dirty;
                return !onlySelf && !!parentDirty && !this._parent._anyControlsDirty();
            }
            _find(name) {
                return null;
            }
        }
        class FormGroup extends AbstractControl {
            constructor(controls, validatorOrOpts, asyncValidator) {
                super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
                this.controls = controls;
                this._initObservables();
                this._setUpdateStrategy(validatorOrOpts);
                this._setUpControls();
                this.updateValueAndValidity({
                    onlySelf: true,
                    emitEvent: !!this.asyncValidator
                });
            }
            registerControl(name, control) {
                if (this.controls[name]) {
                    return this.controls[name];
                }
                this.controls[name] = control;
                control.setParent(this);
                control._registerOnCollectionChange(this._onCollectionChange);
                return control;
            }
            addControl(name, control, options = {}) {
                this.registerControl(name, control);
                this.updateValueAndValidity({
                    emitEvent: options.emitEvent
                });
                this._onCollectionChange();
            }
            removeControl(name, options = {}) {
                if (this.controls[name]) {
                    this.controls[name]._registerOnCollectionChange(() => {});
                }
                delete this.controls[name];
                this.updateValueAndValidity({
                    emitEvent: options.emitEvent
                });
                this._onCollectionChange();
            }
            setControl(name, control, options = {}) {
                if (this.controls[name]) {
                    this.controls[name]._registerOnCollectionChange(() => {});
                }
                delete this.controls[name];
                if (control) {
                    this.registerControl(name, control);
                }
                this.updateValueAndValidity({
                    emitEvent: options.emitEvent
                });
                this._onCollectionChange();
            }
            contains(controlName) {
                return this.controls.hasOwnProperty(controlName) && this.controls[controlName].enabled;
            }
            setValue(value, options = {}) {
                assertAllValuesPresent(this, true, value);
                Object.keys(value).forEach(name => {
                    assertControlPresent(this, true, name);
                    this.controls[name].setValue(value[name], {
                        onlySelf: true,
                        emitEvent: options.emitEvent
                    });
                });
                this.updateValueAndValidity(options);
            }
            patchValue(value, options = {}) {
                if (value == null) {
                    return;
                }
                Object.keys(value).forEach(name => {
                    const control = this.controls[name];
                    if (control) {
                        control.patchValue(value[name], {
                            onlySelf: true,
                            emitEvent: options.emitEvent
                        });
                    }
                });
                this.updateValueAndValidity(options);
            }
            reset(value = {}, options = {}) {
                this._forEachChild((control, name) => {
                    control.reset(value[name], {
                        onlySelf: true,
                        emitEvent: options.emitEvent
                    });
                });
                this._updatePristine(options);
                this._updateTouched(options);
                this.updateValueAndValidity(options);
            }
            getRawValue() {
                return this._reduceChildren({}, (acc, control, name) => {
                    acc[name] = control.getRawValue();
                    return acc;
                });
            }
            _syncPendingControls() {
                let subtreeUpdated = this._reduceChildren(false, (updated, child) => child._syncPendingControls() ? true : updated);
                if (subtreeUpdated) {
                    this.updateValueAndValidity({
                        onlySelf: true
                    });
                }
                return subtreeUpdated;
            }
            _forEachChild(cb) {
                Object.keys(this.controls).forEach(key => {
                    const control = this.controls[key];
                    control && cb(control, key);
                });
            }
            _setUpControls() {
                this._forEachChild(control => {
                    control.setParent(this);
                    control._registerOnCollectionChange(this._onCollectionChange);
                });
            }
            _updateValue() {
                this.value = this._reduceValue();
            }
            _anyControls(condition) {
                for (const [controlName, control] of Object.entries(this.controls)) {
                    if (this.contains(controlName) && condition(control)) {
                        return true;
                    }
                }
                return false;
            }
            _reduceValue() {
                let acc = {};
                return this._reduceChildren(acc, (acc2, control, name) => {
                    if (control.enabled || this.disabled) {
                        acc2[name] = control.value;
                    }
                    return acc2;
                });
            }
            _reduceChildren(initValue, fn) {
                let res = initValue;
                this._forEachChild((control, name) => {
                    res = fn(res, control, name);
                });
                return res;
            }
            _allControlsDisabled() {
                for (const controlName of Object.keys(this.controls)) {
                    if (this.controls[controlName].enabled) {
                        return false;
                    }
                }
                return Object.keys(this.controls).length > 0 || this.disabled;
            }
            _find(name) {
                return this.controls.hasOwnProperty(name) ? this.controls[name] : null;
            }
        }
        const UntypedFormGroup = null;
        const isFormGroup = control => control instanceof FormGroup;
        class FormRecord extends(null){}
        const isFormRecord = control => control instanceof FormRecord;
        function controlPath(name, parent) {
            return [ ...parent.path, name ];
        }
        function setUpControl(control, dir) {
            if (false) {
                if (!control) {
                    _throwError(dir, "Cannot find control with");
                }
                if (!dir.valueAccessor) {
                    _throwError(dir, "No value accessor for form control with");
                }
            }
            setUpValidators(control, dir);
            dir.valueAccessor.writeValue(control.value);
            if (control.disabled) {
                dir.valueAccessor.setDisabledState?.(true);
            }
            setUpViewChangePipeline(control, dir);
            setUpModelChangePipeline(control, dir);
            setUpBlurPipeline(control, dir);
            setUpDisabledChangeHandler(control, dir);
        }
        function cleanUpControl(control, dir, validateControlPresenceOnChange = true) {
            const noop2 = () => {
                if (validateControlPresenceOnChange && false) {
                    _noControlError(dir);
                }
            };
            if (dir.valueAccessor) {
                dir.valueAccessor.registerOnChange(noop2);
                dir.valueAccessor.registerOnTouched(noop2);
            }
            cleanUpValidators(control, dir);
            if (control) {
                dir._invokeOnDestroyCallbacks();
                control._registerOnCollectionChange(() => {});
            }
        }
        function registerOnValidatorChange(validators, onChange) {
            validators.forEach(validator => {
                if (validator.registerOnValidatorChange) {
                    validator.registerOnValidatorChange(onChange);
                }
            });
        }
        function setUpDisabledChangeHandler(control, dir) {
            if (dir.valueAccessor.setDisabledState) {
                const onDisabledChange = isDisabled => {
                    dir.valueAccessor.setDisabledState(isDisabled);
                };
                control.registerOnDisabledChange(onDisabledChange);
                dir._registerOnDestroy(() => {
                    control._unregisterOnDisabledChange(onDisabledChange);
                });
            }
        }
        function setUpValidators(control, dir) {
            const validators = getControlValidators(control);
            if (dir.validator !== null) {
                control.setValidators(mergeValidators(validators, dir.validator));
            } else if (typeof validators === "function") {
                control.setValidators([ validators ]);
            }
            const asyncValidators = getControlAsyncValidators(control);
            if (dir.asyncValidator !== null) {
                control.setAsyncValidators(mergeValidators(asyncValidators, dir.asyncValidator));
            } else if (typeof asyncValidators === "function") {
                control.setAsyncValidators([ asyncValidators ]);
            }
            const onValidatorChange = () => control.updateValueAndValidity();
            registerOnValidatorChange(dir._rawValidators, onValidatorChange);
            registerOnValidatorChange(dir._rawAsyncValidators, onValidatorChange);
        }
        function cleanUpValidators(control, dir) {
            let isControlUpdated = false;
            if (control !== null) {
                if (dir.validator !== null) {
                    const validators = getControlValidators(control);
                    if (Array.isArray(validators) && validators.length > 0) {
                        const updatedValidators = validators.filter(validator => validator !== dir.validator);
                        if (updatedValidators.length !== validators.length) {
                            isControlUpdated = true;
                            control.setValidators(updatedValidators);
                        }
                    }
                }
                if (dir.asyncValidator !== null) {
                    const asyncValidators = getControlAsyncValidators(control);
                    if (Array.isArray(asyncValidators) && asyncValidators.length > 0) {
                        const updatedAsyncValidators = asyncValidators.filter(asyncValidator => asyncValidator !== dir.asyncValidator);
                        if (updatedAsyncValidators.length !== asyncValidators.length) {
                            isControlUpdated = true;
                            control.setAsyncValidators(updatedAsyncValidators);
                        }
                    }
                }
            }
            const noop2 = () => {};
            registerOnValidatorChange(dir._rawValidators, noop2);
            registerOnValidatorChange(dir._rawAsyncValidators, noop2);
            return isControlUpdated;
        }
        function setUpViewChangePipeline(control, dir) {
            dir.valueAccessor.registerOnChange(newValue => {
                control._pendingValue = newValue;
                control._pendingChange = true;
                control._pendingDirty = true;
                if (control.updateOn === "change") {
                    updateControl(control, dir);
                }
            });
        }
        function setUpBlurPipeline(control, dir) {
            dir.valueAccessor.registerOnTouched(() => {
                control._pendingTouched = true;
                if (control.updateOn === "blur" && control._pendingChange) {
                    updateControl(control, dir);
                }
                if (control.updateOn !== "submit") {
                    control.markAsTouched();
                }
            });
        }
        function updateControl(control, dir) {
            if (control._pendingDirty) {
                control.markAsDirty();
            }
            control.setValue(control._pendingValue, {
                emitModelToViewChange: false
            });
            dir.viewToModelUpdate(control._pendingValue);
            control._pendingChange = false;
        }
        function setUpModelChangePipeline(control, dir) {
            const onChange = (newValue, emitModelEvent) => {
                dir.valueAccessor.writeValue(newValue);
                if (emitModelEvent) {
                    dir.viewToModelUpdate(newValue);
                }
            };
            control.registerOnChange(onChange);
            dir._registerOnDestroy(() => {
                control._unregisterOnChange(onChange);
            });
        }
        function setUpFormContainer(control, dir) {
            if (control == null && false) {
                _throwError(dir, "Cannot find control with");
            }
            setUpValidators(control, dir);
        }
        function cleanUpFormContainer(control, dir) {
            return cleanUpValidators(control, dir);
        }
        function _noControlError(dir) {
            return _throwError(dir, "There is no FormControl instance attached to form control element with");
        }
        function _throwError(dir, message) {
            const messageEnd = _describeControlLocation(dir);
            throw new Error(`${message} ${messageEnd}`);
        }
        function _describeControlLocation(dir) {
            const path = dir.path;
            if (path && path.length > 1) {
                return `path: '${path.join(" -> ")}'`;
            }
            if (path?.[0]) {
                return `name: '${path}'`;
            }
            return "unspecified name attribute";
        }
        function _throwInvalidValueAccessorError(dir) {
            const loc = _describeControlLocation(dir);
            throw new RuntimeError(1200, `Value accessor was not provided as an array for form control with ${loc}. Check that the \`NG_VALUE_ACCESSOR\` token is configured as a \`multi: true\` provider.`);
        }
        function isPropertyUpdated(changes, viewModel) {
            if (!changes.hasOwnProperty("model")) {
                return false;
            }
            const change = changes["model"];
            if (change.isFirstChange()) {
                return true;
            }
            return !Object.is(viewModel, change.currentValue);
        }
        function isBuiltInAccessor(valueAccessor) {
            return Object.getPrototypeOf(valueAccessor.constructor) === BuiltInControlValueAccessor;
        }
        function syncPendingControls(form, directives) {
            form._syncPendingControls();
            directives.forEach(dir => {
                const control = dir.control;
                if (control.updateOn === "submit" && control._pendingChange) {
                    dir.viewToModelUpdate(control._pendingValue);
                    control._pendingChange = false;
                }
            });
        }
        function selectValueAccessor(dir, valueAccessors) {
            if (!valueAccessors) {
                return null;
            }
            if (!Array.isArray(valueAccessors) && false) {
                _throwInvalidValueAccessorError(dir);
            }
            let defaultAccessor = void 0;
            let builtinAccessor = void 0;
            let customAccessor = void 0;
            valueAccessors.forEach(v => {
                if (v.constructor === DefaultValueAccessor) {
                    defaultAccessor = v;
                } else if (isBuiltInAccessor(v)) {
                    if (builtinAccessor && false) {
                        _throwError(dir, "More than one built-in value accessor matches form control with");
                    }
                    builtinAccessor = v;
                } else {
                    if (customAccessor && false) {
                        _throwError(dir, "More than one custom value accessor matches form control with");
                    }
                    customAccessor = v;
                }
            });
            if (customAccessor) {
                return customAccessor;
            }
            if (builtinAccessor) {
                return builtinAccessor;
            }
            if (defaultAccessor) {
                return defaultAccessor;
            }
            if (false) {
                _throwError(dir, "No valid value accessor for form control with");
            }
            return null;
        }
        function removeListItem$1(list, el) {
            const index = list.indexOf(el);
            if (index > -1) {
                list.splice(index, 1);
            }
        }
        function _ngModelWarning(name, type, instance, warningConfig) {
            if (warningConfig === "never") {
                return;
            }
            if ((warningConfig === null || warningConfig === "once") && !type._ngModelWarningSentOnce || warningConfig === "always" && !instance._ngModelWarningSent) {
                console.warn(ngModelWarning(name));
                type._ngModelWarningSentOnce = true;
                instance._ngModelWarningSent = true;
            }
        }
        const formDirectiveProvider$1 = {
            provide: ControlContainer,
            useExisting: forwardRef(() => NgForm)
        };
        const resolvedPromise$1 = (() => Promise.resolve())();
        let NgForm = (() => {
            class NgForm2 extends ControlContainer {
                constructor(validators, asyncValidators) {
                    super();
                    this.submitted = false;
                    this._directives = new Set;
                    this.ngSubmit = new EventEmitter;
                    this.form = new FormGroup({}, composeValidators(validators), composeAsyncValidators(asyncValidators));
                }
                ngAfterViewInit() {
                    this._setUpdateStrategy();
                }
                get formDirective() {
                    return this;
                }
                get control() {
                    return this.form;
                }
                get path() {
                    return [];
                }
                get controls() {
                    return this.form.controls;
                }
                addControl(dir) {
                    resolvedPromise$1.then(() => {
                        const container = this._findContainer(dir.path);
                        dir.control = container.registerControl(dir.name, dir.control);
                        setUpControl(dir.control, dir);
                        dir.control.updateValueAndValidity({
                            emitEvent: false
                        });
                        this._directives.add(dir);
                    });
                }
                getControl(dir) {
                    return this.form.get(dir.path);
                }
                removeControl(dir) {
                    resolvedPromise$1.then(() => {
                        const container = this._findContainer(dir.path);
                        if (container) {
                            container.removeControl(dir.name);
                        }
                        this._directives.delete(dir);
                    });
                }
                addFormGroup(dir) {
                    resolvedPromise$1.then(() => {
                        const container = this._findContainer(dir.path);
                        const group = new FormGroup({});
                        setUpFormContainer(group, dir);
                        container.registerControl(dir.name, group);
                        group.updateValueAndValidity({
                            emitEvent: false
                        });
                    });
                }
                removeFormGroup(dir) {
                    resolvedPromise$1.then(() => {
                        const container = this._findContainer(dir.path);
                        if (container) {
                            container.removeControl(dir.name);
                        }
                    });
                }
                getFormGroup(dir) {
                    return this.form.get(dir.path);
                }
                updateModel(dir, value) {
                    resolvedPromise$1.then(() => {
                        const ctrl = this.form.get(dir.path);
                        ctrl.setValue(value);
                    });
                }
                setValue(value) {
                    this.control.setValue(value);
                }
                onSubmit($event) {
                    this.submitted = true;
                    syncPendingControls(this.form, this._directives);
                    this.ngSubmit.emit($event);
                    return $event?.target?.method === "dialog";
                }
                onReset() {
                    this.resetForm();
                }
                resetForm(value = void 0) {
                    this.form.reset(value);
                    this.submitted = false;
                }
                _setUpdateStrategy() {
                    if (this.options && this.options.updateOn != null) {
                        this.form._updateOn = this.options.updateOn;
                    }
                }
                _findContainer(path) {
                    path.pop();
                    return path.length ? this.form.get(path) : this.form;
                }
            }
            NgForm2.fac = function NgForm_Factory(t) {
                return new (t || NgForm2)(directiveInject(NG_VALIDATORS, 10), directiveInject(NG_ASYNC_VALIDATORS, 10));
            };
            NgForm2.dir = defineDirective({
                type: NgForm2,
                selectors: [ [ "form", 3, "ngNoForm", "", 3, "formGroup", "" ], [ "ng-form" ], [ "", "ngForm", "" ] ],
                hostBindings: function NgForm_HostBindings(rf, ctx) {
                    if (rf & 1) {
                        listener("submit", function NgForm_submit_HostBindingHandler($event) {
                            return ctx.onSubmit($event);
                        })("reset", function NgForm_reset_HostBindingHandler() {
                            return ctx.onReset();
                        });
                    }
                },
                inputs: {
                    options: [ "ngFormOptions", "options" ]
                },
                outputs: {
                    ngSubmit: "ngSubmit"
                },
                exportAs: [ "ngForm" ],
                features: [ ProvidersFeature([ formDirectiveProvider$1 ]), InheritDefinitionFeature ]
            });
            return NgForm2;
        })();
        (function() {})();
        function removeListItem(list, el) {
            const index = list.indexOf(el);
            if (index > -1) {
                list.splice(index, 1);
            }
        }
        function isFormControlState(formState) {
            return typeof formState === "object" && formState !== null && Object.keys(formState).length === 2 && "value" in formState && "disabled" in formState;
        }
        const FormControl = class FormControl extends AbstractControl {
            constructor(formState = null, validatorOrOpts, asyncValidator) {
                super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
                this.defaultValue = null;
                this._onChange = [];
                this._pendingChange = false;
                this._applyFormState(formState);
                this._setUpdateStrategy(validatorOrOpts);
                this._initObservables();
                this.updateValueAndValidity({
                    onlySelf: true,
                    emitEvent: !!this.asyncValidator
                });
                if (isOptionsObj(validatorOrOpts) && (validatorOrOpts.nonNullable || validatorOrOpts.initialValueIsDefault)) {
                    if (isFormControlState(formState)) {
                        this.defaultValue = formState.value;
                    } else {
                        this.defaultValue = formState;
                    }
                }
            }
            setValue(value, options = {}) {
                this.value = this._pendingValue = value;
                if (this._onChange.length && options.emitModelToViewChange !== false) {
                    this._onChange.forEach(changeFn => changeFn(this.value, options.emitViewToModelChange !== false));
                }
                this.updateValueAndValidity(options);
            }
            patchValue(value, options = {}) {
                this.setValue(value, options);
            }
            reset(formState = this.defaultValue, options = {}) {
                this._applyFormState(formState);
                this.markAsPristine(options);
                this.markAsUntouched(options);
                this.setValue(this.value, options);
                this._pendingChange = false;
            }
            _updateValue() {}
            _anyControls(condition) {
                return false;
            }
            _allControlsDisabled() {
                return this.disabled;
            }
            registerOnChange(fn) {
                this._onChange.push(fn);
            }
            _unregisterOnChange(fn) {
                removeListItem(this._onChange, fn);
            }
            registerOnDisabledChange(fn) {
                this._onDisabledChange.push(fn);
            }
            _unregisterOnDisabledChange(fn) {
                removeListItem(this._onDisabledChange, fn);
            }
            _forEachChild(cb) {}
            _syncPendingControls() {
                if (this.updateOn === "submit") {
                    if (this._pendingDirty) {
                        this.markAsDirty();
                    }
                    if (this._pendingTouched) {
                        this.markAsTouched();
                    }
                    if (this._pendingChange) {
                        this.setValue(this._pendingValue, {
                            onlySelf: true,
                            emitModelToViewChange: false
                        });
                        return true;
                    }
                }
                return false;
            }
            _applyFormState(formState) {
                if (isFormControlState(formState)) {
                    this.value = this._pendingValue = formState.value;
                    formState.disabled ? this.disable({
                        onlySelf: true,
                        emitEvent: false
                    }) : this.enable({
                        onlySelf: true,
                        emitEvent: false
                    });
                } else {
                    this.value = this._pendingValue = formState;
                }
            }
        };
        const UntypedFormControl = null;
        const isFormControl = control => control instanceof FormControl;
        let AbstractFormGroupDirective = (() => {
            class AbstractFormGroupDirective2 extends ControlContainer {
                ngOnInit() {
                    this._checkParentType();
                    this.formDirective.addFormGroup(this);
                }
                ngOnDestroy() {
                    if (this.formDirective) {
                        this.formDirective.removeFormGroup(this);
                    }
                }
                get control() {
                    return this.formDirective.getFormGroup(this);
                }
                get path() {
                    return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
                }
                get formDirective() {
                    return this._parent ? this._parent.formDirective : null;
                }
                _checkParentType() {}
            }
            AbstractFormGroupDirective2.fac = function() {
                let AbstractFormGroupDirective_BaseFactory;
                return function AbstractFormGroupDirective_Factory(t) {
                    return (AbstractFormGroupDirective_BaseFactory || (AbstractFormGroupDirective_BaseFactory = getInheritedFactory(AbstractFormGroupDirective2)))(t || AbstractFormGroupDirective2);
                };
            }();
            AbstractFormGroupDirective2.dir = defineDirective({
                type: AbstractFormGroupDirective2,
                features: [ InheritDefinitionFeature ]
            });
            return AbstractFormGroupDirective2;
        })();
        (function() {})();
        function modelParentException() {
            return new RuntimeError(1350, `\n    ngModel cannot be used to register form controls with a parent formGroup directive.  Try using\n    formGroup's partner directive "formControlName" instead.  Example:\n\n    ${formControlNameExample}\n\n    Or, if you'd like to avoid registering this form control, indicate that it's standalone in ngModelOptions:\n\n    Example:\n\n    ${ngModelWithFormGroupExample}`);
        }
        function formGroupNameException() {
            return new RuntimeError(1351, `\n    ngModel cannot be used to register form controls with a parent formGroupName or formArrayName directive.\n\n    Option 1: Use formControlName instead of ngModel (reactive strategy):\n\n    ${formGroupNameExample}\n\n    Option 2:  Update ngModel's parent be ngModelGroup (template-driven strategy):\n\n    ${ngModelGroupExample}`);
        }
        function missingNameException() {
            return new RuntimeError(1352, `If ngModel is used within a form tag, either the name attribute must be set or the form\n    control must be defined as 'standalone' in ngModelOptions.\n\n    Example 1: <input [(ngModel)]="person.firstName" name="first">\n    Example 2: <input [(ngModel)]="person.firstName" [ngModelOptions]="{standalone: true}">`);
        }
        function modelGroupParentException() {
            return new RuntimeError(1353, `\n    ngModelGroup cannot be used with a parent formGroup directive.\n\n    Option 1: Use formGroupName instead of ngModelGroup (reactive strategy):\n\n    ${formGroupNameExample}\n\n    Option 2:  Use a regular form tag instead of the formGroup directive (template-driven strategy):\n\n    ${ngModelGroupExample}`);
        }
        const modelGroupProvider = {
            provide: ControlContainer,
            useExisting: forwardRef(() => NgModelGroup)
        };
        let NgModelGroup = (() => {
            class NgModelGroup2 extends AbstractFormGroupDirective {
                constructor(parent, validators, asyncValidators) {
                    super();
                    this._parent = parent;
                    this._setValidators(validators);
                    this._setAsyncValidators(asyncValidators);
                }
                _checkParentType() {
                    if (!(this._parent instanceof NgModelGroup2) && !(this._parent instanceof NgForm) && false) {
                        throw modelGroupParentException();
                    }
                }
            }
            NgModelGroup2.fac = function NgModelGroup_Factory(t) {
                return new (t || NgModelGroup2)(directiveInject(ControlContainer, 5), directiveInject(NG_VALIDATORS, 10), directiveInject(NG_ASYNC_VALIDATORS, 10));
            };
            NgModelGroup2.dir = defineDirective({
                type: NgModelGroup2,
                selectors: [ [ "", "ngModelGroup", "" ] ],
                inputs: {
                    name: [ "ngModelGroup", "name" ]
                },
                exportAs: [ "ngModelGroup" ],
                features: [ ProvidersFeature([ modelGroupProvider ]), InheritDefinitionFeature ]
            });
            return NgModelGroup2;
        })();
        (function() {})();
        const formControlBinding$1 = {
            provide: NgControl,
            useExisting: forwardRef(() => NgModel)
        };
        const resolvedPromise = (() => Promise.resolve())();
        let NgModel = (() => {
            class NgModel2 extends NgControl {
                constructor(parent, validators, asyncValidators, valueAccessors, _changeDetectorRef) {
                    super();
                    this._changeDetectorRef = _changeDetectorRef;
                    this.control = new FormControl;
                    this._registered = false;
                    this.update = new EventEmitter;
                    this._parent = parent;
                    this._setValidators(validators);
                    this._setAsyncValidators(asyncValidators);
                    this.valueAccessor = selectValueAccessor(this, valueAccessors);
                }
                ngOnChanges(changes) {
                    this._checkForErrors();
                    if (!this._registered || "name" in changes) {
                        if (this._registered) {
                            this._checkName();
                            if (this.formDirective) {
                                const oldName = changes["name"].previousValue;
                                this.formDirective.removeControl({
                                    name: oldName,
                                    path: this._getPath(oldName)
                                });
                            }
                        }
                        this._setUpControl();
                    }
                    if ("isDisabled" in changes) {
                        this._updateDisabled(changes);
                    }
                    if (isPropertyUpdated(changes, this.viewModel)) {
                        this._updateValue(this.model);
                        this.viewModel = this.model;
                    }
                }
                ngOnDestroy() {
                    this.formDirective && this.formDirective.removeControl(this);
                }
                get path() {
                    return this._getPath(this.name);
                }
                get formDirective() {
                    return this._parent ? this._parent.formDirective : null;
                }
                viewToModelUpdate(newValue) {
                    this.viewModel = newValue;
                    this.update.emit(newValue);
                }
                _setUpControl() {
                    this._setUpdateStrategy();
                    this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this);
                    this._registered = true;
                }
                _setUpdateStrategy() {
                    if (this.options && this.options.updateOn != null) {
                        this.control._updateOn = this.options.updateOn;
                    }
                }
                _isStandalone() {
                    return !this._parent || !!(this.options && this.options.standalone);
                }
                _setUpStandalone() {
                    setUpControl(this.control, this);
                    this.control.updateValueAndValidity({
                        emitEvent: false
                    });
                }
                _checkForErrors() {
                    if (!this._isStandalone()) {
                        this._checkParentType();
                    }
                    this._checkName();
                }
                _checkParentType() {
                    if (false) {
                        if (!(this._parent instanceof NgModelGroup) && this._parent instanceof AbstractFormGroupDirective) {
                            throw formGroupNameException();
                        } else if (!(this._parent instanceof NgModelGroup) && !(this._parent instanceof NgForm)) {
                            throw modelParentException();
                        }
                    }
                }
                _checkName() {
                    if (this.options && this.options.name) {
                        this.name = this.options.name;
                    }
                    if (!this._isStandalone() && !this.name && false) {
                        throw missingNameException();
                    }
                }
                _updateValue(value) {
                    resolvedPromise.then(() => {
                        this.control.setValue(value, {
                            emitViewToModelChange: false
                        });
                        this._changeDetectorRef?.markForCheck();
                    });
                }
                _updateDisabled(changes) {
                    const disabledValue = changes["isDisabled"].currentValue;
                    const isDisabled = disabledValue !== 0 && coerceToBoolean(disabledValue);
                    resolvedPromise.then(() => {
                        if (isDisabled && !this.control.disabled) {
                            this.control.disable();
                        } else if (!isDisabled && this.control.disabled) {
                            this.control.enable();
                        }
                        this._changeDetectorRef?.markForCheck();
                    });
                }
                _getPath(controlName) {
                    return this._parent ? controlPath(controlName, this._parent) : [ controlName ];
                }
            }
            NgModel2.fac = function NgModel_Factory(t) {
                return new (t || NgModel2)(directiveInject(ControlContainer, 9), directiveInject(NG_VALIDATORS, 10), directiveInject(NG_ASYNC_VALIDATORS, 10), directiveInject(NG_VALUE_ACCESSOR, 10), directiveInject(ChangeDetectorRef, 8));
            };
            NgModel2.dir = defineDirective({
                type: NgModel2,
                selectors: [ [ "", "ngModel", "", 3, "formControlName", "", 3, "formControl", "" ] ],
                inputs: {
                    name: "name",
                    isDisabled: [ "disabled", "isDisabled" ],
                    model: [ "ngModel", "model" ],
                    options: [ "ngModelOptions", "options" ]
                },
                outputs: {
                    update: "ngModelChange"
                },
                exportAs: [ "ngModel" ],
                features: [ ProvidersFeature([ formControlBinding$1 ]), InheritDefinitionFeature, NgOnChangesFeature ]
            });
            return NgModel2;
        })();
        (function() {})();
        let NgNoValidate = (() => {
            class NgNoValidate2 {}
            NgNoValidate2.fac = function NgNoValidate_Factory(t) {
                return new (t || NgNoValidate2);
            };
            NgNoValidate2.dir = defineDirective({
                type: NgNoValidate2,
                selectors: [ [ "form", 3, "ngNoForm", "", 3, "ngNativeValidate", "" ] ],
                hostAttrs: [ "novalidate", "" ]
            });
            return NgNoValidate2;
        })();
        (function() {})();
        const NUMBER_VALUE_ACCESSOR = {
            provide: NG_VALUE_ACCESSOR,
            useExisting: forwardRef(() => NumberValueAccessor),
            multi: true
        };
        let NumberValueAccessor = (() => {
            class NumberValueAccessor2 extends BuiltInControlValueAccessor {
                writeValue(value) {
                    const normalizedValue = value == null ? "" : value;
                    this.setProperty("value", normalizedValue);
                }
                registerOnChange(fn) {
                    this.onChange = value => {
                        fn(value == "" ? null : parseFloat(value));
                    };
                }
            }
            NumberValueAccessor2.fac = function() {
                let NumberValueAccessor_BaseFactory;
                return function NumberValueAccessor_Factory(t) {
                    return (NumberValueAccessor_BaseFactory || (NumberValueAccessor_BaseFactory = getInheritedFactory(NumberValueAccessor2)))(t || NumberValueAccessor2);
                };
            }();
            NumberValueAccessor2.dir = defineDirective({
                type: NumberValueAccessor2,
                selectors: [ [ "input", "type", "number", "formControlName", "" ], [ "input", "type", "number", "formControl", "" ], [ "input", "type", "number", "ngModel", "" ] ],
                hostBindings: function NumberValueAccessor_HostBindings(rf, ctx) {
                    if (rf & 1) {
                        listener("input", function NumberValueAccessor_input_HostBindingHandler($event) {
                            return ctx.onChange($event.target.value);
                        })("blur", function NumberValueAccessor_blur_HostBindingHandler() {
                            return ctx.onTouched();
                        });
                    }
                },
                features: [ ProvidersFeature([ NUMBER_VALUE_ACCESSOR ]), InheritDefinitionFeature ]
            });
            return NumberValueAccessor2;
        })();
        (function() {})();
        const RADIO_VALUE_ACCESSOR = {
            provide: NG_VALUE_ACCESSOR,
            useExisting: forwardRef(() => RadioControlValueAccessor),
            multi: true
        };
        function throwNameError() {
            throw new RuntimeError(1202, `\n      If you define both a name and a formControlName attribute on your radio button, their values\n      must match. Ex: <input type="radio" formControlName="food" name="food">\n    `);
        }
        let RadioControlRegistryModule = (() => {
            class RadioControlRegistryModule2 {}
            RadioControlRegistryModule2.fac = function RadioControlRegistryModule_Factory(t) {
                return new (t || RadioControlRegistryModule2);
            };
            RadioControlRegistryModule2.mod = defineNgModule({
                type: RadioControlRegistryModule2
            });
            RadioControlRegistryModule2.inj = defineInjector({});
            return RadioControlRegistryModule2;
        })();
        (function() {})();
        let RadioControlRegistry = (() => {
            class RadioControlRegistry2 {
                constructor() {
                    this._accessors = [];
                }
                add(control, accessor) {
                    this._accessors.push([ control, accessor ]);
                }
                remove(accessor) {
                    for (let i = this._accessors.length - 1; i >= 0; --i) {
                        if (this._accessors[i][1] === accessor) {
                            this._accessors.splice(i, 1);
                            return;
                        }
                    }
                }
                select(accessor) {
                    this._accessors.forEach(c => {
                        if (this._isSameGroup(c, accessor) && c[1] !== accessor) {
                            c[1].fireUncheck(accessor.value);
                        }
                    });
                }
                _isSameGroup(controlPair, accessor) {
                    if (!controlPair[0].control) {
                        return false;
                    }
                    return controlPair[0]._parent === accessor._control._parent && controlPair[1].name === accessor.name;
                }
            }
            RadioControlRegistry2.fac = function RadioControlRegistry_Factory(t) {
                return new (t || RadioControlRegistry2);
            };
            RadioControlRegistry2.prov = defineInjectable({
                token: RadioControlRegistry2,
                factory: RadioControlRegistry2.fac,
                providedIn: RadioControlRegistryModule
            });
            return RadioControlRegistry2;
        })();
        (function() {})();
        let RadioControlValueAccessor = (() => {
            class RadioControlValueAccessor2 extends BuiltInControlValueAccessor {
                constructor(renderer, elementRef, _registry, _injector) {
                    super(renderer, elementRef);
                    this._registry = _registry;
                    this._injector = _injector;
                    this.onChange = () => {};
                }
                ngOnInit() {
                    this._control = this._injector.get(NgControl);
                    this._checkName();
                    this._registry.add(this._control, this);
                }
                ngOnDestroy() {
                    this._registry.remove(this);
                }
                writeValue(value) {
                    this._state = value === this.value;
                    this.setProperty("checked", this._state);
                }
                registerOnChange(fn) {
                    this._fn = fn;
                    this.onChange = () => {
                        fn(this.value);
                        this._registry.select(this);
                    };
                }
                fireUncheck(value) {
                    this.writeValue(value);
                }
                _checkName() {
                    if (this.name && this.formControlName && this.name !== this.formControlName && false) {
                        throwNameError();
                    }
                    if (!this.name && this.formControlName) {
                        this.name = this.formControlName;
                    }
                }
            }
            RadioControlValueAccessor2.fac = function RadioControlValueAccessor_Factory(t) {
                return new (t || RadioControlValueAccessor2)(directiveInject(core_Renderer2), directiveInject(core_ElementRef), directiveInject(RadioControlRegistry), directiveInject(core_Injector));
            };
            RadioControlValueAccessor2.dir = defineDirective({
                type: RadioControlValueAccessor2,
                selectors: [ [ "input", "type", "radio", "formControlName", "" ], [ "input", "type", "radio", "formControl", "" ], [ "input", "type", "radio", "ngModel", "" ] ],
                hostBindings: function RadioControlValueAccessor_HostBindings(rf, ctx) {
                    if (rf & 1) {
                        listener("change", function RadioControlValueAccessor_change_HostBindingHandler() {
                            return ctx.onChange();
                        })("blur", function RadioControlValueAccessor_blur_HostBindingHandler() {
                            return ctx.onTouched();
                        });
                    }
                },
                inputs: {
                    name: "name",
                    formControlName: "formControlName",
                    value: "value"
                },
                features: [ ProvidersFeature([ RADIO_VALUE_ACCESSOR ]), InheritDefinitionFeature ]
            });
            return RadioControlValueAccessor2;
        })();
        (function() {})();
        const RANGE_VALUE_ACCESSOR = {
            provide: NG_VALUE_ACCESSOR,
            useExisting: forwardRef(() => RangeValueAccessor),
            multi: true
        };
        let RangeValueAccessor = (() => {
            class RangeValueAccessor2 extends BuiltInControlValueAccessor {
                writeValue(value) {
                    this.setProperty("value", parseFloat(value));
                }
                registerOnChange(fn) {
                    this.onChange = value => {
                        fn(value == "" ? null : parseFloat(value));
                    };
                }
            }
            RangeValueAccessor2.fac = function() {
                let RangeValueAccessor_BaseFactory;
                return function RangeValueAccessor_Factory(t) {
                    return (RangeValueAccessor_BaseFactory || (RangeValueAccessor_BaseFactory = getInheritedFactory(RangeValueAccessor2)))(t || RangeValueAccessor2);
                };
            }();
            RangeValueAccessor2.dir = defineDirective({
                type: RangeValueAccessor2,
                selectors: [ [ "input", "type", "range", "formControlName", "" ], [ "input", "type", "range", "formControl", "" ], [ "input", "type", "range", "ngModel", "" ] ],
                hostBindings: function RangeValueAccessor_HostBindings(rf, ctx) {
                    if (rf & 1) {
                        listener("change", function RangeValueAccessor_change_HostBindingHandler($event) {
                            return ctx.onChange($event.target.value);
                        })("input", function RangeValueAccessor_input_HostBindingHandler($event) {
                            return ctx.onChange($event.target.value);
                        })("blur", function RangeValueAccessor_blur_HostBindingHandler() {
                            return ctx.onTouched();
                        });
                    }
                },
                features: [ ProvidersFeature([ RANGE_VALUE_ACCESSOR ]), InheritDefinitionFeature ]
            });
            return RangeValueAccessor2;
        })();
        (function() {})();
        const NG_MODEL_WITH_FORM_CONTROL_WARNING = new InjectionToken("NgModelWithFormControlWarning");
        const formControlBinding = {
            provide: NgControl,
            useExisting: forwardRef(() => FormControlDirective)
        };
        let FormControlDirective = (() => {
            class FormControlDirective2 extends NgControl {
                constructor(validators, asyncValidators, valueAccessors, _ngModelWarningConfig) {
                    super();
                    this._ngModelWarningConfig = _ngModelWarningConfig;
                    this.update = new EventEmitter;
                    this._ngModelWarningSent = false;
                    this._setValidators(validators);
                    this._setAsyncValidators(asyncValidators);
                    this.valueAccessor = selectValueAccessor(this, valueAccessors);
                }
                set isDisabled(isDisabled) {
                    if (false) {
                        console.warn(disabledAttrWarning);
                    }
                }
                ngOnChanges(changes) {
                    if (this._isControlChanged(changes)) {
                        const previousForm = changes["form"].previousValue;
                        if (previousForm) {
                            cleanUpControl(previousForm, this, false);
                        }
                        setUpControl(this.form, this);
                        this.form.updateValueAndValidity({
                            emitEvent: false
                        });
                    }
                    if (isPropertyUpdated(changes, this.viewModel)) {
                        if (false) {
                            _ngModelWarning("formControl", _FormControlDirective, this, this._ngModelWarningConfig);
                        }
                        this.form.setValue(this.model);
                        this.viewModel = this.model;
                    }
                }
                ngOnDestroy() {
                    if (this.form) {
                        cleanUpControl(this.form, this, false);
                    }
                }
                get path() {
                    return [];
                }
                get control() {
                    return this.form;
                }
                viewToModelUpdate(newValue) {
                    this.viewModel = newValue;
                    this.update.emit(newValue);
                }
                _isControlChanged(changes) {
                    return changes.hasOwnProperty("form");
                }
            }
            FormControlDirective2._ngModelWarningSentOnce = false;
            FormControlDirective2.fac = function FormControlDirective_Factory(t) {
                return new (t || FormControlDirective2)(directiveInject(NG_VALIDATORS, 10), directiveInject(NG_ASYNC_VALIDATORS, 10), directiveInject(NG_VALUE_ACCESSOR, 10), directiveInject(NG_MODEL_WITH_FORM_CONTROL_WARNING, 8));
            };
            FormControlDirective2.dir = defineDirective({
                type: FormControlDirective2,
                selectors: [ [ "", "formControl", "" ] ],
                inputs: {
                    form: [ "formControl", "form" ],
                    isDisabled: [ "disabled", "isDisabled" ],
                    model: [ "ngModel", "model" ]
                },
                outputs: {
                    update: "ngModelChange"
                },
                exportAs: [ "ngForm" ],
                features: [ ProvidersFeature([ formControlBinding ]), InheritDefinitionFeature, NgOnChangesFeature ]
            });
            return FormControlDirective2;
        })();
        (function() {})();
        const formDirectiveProvider = {
            provide: ControlContainer,
            useExisting: forwardRef(() => FormGroupDirective)
        };
        let FormGroupDirective = (() => {
            class FormGroupDirective2 extends ControlContainer {
                constructor(validators, asyncValidators) {
                    super();
                    this.submitted = false;
                    this._onCollectionChange = () => this._updateDomValue();
                    this.directives = [];
                    this.form = null;
                    this.ngSubmit = new EventEmitter;
                    this._setValidators(validators);
                    this._setAsyncValidators(asyncValidators);
                }
                ngOnChanges(changes) {
                    this._checkFormPresent();
                    if (changes.hasOwnProperty("form")) {
                        this._updateValidators();
                        this._updateDomValue();
                        this._updateRegistrations();
                        this._oldForm = this.form;
                    }
                }
                ngOnDestroy() {
                    if (this.form) {
                        cleanUpValidators(this.form, this);
                        if (this.form._onCollectionChange === this._onCollectionChange) {
                            this.form._registerOnCollectionChange(() => {});
                        }
                    }
                }
                get formDirective() {
                    return this;
                }
                get control() {
                    return this.form;
                }
                get path() {
                    return [];
                }
                addControl(dir) {
                    const ctrl = this.form.get(dir.path);
                    setUpControl(ctrl, dir);
                    ctrl.updateValueAndValidity({
                        emitEvent: false
                    });
                    this.directives.push(dir);
                    return ctrl;
                }
                getControl(dir) {
                    return this.form.get(dir.path);
                }
                removeControl(dir) {
                    cleanUpControl(dir.control || null, dir, false);
                    removeListItem$1(this.directives, dir);
                }
                addFormGroup(dir) {
                    this._setUpFormContainer(dir);
                }
                removeFormGroup(dir) {
                    this._cleanUpFormContainer(dir);
                }
                getFormGroup(dir) {
                    return this.form.get(dir.path);
                }
                addFormArray(dir) {
                    this._setUpFormContainer(dir);
                }
                removeFormArray(dir) {
                    this._cleanUpFormContainer(dir);
                }
                getFormArray(dir) {
                    return this.form.get(dir.path);
                }
                updateModel(dir, value) {
                    const ctrl = this.form.get(dir.path);
                    ctrl.setValue(value);
                }
                onSubmit($event) {
                    this.submitted = true;
                    syncPendingControls(this.form, this.directives);
                    this.ngSubmit.emit($event);
                    return $event?.target?.method === "dialog";
                }
                onReset() {
                    this.resetForm();
                }
                resetForm(value = void 0) {
                    this.form.reset(value);
                    this.submitted = false;
                }
                _updateDomValue() {
                    this.directives.forEach(dir => {
                        const oldCtrl = dir.control;
                        const newCtrl = this.form.get(dir.path);
                        if (oldCtrl !== newCtrl) {
                            cleanUpControl(oldCtrl || null, dir);
                            if (isFormControl(newCtrl)) {
                                setUpControl(newCtrl, dir);
                                dir.control = newCtrl;
                            }
                        }
                    });
                    this.form._updateTreeValidity({
                        emitEvent: false
                    });
                }
                _setUpFormContainer(dir) {
                    const ctrl = this.form.get(dir.path);
                    setUpFormContainer(ctrl, dir);
                    ctrl.updateValueAndValidity({
                        emitEvent: false
                    });
                }
                _cleanUpFormContainer(dir) {
                    if (this.form) {
                        const ctrl = this.form.get(dir.path);
                        if (ctrl) {
                            const isControlUpdated = cleanUpFormContainer(ctrl, dir);
                            if (isControlUpdated) {
                                ctrl.updateValueAndValidity({
                                    emitEvent: false
                                });
                            }
                        }
                    }
                }
                _updateRegistrations() {
                    this.form._registerOnCollectionChange(this._onCollectionChange);
                    if (this._oldForm) {
                        this._oldForm._registerOnCollectionChange(() => {});
                    }
                }
                _updateValidators() {
                    setUpValidators(this.form, this);
                    if (this._oldForm) {
                        cleanUpValidators(this._oldForm, this);
                    }
                }
                _checkFormPresent() {
                    if (!this.form && false) {
                        throw missingFormException();
                    }
                }
            }
            FormGroupDirective2.fac = function FormGroupDirective_Factory(t) {
                return new (t || FormGroupDirective2)(directiveInject(NG_VALIDATORS, 10), directiveInject(NG_ASYNC_VALIDATORS, 10));
            };
            FormGroupDirective2.dir = defineDirective({
                type: FormGroupDirective2,
                selectors: [ [ "", "formGroup", "" ] ],
                hostBindings: function FormGroupDirective_HostBindings(rf, ctx) {
                    if (rf & 1) {
                        listener("submit", function FormGroupDirective_submit_HostBindingHandler($event) {
                            return ctx.onSubmit($event);
                        })("reset", function FormGroupDirective_reset_HostBindingHandler() {
                            return ctx.onReset();
                        });
                    }
                },
                inputs: {
                    form: [ "formGroup", "form" ]
                },
                outputs: {
                    ngSubmit: "ngSubmit"
                },
                exportAs: [ "ngForm" ],
                features: [ ProvidersFeature([ formDirectiveProvider ]), InheritDefinitionFeature, NgOnChangesFeature ]
            });
            return FormGroupDirective2;
        })();
        (function() {})();
        const formGroupNameProvider = {
            provide: ControlContainer,
            useExisting: forwardRef(() => FormGroupName)
        };
        let FormGroupName = (() => {
            class FormGroupName2 extends AbstractFormGroupDirective {
                constructor(parent, validators, asyncValidators) {
                    super();
                    this._parent = parent;
                    this._setValidators(validators);
                    this._setAsyncValidators(asyncValidators);
                }
                _checkParentType() {
                    if (_hasInvalidParent(this._parent) && false) {
                        throw groupParentException();
                    }
                }
            }
            FormGroupName2.fac = function FormGroupName_Factory(t) {
                return new (t || FormGroupName2)(directiveInject(ControlContainer, 13), directiveInject(NG_VALIDATORS, 10), directiveInject(NG_ASYNC_VALIDATORS, 10));
            };
            FormGroupName2.dir = defineDirective({
                type: FormGroupName2,
                selectors: [ [ "", "formGroupName", "" ] ],
                inputs: {
                    name: [ "formGroupName", "name" ]
                },
                features: [ ProvidersFeature([ formGroupNameProvider ]), InheritDefinitionFeature ]
            });
            return FormGroupName2;
        })();
        (function() {})();
        const formArrayNameProvider = {
            provide: ControlContainer,
            useExisting: forwardRef(() => FormArrayName)
        };
        let FormArrayName = (() => {
            class FormArrayName2 extends ControlContainer {
                constructor(parent, validators, asyncValidators) {
                    super();
                    this._parent = parent;
                    this._setValidators(validators);
                    this._setAsyncValidators(asyncValidators);
                }
                ngOnInit() {
                    this._checkParentType();
                    this.formDirective.addFormArray(this);
                }
                ngOnDestroy() {
                    if (this.formDirective) {
                        this.formDirective.removeFormArray(this);
                    }
                }
                get control() {
                    return this.formDirective.getFormArray(this);
                }
                get formDirective() {
                    return this._parent ? this._parent.formDirective : null;
                }
                get path() {
                    return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
                }
                _checkParentType() {
                    if (_hasInvalidParent(this._parent) && false) {
                        throw arrayParentException();
                    }
                }
            }
            FormArrayName2.fac = function FormArrayName_Factory(t) {
                return new (t || FormArrayName2)(directiveInject(ControlContainer, 13), directiveInject(NG_VALIDATORS, 10), directiveInject(NG_ASYNC_VALIDATORS, 10));
            };
            FormArrayName2.dir = defineDirective({
                type: FormArrayName2,
                selectors: [ [ "", "formArrayName", "" ] ],
                inputs: {
                    name: [ "formArrayName", "name" ]
                },
                features: [ ProvidersFeature([ formArrayNameProvider ]), InheritDefinitionFeature ]
            });
            return FormArrayName2;
        })();
        (function() {})();
        function _hasInvalidParent(parent) {
            return !(parent instanceof FormGroupName) && !(parent instanceof FormGroupDirective) && !(parent instanceof FormArrayName);
        }
        const controlNameBinding = {
            provide: NgControl,
            useExisting: forwardRef(() => FormControlName)
        };
        let FormControlName = (() => {
            class FormControlName2 extends NgControl {
                constructor(parent, validators, asyncValidators, valueAccessors, _ngModelWarningConfig) {
                    super();
                    this._ngModelWarningConfig = _ngModelWarningConfig;
                    this._added = false;
                    this.update = new EventEmitter;
                    this._ngModelWarningSent = false;
                    this._parent = parent;
                    this._setValidators(validators);
                    this._setAsyncValidators(asyncValidators);
                    this.valueAccessor = selectValueAccessor(this, valueAccessors);
                }
                set isDisabled(isDisabled) {
                    if (false) {
                        console.warn(disabledAttrWarning);
                    }
                }
                ngOnChanges(changes) {
                    if (!this._added) {
                        this._setUpControl();
                    }
                    if (isPropertyUpdated(changes, this.viewModel)) {
                        if (false) {
                            _ngModelWarning("formControlName", _FormControlName, this, this._ngModelWarningConfig);
                        }
                        this.viewModel = this.model;
                        this.formDirective.updateModel(this, this.model);
                    }
                }
                ngOnDestroy() {
                    if (this.formDirective) {
                        this.formDirective.removeControl(this);
                    }
                }
                viewToModelUpdate(newValue) {
                    this.viewModel = newValue;
                    this.update.emit(newValue);
                }
                get path() {
                    return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
                }
                get formDirective() {
                    return this._parent ? this._parent.formDirective : null;
                }
                _checkParentType() {
                    if (false) {
                        if (!(this._parent instanceof FormGroupName) && this._parent instanceof AbstractFormGroupDirective) {
                            throw ngModelGroupException();
                        } else if (!(this._parent instanceof FormGroupName) && !(this._parent instanceof FormGroupDirective) && !(this._parent instanceof FormArrayName)) {
                            throw controlParentException();
                        }
                    }
                }
                _setUpControl() {
                    this._checkParentType();
                    this.control = this.formDirective.addControl(this);
                    this._added = true;
                }
            }
            FormControlName2._ngModelWarningSentOnce = false;
            FormControlName2.fac = function FormControlName_Factory(t) {
                return new (t || FormControlName2)(directiveInject(ControlContainer, 13), directiveInject(NG_VALIDATORS, 10), directiveInject(NG_ASYNC_VALIDATORS, 10), directiveInject(NG_VALUE_ACCESSOR, 10), directiveInject(NG_MODEL_WITH_FORM_CONTROL_WARNING, 8));
            };
            FormControlName2.dir = defineDirective({
                type: FormControlName2,
                selectors: [ [ "", "formControlName", "" ] ],
                inputs: {
                    name: [ "formControlName", "name" ],
                    isDisabled: [ "disabled", "isDisabled" ],
                    model: [ "ngModel", "model" ]
                },
                outputs: {
                    update: "ngModelChange"
                },
                features: [ ProvidersFeature([ controlNameBinding ]), InheritDefinitionFeature, NgOnChangesFeature ]
            });
            return FormControlName2;
        })();
        (function() {})();
        const SELECT_VALUE_ACCESSOR = {
            provide: NG_VALUE_ACCESSOR,
            useExisting: forwardRef(() => SelectControlValueAccessor),
            multi: true
        };
        function _buildValueString$1(id, value) {
            if (id == null) {
                return `${value}`;
            }
            if (value && typeof value === "object") {
                value = "Object";
            }
            return `${id}: ${value}`.slice(0, 50);
        }
        function _extractId$1(valueString) {
            return valueString.split(":")[0];
        }
        let SelectControlValueAccessor = (() => {
            class SelectControlValueAccessor2 extends BuiltInControlValueAccessor {
                constructor() {
                    super(...arguments);
                    this._optionMap = new Map;
                    this._idCounter = 0;
                    this._compareWith = Object.is;
                }
                set compareWith(fn) {
                    if (typeof fn !== "function" && false) {
                        throw new RuntimeError(1201, `compareWith must be a function, but received ${JSON.stringify(fn)}`);
                    }
                    this._compareWith = fn;
                }
                writeValue(value) {
                    this.value = value;
                    const id = this._getOptionId(value);
                    const valueString = _buildValueString$1(id, value);
                    this.setProperty("value", valueString);
                }
                registerOnChange(fn) {
                    this.onChange = valueString => {
                        this.value = this._getOptionValue(valueString);
                        fn(this.value);
                    };
                }
                _registerOption() {
                    return (this._idCounter++).toString();
                }
                _getOptionId(value) {
                    for (const id of Array.from(this._optionMap.keys())) {
                        if (this._compareWith(this._optionMap.get(id), value)) {
                            return id;
                        }
                    }
                    return null;
                }
                _getOptionValue(valueString) {
                    const id = _extractId$1(valueString);
                    return this._optionMap.has(id) ? this._optionMap.get(id) : valueString;
                }
            }
            SelectControlValueAccessor2.fac = function() {
                let SelectControlValueAccessor_BaseFactory;
                return function SelectControlValueAccessor_Factory(t) {
                    return (SelectControlValueAccessor_BaseFactory || (SelectControlValueAccessor_BaseFactory = getInheritedFactory(SelectControlValueAccessor2)))(t || SelectControlValueAccessor2);
                };
            }();
            SelectControlValueAccessor2.dir = defineDirective({
                type: SelectControlValueAccessor2,
                selectors: [ [ "select", "formControlName", "", 3, "multiple", "" ], [ "select", "formControl", "", 3, "multiple", "" ], [ "select", "ngModel", "", 3, "multiple", "" ] ],
                hostBindings: function SelectControlValueAccessor_HostBindings(rf, ctx) {
                    if (rf & 1) {
                        listener("change", function SelectControlValueAccessor_change_HostBindingHandler($event) {
                            return ctx.onChange($event.target.value);
                        })("blur", function SelectControlValueAccessor_blur_HostBindingHandler() {
                            return ctx.onTouched();
                        });
                    }
                },
                inputs: {
                    compareWith: "compareWith"
                },
                features: [ ProvidersFeature([ SELECT_VALUE_ACCESSOR ]), InheritDefinitionFeature ]
            });
            return SelectControlValueAccessor2;
        })();
        (function() {})();
        let NgSelectOption = (() => {
            class NgSelectOption2 {
                constructor(_element, _renderer, _select) {
                    this._element = _element;
                    this._renderer = _renderer;
                    this._select = _select;
                    if (this._select) {
                        this.id = this._select._registerOption();
                    }
                }
                set ngValue(value) {
                    if (this._select == null) {
                        return;
                    }
                    this._select._optionMap.set(this.id, value);
                    this._setElementValue(_buildValueString$1(this.id, value));
                    this._select.writeValue(this._select.value);
                }
                set value(value) {
                    this._setElementValue(value);
                    if (this._select) {
                        this._select.writeValue(this._select.value);
                    }
                }
                _setElementValue(value) {
                    this._renderer.setProperty(this._element.nativeElement, "value", value);
                }
                ngOnDestroy() {
                    if (this._select) {
                        this._select._optionMap.delete(this.id);
                        this._select.writeValue(this._select.value);
                    }
                }
            }
            NgSelectOption2.fac = function NgSelectOption_Factory(t) {
                return new (t || NgSelectOption2)(directiveInject(core_ElementRef), directiveInject(core_Renderer2), directiveInject(SelectControlValueAccessor, 9));
            };
            NgSelectOption2.dir = defineDirective({
                type: NgSelectOption2,
                selectors: [ [ "option" ] ],
                inputs: {
                    ngValue: "ngValue",
                    value: "value"
                }
            });
            return NgSelectOption2;
        })();
        (function() {})();
        const SELECT_MULTIPLE_VALUE_ACCESSOR = {
            provide: NG_VALUE_ACCESSOR,
            useExisting: forwardRef(() => SelectMultipleControlValueAccessor),
            multi: true
        };
        function _buildValueString(id, value) {
            if (id == null) {
                return `${value}`;
            }
            if (typeof value === "string") {
                value = `'${value}'`;
            }
            if (value && typeof value === "object") {
                value = "Object";
            }
            return `${id}: ${value}`.slice(0, 50);
        }
        function _extractId(valueString) {
            return valueString.split(":")[0];
        }
        class HTMLCollection {}
        let SelectMultipleControlValueAccessor = (() => {
            class SelectMultipleControlValueAccessor2 extends BuiltInControlValueAccessor {
                constructor() {
                    super(...arguments);
                    this._optionMap = new Map;
                    this._idCounter = 0;
                    this._compareWith = Object.is;
                }
                set compareWith(fn) {
                    if (typeof fn !== "function" && false) {
                        throw new RuntimeError(1201, `compareWith must be a function, but received ${JSON.stringify(fn)}`);
                    }
                    this._compareWith = fn;
                }
                writeValue(value) {
                    this.value = value;
                    let optionSelectedStateSetter;
                    if (Array.isArray(value)) {
                        const ids = value.map(v => this._getOptionId(v));
                        optionSelectedStateSetter = (opt, o) => {
                            opt._setSelected(ids.indexOf(o.toString()) > -1);
                        };
                    } else {
                        optionSelectedStateSetter = (opt, o) => {
                            opt._setSelected(false);
                        };
                    }
                    this._optionMap.forEach(optionSelectedStateSetter);
                }
                registerOnChange(fn) {
                    this.onChange = element => {
                        const selected = [];
                        const selectedOptions = element.selectedOptions;
                        if (selectedOptions !== void 0) {
                            const options = selectedOptions;
                            for (let i = 0; i < options.length; i++) {
                                const opt = options[i];
                                const val = this._getOptionValue(opt.value);
                                selected.push(val);
                            }
                        } else {
                            const options = element.options;
                            for (let i = 0; i < options.length; i++) {
                                const opt = options[i];
                                if (opt.selected) {
                                    const val = this._getOptionValue(opt.value);
                                    selected.push(val);
                                }
                            }
                        }
                        this.value = selected;
                        fn(selected);
                    };
                }
                _registerOption(value) {
                    const id = (this._idCounter++).toString();
                    this._optionMap.set(id, value);
                    return id;
                }
                _getOptionId(value) {
                    for (const id of Array.from(this._optionMap.keys())) {
                        if (this._compareWith(this._optionMap.get(id)._value, value)) {
                            return id;
                        }
                    }
                    return null;
                }
                _getOptionValue(valueString) {
                    const id = _extractId(valueString);
                    return this._optionMap.has(id) ? this._optionMap.get(id)._value : valueString;
                }
            }
            SelectMultipleControlValueAccessor2.fac = function() {
                let SelectMultipleControlValueAccessor_BaseFactory;
                return function SelectMultipleControlValueAccessor_Factory(t) {
                    return (SelectMultipleControlValueAccessor_BaseFactory || (SelectMultipleControlValueAccessor_BaseFactory = getInheritedFactory(SelectMultipleControlValueAccessor2)))(t || SelectMultipleControlValueAccessor2);
                };
            }();
            SelectMultipleControlValueAccessor2.dir = defineDirective({
                type: SelectMultipleControlValueAccessor2,
                selectors: [ [ "select", "multiple", "", "formControlName", "" ], [ "select", "multiple", "", "formControl", "" ], [ "select", "multiple", "", "ngModel", "" ] ],
                hostBindings: function SelectMultipleControlValueAccessor_HostBindings(rf, ctx) {
                    if (rf & 1) {
                        listener("change", function SelectMultipleControlValueAccessor_change_HostBindingHandler($event) {
                            return ctx.onChange($event.target);
                        })("blur", function SelectMultipleControlValueAccessor_blur_HostBindingHandler() {
                            return ctx.onTouched();
                        });
                    }
                },
                inputs: {
                    compareWith: "compareWith"
                },
                features: [ ProvidersFeature([ SELECT_MULTIPLE_VALUE_ACCESSOR ]), InheritDefinitionFeature ]
            });
            return SelectMultipleControlValueAccessor2;
        })();
        (function() {})();
        let NgSelectMultipleOption = (() => {
            class NgSelectMultipleOption2 {
                constructor(_element, _renderer, _select) {
                    this._element = _element;
                    this._renderer = _renderer;
                    this._select = _select;
                    if (this._select) {
                        this.id = this._select._registerOption(this);
                    }
                }
                set ngValue(value) {
                    if (this._select == null) {
                        return;
                    }
                    this._value = value;
                    this._setElementValue(_buildValueString(this.id, value));
                    this._select.writeValue(this._select.value);
                }
                set value(value) {
                    if (this._select) {
                        this._value = value;
                        this._setElementValue(_buildValueString(this.id, value));
                        this._select.writeValue(this._select.value);
                    } else {
                        this._setElementValue(value);
                    }
                }
                _setElementValue(value) {
                    this._renderer.setProperty(this._element.nativeElement, "value", value);
                }
                _setSelected(selected) {
                    this._renderer.setProperty(this._element.nativeElement, "selected", selected);
                }
                ngOnDestroy() {
                    if (this._select) {
                        this._select._optionMap.delete(this.id);
                        this._select.writeValue(this._select.value);
                    }
                }
            }
            NgSelectMultipleOption2.fac = function NgSelectMultipleOption_Factory(t) {
                return new (t || NgSelectMultipleOption2)(directiveInject(core_ElementRef), directiveInject(core_Renderer2), directiveInject(SelectMultipleControlValueAccessor, 9));
            };
            NgSelectMultipleOption2.dir = defineDirective({
                type: NgSelectMultipleOption2,
                selectors: [ [ "option" ] ],
                inputs: {
                    ngValue: "ngValue",
                    value: "value"
                }
            });
            return NgSelectMultipleOption2;
        })();
        (function() {})();
        function toInteger(value) {
            return typeof value === "number" ? value : parseInt(value, 10);
        }
        function toFloat(value) {
            return typeof value === "number" ? value : parseFloat(value);
        }
        let AbstractValidatorDirective = (() => {
            class AbstractValidatorDirective2 {
                constructor() {
                    this._validator = nullValidator;
                }
                ngOnChanges(changes) {
                    if (this.inputName in changes) {
                        const input = this.normalizeInput(changes[this.inputName].currentValue);
                        this._enabled = this.enabled(input);
                        this._validator = this._enabled ? this.createValidator(input) : nullValidator;
                        if (this._onChange) {
                            this._onChange();
                        }
                    }
                }
                validate(control) {
                    return this._validator(control);
                }
                registerOnValidatorChange(fn) {
                    this._onChange = fn;
                }
                enabled(input) {
                    return input != null;
                }
            }
            AbstractValidatorDirective2.fac = function AbstractValidatorDirective_Factory(t) {
                return new (t || AbstractValidatorDirective2);
            };
            AbstractValidatorDirective2.dir = defineDirective({
                type: AbstractValidatorDirective2,
                features: [ NgOnChangesFeature ]
            });
            return AbstractValidatorDirective2;
        })();
        (function() {})();
        const MAX_VALIDATOR = {
            provide: NG_VALIDATORS,
            useExisting: forwardRef(() => MaxValidator),
            multi: true
        };
        let MaxValidator = (() => {
            class MaxValidator2 extends AbstractValidatorDirective {
                constructor() {
                    super(...arguments);
                    this.inputName = "max";
                    this.normalizeInput = input => toFloat(input);
                    this.createValidator = max => maxValidator(max);
                }
            }
            MaxValidator2.fac = function() {
                let MaxValidator_BaseFactory;
                return function MaxValidator_Factory(t) {
                    return (MaxValidator_BaseFactory || (MaxValidator_BaseFactory = getInheritedFactory(MaxValidator2)))(t || MaxValidator2);
                };
            }();
            MaxValidator2.dir = defineDirective({
                type: MaxValidator2,
                selectors: [ [ "input", "type", "number", "max", "", "formControlName", "" ], [ "input", "type", "number", "max", "", "formControl", "" ], [ "input", "type", "number", "max", "", "ngModel", "" ] ],
                hostVars: 1,
                hostBindings: function MaxValidator_HostBindings(rf, ctx) {
                    if (rf & 2) {
                        attribute("max", ctx._enabled ? ctx.max : null);
                    }
                },
                inputs: {
                    max: "max"
                },
                features: [ ProvidersFeature([ MAX_VALIDATOR ]), InheritDefinitionFeature ]
            });
            return MaxValidator2;
        })();
        (function() {})();
        const MIN_VALIDATOR = {
            provide: NG_VALIDATORS,
            useExisting: forwardRef(() => MinValidator),
            multi: true
        };
        let MinValidator = (() => {
            class MinValidator2 extends AbstractValidatorDirective {
                constructor() {
                    super(...arguments);
                    this.inputName = "min";
                    this.normalizeInput = input => toFloat(input);
                    this.createValidator = min => minValidator(min);
                }
            }
            MinValidator2.fac = function() {
                let MinValidator_BaseFactory;
                return function MinValidator_Factory(t) {
                    return (MinValidator_BaseFactory || (MinValidator_BaseFactory = getInheritedFactory(MinValidator2)))(t || MinValidator2);
                };
            }();
            MinValidator2.dir = defineDirective({
                type: MinValidator2,
                selectors: [ [ "input", "type", "number", "min", "", "formControlName", "" ], [ "input", "type", "number", "min", "", "formControl", "" ], [ "input", "type", "number", "min", "", "ngModel", "" ] ],
                hostVars: 1,
                hostBindings: function MinValidator_HostBindings(rf, ctx) {
                    if (rf & 2) {
                        attribute("min", ctx._enabled ? ctx.min : null);
                    }
                },
                inputs: {
                    min: "min"
                },
                features: [ ProvidersFeature([ MIN_VALIDATOR ]), InheritDefinitionFeature ]
            });
            return MinValidator2;
        })();
        (function() {})();
        const REQUIRED_VALIDATOR = {
            provide: NG_VALIDATORS,
            useExisting: forwardRef(() => RequiredValidator),
            multi: true
        };
        const CHECKBOX_REQUIRED_VALIDATOR = {
            provide: NG_VALIDATORS,
            useExisting: forwardRef(() => CheckboxRequiredValidator),
            multi: true
        };
        let RequiredValidator = (() => {
            class RequiredValidator2 extends AbstractValidatorDirective {
                constructor() {
                    super(...arguments);
                    this.inputName = "required";
                    this.normalizeInput = coerceToBoolean;
                    this.createValidator = input => requiredValidator;
                }
                enabled(input) {
                    return input;
                }
            }
            RequiredValidator2.fac = function() {
                let RequiredValidator_BaseFactory;
                return function RequiredValidator_Factory(t) {
                    return (RequiredValidator_BaseFactory || (RequiredValidator_BaseFactory = getInheritedFactory(RequiredValidator2)))(t || RequiredValidator2);
                };
            }();
            RequiredValidator2.dir = defineDirective({
                type: RequiredValidator2,
                selectors: [ [ "", "required", "", "formControlName", "", 3, "type", "checkbox" ], [ "", "required", "", "formControl", "", 3, "type", "checkbox" ], [ "", "required", "", "ngModel", "", 3, "type", "checkbox" ] ],
                hostVars: 1,
                hostBindings: function RequiredValidator_HostBindings(rf, ctx) {
                    if (rf & 2) {
                        attribute("required", ctx._enabled ? "" : null);
                    }
                },
                inputs: {
                    required: "required"
                },
                features: [ ProvidersFeature([ REQUIRED_VALIDATOR ]), InheritDefinitionFeature ]
            });
            return RequiredValidator2;
        })();
        (function() {})();
        let CheckboxRequiredValidator = (() => {
            class CheckboxRequiredValidator2 extends RequiredValidator {
                constructor() {
                    super(...arguments);
                    this.createValidator = input => requiredTrueValidator;
                }
            }
            CheckboxRequiredValidator2.fac = function() {
                let CheckboxRequiredValidator_BaseFactory;
                return function CheckboxRequiredValidator_Factory(t) {
                    return (CheckboxRequiredValidator_BaseFactory || (CheckboxRequiredValidator_BaseFactory = getInheritedFactory(CheckboxRequiredValidator2)))(t || CheckboxRequiredValidator2);
                };
            }();
            CheckboxRequiredValidator2.dir = defineDirective({
                type: CheckboxRequiredValidator2,
                selectors: [ [ "input", "type", "checkbox", "required", "", "formControlName", "" ], [ "input", "type", "checkbox", "required", "", "formControl", "" ], [ "input", "type", "checkbox", "required", "", "ngModel", "" ] ],
                hostVars: 1,
                hostBindings: function CheckboxRequiredValidator_HostBindings(rf, ctx) {
                    if (rf & 2) {
                        attribute("required", ctx._enabled ? "" : null);
                    }
                },
                features: [ ProvidersFeature([ CHECKBOX_REQUIRED_VALIDATOR ]), InheritDefinitionFeature ]
            });
            return CheckboxRequiredValidator2;
        })();
        (function() {})();
        const EMAIL_VALIDATOR = {
            provide: NG_VALIDATORS,
            useExisting: forwardRef(() => EmailValidator),
            multi: true
        };
        let EmailValidator = (() => {
            class EmailValidator2 extends AbstractValidatorDirective {
                constructor() {
                    super(...arguments);
                    this.inputName = "email";
                    this.normalizeInput = coerceToBoolean;
                    this.createValidator = input => emailValidator;
                }
                enabled(input) {
                    return input;
                }
            }
            EmailValidator2.fac = function() {
                let EmailValidator_BaseFactory;
                return function EmailValidator_Factory(t) {
                    return (EmailValidator_BaseFactory || (EmailValidator_BaseFactory = getInheritedFactory(EmailValidator2)))(t || EmailValidator2);
                };
            }();
            EmailValidator2.dir = defineDirective({
                type: EmailValidator2,
                selectors: [ [ "", "email", "", "formControlName", "" ], [ "", "email", "", "formControl", "" ], [ "", "email", "", "ngModel", "" ] ],
                inputs: {
                    email: "email"
                },
                features: [ ProvidersFeature([ EMAIL_VALIDATOR ]), InheritDefinitionFeature ]
            });
            return EmailValidator2;
        })();
        (function() {})();
        const MIN_LENGTH_VALIDATOR = {
            provide: NG_VALIDATORS,
            useExisting: forwardRef(() => MinLengthValidator),
            multi: true
        };
        let MinLengthValidator = (() => {
            class MinLengthValidator2 extends AbstractValidatorDirective {
                constructor() {
                    super(...arguments);
                    this.inputName = "minlength";
                    this.normalizeInput = input => toInteger(input);
                    this.createValidator = minlength => minLengthValidator(minlength);
                }
            }
            MinLengthValidator2.fac = function() {
                let MinLengthValidator_BaseFactory;
                return function MinLengthValidator_Factory(t) {
                    return (MinLengthValidator_BaseFactory || (MinLengthValidator_BaseFactory = getInheritedFactory(MinLengthValidator2)))(t || MinLengthValidator2);
                };
            }();
            MinLengthValidator2.dir = defineDirective({
                type: MinLengthValidator2,
                selectors: [ [ "", "minlength", "", "formControlName", "" ], [ "", "minlength", "", "formControl", "" ], [ "", "minlength", "", "ngModel", "" ] ],
                hostVars: 1,
                hostBindings: function MinLengthValidator_HostBindings(rf, ctx) {
                    if (rf & 2) {
                        attribute("minlength", ctx._enabled ? ctx.minlength : null);
                    }
                },
                inputs: {
                    minlength: "minlength"
                },
                features: [ ProvidersFeature([ MIN_LENGTH_VALIDATOR ]), InheritDefinitionFeature ]
            });
            return MinLengthValidator2;
        })();
        (function() {})();
        const MAX_LENGTH_VALIDATOR = {
            provide: NG_VALIDATORS,
            useExisting: forwardRef(() => MaxLengthValidator),
            multi: true
        };
        let MaxLengthValidator = (() => {
            class MaxLengthValidator2 extends AbstractValidatorDirective {
                constructor() {
                    super(...arguments);
                    this.inputName = "maxlength";
                    this.normalizeInput = input => toInteger(input);
                    this.createValidator = maxlength => maxLengthValidator(maxlength);
                }
            }
            MaxLengthValidator2.fac = function() {
                let MaxLengthValidator_BaseFactory;
                return function MaxLengthValidator_Factory(t) {
                    return (MaxLengthValidator_BaseFactory || (MaxLengthValidator_BaseFactory = getInheritedFactory(MaxLengthValidator2)))(t || MaxLengthValidator2);
                };
            }();
            MaxLengthValidator2.dir = defineDirective({
                type: MaxLengthValidator2,
                selectors: [ [ "", "maxlength", "", "formControlName", "" ], [ "", "maxlength", "", "formControl", "" ], [ "", "maxlength", "", "ngModel", "" ] ],
                hostVars: 1,
                hostBindings: function MaxLengthValidator_HostBindings(rf, ctx) {
                    if (rf & 2) {
                        attribute("maxlength", ctx._enabled ? ctx.maxlength : null);
                    }
                },
                inputs: {
                    maxlength: "maxlength"
                },
                features: [ ProvidersFeature([ MAX_LENGTH_VALIDATOR ]), InheritDefinitionFeature ]
            });
            return MaxLengthValidator2;
        })();
        (function() {})();
        const PATTERN_VALIDATOR = {
            provide: NG_VALIDATORS,
            useExisting: forwardRef(() => PatternValidator),
            multi: true
        };
        let PatternValidator = (() => {
            class PatternValidator2 extends AbstractValidatorDirective {
                constructor() {
                    super(...arguments);
                    this.inputName = "pattern";
                    this.normalizeInput = input => input;
                    this.createValidator = input => patternValidator(input);
                }
            }
            PatternValidator2.fac = function() {
                let PatternValidator_BaseFactory;
                return function PatternValidator_Factory(t) {
                    return (PatternValidator_BaseFactory || (PatternValidator_BaseFactory = getInheritedFactory(PatternValidator2)))(t || PatternValidator2);
                };
            }();
            PatternValidator2.dir = defineDirective({
                type: PatternValidator2,
                selectors: [ [ "", "pattern", "", "formControlName", "" ], [ "", "pattern", "", "formControl", "" ], [ "", "pattern", "", "ngModel", "" ] ],
                hostVars: 1,
                hostBindings: function PatternValidator_HostBindings(rf, ctx) {
                    if (rf & 2) {
                        attribute("pattern", ctx._enabled ? ctx.pattern : null);
                    }
                },
                inputs: {
                    pattern: "pattern"
                },
                features: [ ProvidersFeature([ PATTERN_VALIDATOR ]), InheritDefinitionFeature ]
            });
            return PatternValidator2;
        })();
        (function() {})();
        const SHARED_FORM_DIRECTIVES = [ NgNoValidate, NgSelectOption, NgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor, RangeValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, SelectMultipleControlValueAccessor, RadioControlValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinLengthValidator, MaxLengthValidator, PatternValidator, CheckboxRequiredValidator, EmailValidator, MinValidator, MaxValidator ];
        const TEMPLATE_DRIVEN_DIRECTIVES = [ NgModel, NgModelGroup, NgForm ];
        const REACTIVE_DRIVEN_DIRECTIVES = [ FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName ];
        let InternalFormsSharedModule = (() => {
            class InternalFormsSharedModule2 {}
            InternalFormsSharedModule2.fac = function InternalFormsSharedModule_Factory(t) {
                return new (t || InternalFormsSharedModule2);
            };
            InternalFormsSharedModule2.mod = defineNgModule({
                type: InternalFormsSharedModule2
            });
            InternalFormsSharedModule2.inj = defineInjector({
                imports: [ RadioControlRegistryModule ]
            });
            return InternalFormsSharedModule2;
        })();
        (function() {})();
        let FormsModule = null;
        (function() {})();
        let ReactiveFormsModule = (() => {
            class ReactiveFormsModule2 {
                static withConfig(opts) {
                    return {
                        ngModule: ReactiveFormsModule2,
                        providers: [ {
                            provide: NG_MODEL_WITH_FORM_CONTROL_WARNING,
                            useValue: opts.warnOnNgModelWithFormControl
                        } ]
                    };
                }
            }
            ReactiveFormsModule2.fac = function ReactiveFormsModule_Factory(t) {
                return new (t || ReactiveFormsModule2);
            };
            ReactiveFormsModule2.mod = defineNgModule({
                type: ReactiveFormsModule2
            });
            ReactiveFormsModule2.inj = defineInjector({
                imports: [ InternalFormsSharedModule ]
            });
            return ReactiveFormsModule2;
        })();
        (function() {})();
        class FormArray extends(null){
            constructor(controls, validatorOrOpts, asyncValidator) {
                super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
                this.controls = controls;
                this._initObservables();
                this._setUpdateStrategy(validatorOrOpts);
                this._setUpControls();
                this.updateValueAndValidity({
                    onlySelf: true,
                    emitEvent: !!this.asyncValidator
                });
            }
            at(index) {
                return this.controls[this._adjustIndex(index)];
            }
            push(control, options = {}) {
                this.controls.push(control);
                this._registerControl(control);
                this.updateValueAndValidity({
                    emitEvent: options.emitEvent
                });
                this._onCollectionChange();
            }
            insert(index, control, options = {}) {
                this.controls.splice(index, 0, control);
                this._registerControl(control);
                this.updateValueAndValidity({
                    emitEvent: options.emitEvent
                });
            }
            removeAt(index, options = {}) {
                let adjustedIndex = this._adjustIndex(index);
                if (adjustedIndex < 0) {
                    adjustedIndex = 0;
                }
                if (this.controls[adjustedIndex]) {
                    this.controls[adjustedIndex]._registerOnCollectionChange(() => {});
                }
                this.controls.splice(adjustedIndex, 1);
                this.updateValueAndValidity({
                    emitEvent: options.emitEvent
                });
            }
            setControl(index, control, options = {}) {
                let adjustedIndex = this._adjustIndex(index);
                if (adjustedIndex < 0) {
                    adjustedIndex = 0;
                }
                if (this.controls[adjustedIndex]) {
                    this.controls[adjustedIndex]._registerOnCollectionChange(() => {});
                }
                this.controls.splice(adjustedIndex, 1);
                if (control) {
                    this.controls.splice(adjustedIndex, 0, control);
                    this._registerControl(control);
                }
                this.updateValueAndValidity({
                    emitEvent: options.emitEvent
                });
                this._onCollectionChange();
            }
            get length() {
                return this.controls.length;
            }
            setValue(value, options = {}) {
                assertAllValuesPresent(this, false, value);
                value.forEach((newValue, index) => {
                    assertControlPresent(this, false, index);
                    this.at(index).setValue(newValue, {
                        onlySelf: true,
                        emitEvent: options.emitEvent
                    });
                });
                this.updateValueAndValidity(options);
            }
            patchValue(value, options = {}) {
                if (value == null) {
                    return;
                }
                value.forEach((newValue, index) => {
                    if (this.at(index)) {
                        this.at(index).patchValue(newValue, {
                            onlySelf: true,
                            emitEvent: options.emitEvent
                        });
                    }
                });
                this.updateValueAndValidity(options);
            }
            reset(value = [], options = {}) {
                this._forEachChild((control, index) => {
                    control.reset(value[index], {
                        onlySelf: true,
                        emitEvent: options.emitEvent
                    });
                });
                this._updatePristine(options);
                this._updateTouched(options);
                this.updateValueAndValidity(options);
            }
            getRawValue() {
                return this.controls.map(control => control.getRawValue());
            }
            clear(options = {}) {
                if (this.controls.length < 1) {
                    return;
                }
                this._forEachChild(control => control._registerOnCollectionChange(() => {}));
                this.controls.splice(0);
                this.updateValueAndValidity({
                    emitEvent: options.emitEvent
                });
            }
            _adjustIndex(index) {
                return index < 0 ? index + this.length : index;
            }
            _syncPendingControls() {
                let subtreeUpdated = this.controls.reduce((updated, child) => child._syncPendingControls() ? true : updated, false);
                if (subtreeUpdated) {
                    this.updateValueAndValidity({
                        onlySelf: true
                    });
                }
                return subtreeUpdated;
            }
            _forEachChild(cb) {
                this.controls.forEach((control, index) => {
                    cb(control, index);
                });
            }
            _updateValue() {
                this.value = this.controls.filter(control => control.enabled || this.disabled).map(control => control.value);
            }
            _anyControls(condition) {
                return this.controls.some(control => control.enabled && condition(control));
            }
            _setUpControls() {
                this._forEachChild(control => this._registerControl(control));
            }
            _allControlsDisabled() {
                for (const control of this.controls) {
                    if (control.enabled) {
                        return false;
                    }
                }
                return this.controls.length > 0 || this.disabled;
            }
            _registerControl(control) {
                control.setParent(this);
                control._registerOnCollectionChange(this._onCollectionChange);
            }
            _find(name) {
                return this.at(name) ?? null;
            }
        }
        const UntypedFormArray = null;
        const isFormArray = control => control instanceof FormArray;
        function isAbstractControlOptions(options) {
            return !!options && (options.asyncValidators !== void 0 || options.validators !== void 0 || options.updateOn !== void 0);
        }
        let FormBuilder = null;
        (function() {})();
        let NonNullableFormBuilder = null;
        (function() {})();
        let UntypedFormBuilder = null;
        (function() {})();
        const forms_VERSION = new Version("14.3.0");
        function of_of(...args) {
            const scheduler = popScheduler(args);
            return from(args, scheduler);
        }
        class BehaviorSubject extends Subject {
            constructor(_value) {
                super();
                this._value = _value;
            }
            get value() {
                return this.getValue();
            }
            _subscribe(subscriber) {
                const subscription = super._subscribe(subscriber);
                !subscription.closed && subscriber.next(this._value);
                return subscription;
            }
            getValue() {
                const {hasError, thrownError, _value} = this;
                if (hasError) {
                    throw thrownError;
                }
                this._throwIfClosed();
                return _value;
            }
            next(value) {
                super.next(this._value = value);
            }
        }
        const EmptyError = createErrorClass(_super => function EmptyErrorImpl() {
            _super(this);
            this.name = "EmptyError";
            this.message = "no elements in sequence";
        });
        function combineLatest(...args) {
            const scheduler = popScheduler(args);
            const resultSelector = popResultSelector(args);
            const {args: observables, keys} = argsArgArrayOrObject(args);
            if (observables.length === 0) {
                return from([], scheduler);
            }
            const result = new Observable_Observable(combineLatestInit(observables, scheduler, keys ? values => createObject(keys, values) : identity));
            return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
        }
        function combineLatestInit(observables, scheduler, valueTransform = identity) {
            return subscriber => {
                maybeSchedule(scheduler, () => {
                    const {length} = observables;
                    const values = new Array(length);
                    let active = length;
                    let remainingFirstValues = length;
                    for (let i = 0; i < length; i++) {
                        maybeSchedule(scheduler, () => {
                            const source = from(observables[i], scheduler);
                            let hasFirstValue = false;
                            source.subscribe(createOperatorSubscriber(subscriber, value => {
                                values[i] = value;
                                if (!hasFirstValue) {
                                    hasFirstValue = true;
                                    remainingFirstValues--;
                                }
                                if (!remainingFirstValues) {
                                    subscriber.next(valueTransform(values.slice()));
                                }
                            }, () => {
                                if (!--active) {
                                    subscriber.complete();
                                }
                            }));
                        }, subscriber);
                    }
                }, subscriber);
            };
        }
        function maybeSchedule(scheduler, execute, subscription) {
            if (scheduler) {
                executeSchedule(subscription, scheduler, execute);
            } else {
                execute();
            }
        }
        function concatAll() {
            return mergeAll(1);
        }
        function concat(...args) {
            return concatAll()(from(args, popScheduler(args)));
        }
        function defer(observableFactory) {
            return new Observable_Observable(subscriber => {
                innerFrom(observableFactory()).subscribe(subscriber);
            });
        }
        function throwError_throwError(errorOrErrorFactory, scheduler) {
            const errorFactory = isFunction(errorOrErrorFactory) ? errorOrErrorFactory : () => errorOrErrorFactory;
            const init = subscriber => subscriber.error(errorFactory());
            return new Observable_Observable(scheduler ? subscriber => scheduler.schedule(init, 0, subscriber) : init);
        }
        function refCount() {
            return operate((source, subscriber) => {
                let connection = null;
                source._refCount++;
                const refCounter = createOperatorSubscriber(subscriber, void 0, void 0, void 0, () => {
                    if (!source || source._refCount <= 0 || 0 < --source._refCount) {
                        connection = null;
                        return;
                    }
                    const sharedConnection = source._connection;
                    const conn = connection;
                    connection = null;
                    if (sharedConnection && (!conn || sharedConnection === conn)) {
                        sharedConnection.unsubscribe();
                    }
                    subscriber.unsubscribe();
                });
                source.subscribe(refCounter);
                if (!refCounter.closed) {
                    connection = source.connect();
                }
            });
        }
        class ConnectableObservable extends Observable_Observable {
            constructor(source, subjectFactory) {
                super();
                this.source = source;
                this.subjectFactory = subjectFactory;
                this._subject = null;
                this._refCount = 0;
                this._connection = null;
                if (hasLift(source)) {
                    this.lift = source.lift;
                }
            }
            _subscribe(subscriber) {
                return this.getSubject().subscribe(subscriber);
            }
            getSubject() {
                const subject = this._subject;
                if (!subject || subject.isStopped) {
                    this._subject = this.subjectFactory();
                }
                return this._subject;
            }
            _teardown() {
                this._refCount = 0;
                const {_connection} = this;
                this._subject = this._connection = null;
                _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
            }
            connect() {
                let connection = this._connection;
                if (!connection) {
                    connection = this._connection = new Subscription;
                    const subject = this.getSubject();
                    connection.add(this.source.subscribe(createOperatorSubscriber(subject, void 0, () => {
                        this._teardown();
                        subject.complete();
                    }, err => {
                        this._teardown();
                        subject.error(err);
                    }, () => this._teardown())));
                    if (connection.closed) {
                        this._connection = null;
                        connection = Subscription.EMPTY;
                    }
                }
                return connection;
            }
            refCount() {
                return refCount()(this);
            }
        }
        function switchMap(project, resultSelector) {
            return operate((source, subscriber) => {
                let innerSubscriber = null;
                let index = 0;
                let isComplete = false;
                const checkComplete = () => isComplete && !innerSubscriber && subscriber.complete();
                source.subscribe(createOperatorSubscriber(subscriber, value => {
                    innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
                    let innerIndex = 0;
                    const outerIndex = index++;
                    innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = createOperatorSubscriber(subscriber, innerValue => subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue), () => {
                        innerSubscriber = null;
                        checkComplete();
                    }));
                }, () => {
                    isComplete = true;
                    checkComplete();
                }));
            });
        }
        function take(count) {
            return count <= 0 ? () => EMPTY : operate((source, subscriber) => {
                let seen = 0;
                source.subscribe(createOperatorSubscriber(subscriber, value => {
                    if (++seen <= count) {
                        subscriber.next(value);
                        if (count <= seen) {
                            subscriber.complete();
                        }
                    }
                }));
            });
        }
        function startWith(...values) {
            const scheduler = popScheduler(values);
            return operate((source, subscriber) => {
                (scheduler ? concat(values, source, scheduler) : concat(values, source)).subscribe(subscriber);
            });
        }
        function filter(predicate, thisArg) {
            return operate((source, subscriber) => {
                let index = 0;
                source.subscribe(createOperatorSubscriber(subscriber, value => predicate.call(thisArg, value, index++) && subscriber.next(value)));
            });
        }
        function defaultIfEmpty(defaultValue) {
            return operate((source, subscriber) => {
                let hasValue = false;
                source.subscribe(createOperatorSubscriber(subscriber, value => {
                    hasValue = true;
                    subscriber.next(value);
                }, () => {
                    if (!hasValue) {
                        subscriber.next(defaultValue);
                    }
                    subscriber.complete();
                }));
            });
        }
        function throwIfEmpty(errorFactory = defaultErrorFactory) {
            return operate((source, subscriber) => {
                let hasValue = false;
                source.subscribe(createOperatorSubscriber(subscriber, value => {
                    hasValue = true;
                    subscriber.next(value);
                }, () => hasValue ? subscriber.complete() : subscriber.error(errorFactory())));
            });
        }
        function defaultErrorFactory() {
            return new EmptyError;
        }
        function first(predicate, defaultValue) {
            const hasDefaultValue = arguments.length >= 2;
            return source => source.pipe(predicate ? filter((v, i) => predicate(v, i, source)) : identity, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(() => new EmptyError));
        }
        function concatMap(project, resultSelector) {
            return isFunction(resultSelector) ? mergeMap(project, resultSelector, 1) : mergeMap(project, 1);
        }
        function tap(observerOrNext, error, complete) {
            const tapObserver = isFunction(observerOrNext) || error || complete ? {
                next: observerOrNext,
                error,
                complete
            } : observerOrNext;
            return tapObserver ? operate((source, subscriber) => {
                var _a;
                (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
                let isUnsub = true;
                source.subscribe(createOperatorSubscriber(subscriber, value => {
                    var _a2;
                    (_a2 = tapObserver.next) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, value);
                    subscriber.next(value);
                }, () => {
                    var _a2;
                    isUnsub = false;
                    (_a2 = tapObserver.complete) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
                    subscriber.complete();
                }, err => {
                    var _a2;
                    isUnsub = false;
                    (_a2 = tapObserver.error) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, err);
                    subscriber.error(err);
                }, () => {
                    var _a2, _b;
                    if (isUnsub) {
                        (_a2 = tapObserver.unsubscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
                    }
                    (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
                }));
            }) : identity;
        }
        function catchError_catchError(selector) {
            return operate((source, subscriber) => {
                let innerSub = null;
                let syncUnsub = false;
                let handledResult;
                innerSub = source.subscribe(createOperatorSubscriber(subscriber, void 0, void 0, err => {
                    handledResult = innerFrom(selector(err, catchError_catchError(selector)(source)));
                    if (innerSub) {
                        innerSub.unsubscribe();
                        innerSub = null;
                        handledResult.subscribe(subscriber);
                    } else {
                        syncUnsub = true;
                    }
                }));
                if (syncUnsub) {
                    innerSub.unsubscribe();
                    innerSub = null;
                    handledResult.subscribe(subscriber);
                }
            });
        }
        function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
            return (source, subscriber) => {
                let hasState = hasSeed;
                let state = seed;
                let index = 0;
                source.subscribe(createOperatorSubscriber(subscriber, value => {
                    const i = index++;
                    state = hasState ? accumulator(state, value, i) : (hasState = true, value);
                    emitOnNext && subscriber.next(state);
                }, emitBeforeComplete && (() => {
                    hasState && subscriber.next(state);
                    subscriber.complete();
                })));
            };
        }
        function scan(accumulator, seed) {
            return operate(scanInternals(accumulator, seed, arguments.length >= 2, true));
        }
        function takeLast(count) {
            return count <= 0 ? () => EMPTY : operate((source, subscriber) => {
                let buffer = [];
                source.subscribe(createOperatorSubscriber(subscriber, value => {
                    buffer.push(value);
                    count < buffer.length && buffer.shift();
                }, () => {
                    for (const value of buffer) {
                        subscriber.next(value);
                    }
                    subscriber.complete();
                }, void 0, () => {
                    buffer = null;
                }));
            });
        }
        function last_last(predicate, defaultValue) {
            const hasDefaultValue = arguments.length >= 2;
            return source => source.pipe(predicate ? filter((v, i) => predicate(v, i, source)) : identity, takeLast(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(() => new EmptyError));
        }
        function takeWhile(predicate, inclusive = false) {
            return operate((source, subscriber) => {
                let index = 0;
                source.subscribe(createOperatorSubscriber(subscriber, value => {
                    const result = predicate(value, index++);
                    (result || inclusive) && subscriber.next(value);
                    !result && subscriber.complete();
                }));
            });
        }
        function mapTo(value) {
            return map(() => value);
        }
        function finalize(callback) {
            return operate((source, subscriber) => {
                try {
                    source.subscribe(subscriber);
                } finally {
                    subscriber.add(callback);
                }
            });
        }
        const PRIMARY_OUTLET = "primary";
        const RouteTitleKey = Symbol("RouteTitle");
        class ParamsAsMap {
            constructor(params) {
                this.params = params || {};
            }
            has(name) {
                return Object.prototype.hasOwnProperty.call(this.params, name);
            }
            get(name) {
                if (this.has(name)) {
                    const v = this.params[name];
                    return Array.isArray(v) ? v[0] : v;
                }
                return null;
            }
            getAll(name) {
                if (this.has(name)) {
                    const v = this.params[name];
                    return Array.isArray(v) ? v : [ v ];
                }
                return [];
            }
            get keys() {
                return Object.keys(this.params);
            }
        }
        function convertToParamMap(params) {
            return new ParamsAsMap(params);
        }
        function defaultUrlMatcher(segments, segmentGroup, route) {
            const parts = route.path.split("/");
            if (parts.length > segments.length) {
                return null;
            }
            if (route.pathMatch === "full" && (segmentGroup.hasChildren() || parts.length < segments.length)) {
                return null;
            }
            const posParams = {};
            for (let index = 0; index < parts.length; index++) {
                const part = parts[index];
                const segment = segments[index];
                const isParameter = part.startsWith(":");
                if (isParameter) {
                    posParams[part.substring(1)] = segment;
                } else if (part !== segment.path) {
                    return null;
                }
            }
            return {
                consumed: segments.slice(0, parts.length),
                posParams
            };
        }
        function shallowEqualArrays(a, b) {
            if (a.length !== b.length) {
                return false;
            }
            for (let i = 0; i < a.length; ++i) {
                if (!shallowEqual(a[i], b[i])) {
                    return false;
                }
            }
            return true;
        }
        function shallowEqual(a, b) {
            const k1 = a ? Object.keys(a) : void 0;
            const k2 = b ? Object.keys(b) : void 0;
            if (!k1 || !k2 || k1.length != k2.length) {
                return false;
            }
            let key;
            for (let i = 0; i < k1.length; i++) {
                key = k1[i];
                if (!equalArraysOrString(a[key], b[key])) {
                    return false;
                }
            }
            return true;
        }
        function equalArraysOrString(a, b) {
            if (Array.isArray(a) && Array.isArray(b)) {
                if (a.length !== b.length) {
                    return false;
                }
                const aSorted = [ ...a ].sort();
                const bSorted = [ ...b ].sort();
                return aSorted.every((val, index) => bSorted[index] === val);
            } else {
                return a === b;
            }
        }
        function router_flatten(arr) {
            return Array.prototype.concat.apply([], arr);
        }
        function router_last(a) {
            return a.length > 0 ? a[a.length - 1] : null;
        }
        function and(bools) {
            return !bools.some(v => !v);
        }
        function forEach(map2, callback) {
            for (const prop in map2) {
                if (map2.hasOwnProperty(prop)) {
                    callback(map2[prop], prop);
                }
            }
        }
        function wrapIntoObservable(value) {
            if (isObservable(value)) {
                return value;
            }
            if (core_isPromise(value)) {
                return from(Promise.resolve(value));
            }
            return of_of(value);
        }
        const NG_DEV_MODE$9 = false;
        function createEmptyUrlTree() {
            return new UrlTree(new UrlSegmentGroup([], {}), {}, null);
        }
        const pathCompareMap = {
            exact: equalSegmentGroups,
            subset: containsSegmentGroup
        };
        const paramCompareMap = {
            exact: equalParams,
            subset: containsParams,
            ignored: () => true
        };
        function containsTree(container, containee, options) {
            return pathCompareMap[options.paths](container.root, containee.root, options.matrixParams) && paramCompareMap[options.queryParams](container.queryParams, containee.queryParams) && !(options.fragment === "exact" && container.fragment !== containee.fragment);
        }
        function equalParams(container, containee) {
            return shallowEqual(container, containee);
        }
        function equalSegmentGroups(container, containee, matrixParams) {
            if (!equalPath(container.segments, containee.segments)) {
                return false;
            }
            if (!matrixParamsMatch(container.segments, containee.segments, matrixParams)) {
                return false;
            }
            if (container.numberOfChildren !== containee.numberOfChildren) {
                return false;
            }
            for (const c in containee.children) {
                if (!container.children[c]) {
                    return false;
                }
                if (!equalSegmentGroups(container.children[c], containee.children[c], matrixParams)) {
                    return false;
                }
            }
            return true;
        }
        function containsParams(container, containee) {
            return Object.keys(containee).length <= Object.keys(container).length && Object.keys(containee).every(key => equalArraysOrString(container[key], containee[key]));
        }
        function containsSegmentGroup(container, containee, matrixParams) {
            return containsSegmentGroupHelper(container, containee, containee.segments, matrixParams);
        }
        function containsSegmentGroupHelper(container, containee, containeePaths, matrixParams) {
            if (container.segments.length > containeePaths.length) {
                const current = container.segments.slice(0, containeePaths.length);
                if (!equalPath(current, containeePaths)) {
                    return false;
                }
                if (containee.hasChildren()) {
                    return false;
                }
                if (!matrixParamsMatch(current, containeePaths, matrixParams)) {
                    return false;
                }
                return true;
            } else if (container.segments.length === containeePaths.length) {
                if (!equalPath(container.segments, containeePaths)) {
                    return false;
                }
                if (!matrixParamsMatch(container.segments, containeePaths, matrixParams)) {
                    return false;
                }
                for (const c in containee.children) {
                    if (!container.children[c]) {
                        return false;
                    }
                    if (!containsSegmentGroup(container.children[c], containee.children[c], matrixParams)) {
                        return false;
                    }
                }
                return true;
            } else {
                const current = containeePaths.slice(0, container.segments.length);
                const next = containeePaths.slice(container.segments.length);
                if (!equalPath(container.segments, current)) {
                    return false;
                }
                if (!matrixParamsMatch(container.segments, current, matrixParams)) {
                    return false;
                }
                if (!container.children[PRIMARY_OUTLET]) {
                    return false;
                }
                return containsSegmentGroupHelper(container.children[PRIMARY_OUTLET], containee, next, matrixParams);
            }
        }
        function matrixParamsMatch(containerPaths, containeePaths, options) {
            return containeePaths.every((containeeSegment, i) => paramCompareMap[options](containerPaths[i].parameters, containeeSegment.parameters));
        }
        class UrlTree {
            constructor(root, queryParams, fragment) {
                this.root = root;
                this.queryParams = queryParams;
                this.fragment = fragment;
            }
            get queryParamMap() {
                if (!this._queryParamMap) {
                    this._queryParamMap = convertToParamMap(this.queryParams);
                }
                return this._queryParamMap;
            }
            toString() {
                return DEFAULT_SERIALIZER.serialize(this);
            }
        }
        class UrlSegmentGroup {
            constructor(segments, children) {
                this.segments = segments;
                this.children = children;
                this.parent = null;
                forEach(children, (v, k) => v.parent = this);
            }
            hasChildren() {
                return this.numberOfChildren > 0;
            }
            get numberOfChildren() {
                return Object.keys(this.children).length;
            }
            toString() {
                return serializePaths(this);
            }
        }
        class UrlSegment {
            constructor(path, parameters) {
                this.path = path;
                this.parameters = parameters;
            }
            get parameterMap() {
                if (!this._parameterMap) {
                    this._parameterMap = convertToParamMap(this.parameters);
                }
                return this._parameterMap;
            }
            toString() {
                return serializePath(this);
            }
        }
        function equalSegments(as, bs) {
            return equalPath(as, bs) && as.every((a, i) => shallowEqual(a.parameters, bs[i].parameters));
        }
        function equalPath(as, bs) {
            if (as.length !== bs.length) {
                return false;
            }
            return as.every((a, i) => a.path === bs[i].path);
        }
        function mapChildrenIntoArray(segment, fn) {
            let res = [];
            forEach(segment.children, (child, childOutlet) => {
                if (childOutlet === PRIMARY_OUTLET) {
                    res = res.concat(fn(child, childOutlet));
                }
            });
            forEach(segment.children, (child, childOutlet) => {
                if (childOutlet !== PRIMARY_OUTLET) {
                    res = res.concat(fn(child, childOutlet));
                }
            });
            return res;
        }
        let UrlSerializer = (() => {
            class UrlSerializer2 {}
            UrlSerializer2.fac = function UrlSerializer_Factory(t) {
                return new (t || UrlSerializer2);
            };
            UrlSerializer2.prov = defineInjectable({
                token: UrlSerializer2,
                factory: function() {
                    return (() => new DefaultUrlSerializer)();
                },
                providedIn: "root"
            });
            return UrlSerializer2;
        })();
        (function() {})();
        class DefaultUrlSerializer {
            parse(url) {
                const p = new UrlParser(url);
                return new UrlTree(p.parseRootSegment(), p.parseQueryParams(), p.parseFragment());
            }
            serialize(tree2) {
                const segment = `/${serializeSegment(tree2.root, true)}`;
                const query = serializeQueryParams(tree2.queryParams);
                const fragment = typeof tree2.fragment === `string` ? `#${encodeUriFragment(tree2.fragment)}` : "";
                return `${segment}${query}${fragment}`;
            }
        }
        const DEFAULT_SERIALIZER = new DefaultUrlSerializer;
        function serializePaths(segment) {
            return segment.segments.map(p => serializePath(p)).join("/");
        }
        function serializeSegment(segment, root) {
            if (!segment.hasChildren()) {
                return serializePaths(segment);
            }
            if (root) {
                const primary = segment.children[PRIMARY_OUTLET] ? serializeSegment(segment.children[PRIMARY_OUTLET], false) : "";
                const children = [];
                forEach(segment.children, (v, k) => {
                    if (k !== PRIMARY_OUTLET) {
                        children.push(`${k}:${serializeSegment(v, false)}`);
                    }
                });
                return children.length > 0 ? `${primary}(${children.join("//")})` : primary;
            } else {
                const children = mapChildrenIntoArray(segment, (v, k) => {
                    if (k === PRIMARY_OUTLET) {
                        return [ serializeSegment(segment.children[PRIMARY_OUTLET], false) ];
                    }
                    return [ `${k}:${serializeSegment(v, false)}` ];
                });
                if (Object.keys(segment.children).length === 1 && segment.children[PRIMARY_OUTLET] != null) {
                    return `${serializePaths(segment)}/${children[0]}`;
                }
                return `${serializePaths(segment)}/(${children.join("//")})`;
            }
        }
        function encodeUriString(s) {
            return encodeURIComponent(s).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",");
        }
        function encodeUriQuery(s) {
            return encodeUriString(s).replace(/%3B/gi, ";");
        }
        function encodeUriFragment(s) {
            return encodeURI(s);
        }
        function encodeUriSegment(s) {
            return encodeUriString(s).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&");
        }
        function decode(s) {
            return decodeURIComponent(s);
        }
        function decodeQuery(s) {
            return decode(s.replace(/\+/g, "%20"));
        }
        function serializePath(path) {
            return `${encodeUriSegment(path.path)}${serializeMatrixParams(path.parameters)}`;
        }
        function serializeMatrixParams(params) {
            return Object.keys(params).map(key => `;${encodeUriSegment(key)}=${encodeUriSegment(params[key])}`).join("");
        }
        function serializeQueryParams(params) {
            const strParams = Object.keys(params).map(name => {
                const value = params[name];
                return Array.isArray(value) ? value.map(v => `${encodeUriQuery(name)}=${encodeUriQuery(v)}`).join("&") : `${encodeUriQuery(name)}=${encodeUriQuery(value)}`;
            }).filter(s => !!s);
            return strParams.length ? `?${strParams.join("&")}` : "";
        }
        const SEGMENT_RE = /^[^\/()?;=#]+/;
        function matchSegments(str) {
            const match2 = str.match(SEGMENT_RE);
            return match2 ? match2[0] : "";
        }
        const QUERY_PARAM_RE = /^[^=?&#]+/;
        function matchQueryParams(str) {
            const match2 = str.match(QUERY_PARAM_RE);
            return match2 ? match2[0] : "";
        }
        const QUERY_PARAM_VALUE_RE = /^[^&#]+/;
        function matchUrlQueryParamValue(str) {
            const match2 = str.match(QUERY_PARAM_VALUE_RE);
            return match2 ? match2[0] : "";
        }
        class UrlParser {
            constructor(url) {
                this.url = url;
                this.remaining = url;
            }
            parseRootSegment() {
                this.consumeOptional("/");
                if (this.remaining === "" || this.peekStartsWith("?") || this.peekStartsWith("#")) {
                    return new UrlSegmentGroup([], {});
                }
                return new UrlSegmentGroup([], this.parseChildren());
            }
            parseQueryParams() {
                const params = {};
                if (this.consumeOptional("?")) {
                    do {
                        this.parseQueryParam(params);
                    } while (this.consumeOptional("&"));
                }
                return params;
            }
            parseFragment() {
                return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null;
            }
            parseChildren() {
                if (this.remaining === "") {
                    return {};
                }
                this.consumeOptional("/");
                const segments = [];
                if (!this.peekStartsWith("(")) {
                    segments.push(this.parseSegment());
                }
                while (this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/(")) {
                    this.capture("/");
                    segments.push(this.parseSegment());
                }
                let children = {};
                if (this.peekStartsWith("/(")) {
                    this.capture("/");
                    children = this.parseParens(true);
                }
                let res = {};
                if (this.peekStartsWith("(")) {
                    res = this.parseParens(false);
                }
                if (segments.length > 0 || Object.keys(children).length > 0) {
                    res[PRIMARY_OUTLET] = new UrlSegmentGroup(segments, children);
                }
                return res;
            }
            parseSegment() {
                const path = matchSegments(this.remaining);
                if (path === "" && this.peekStartsWith(";")) {
                    throw new RuntimeError(4009, NG_DEV_MODE$9 && `Empty path url segment cannot have parameters: '${this.remaining}'.`);
                }
                this.capture(path);
                return new UrlSegment(decode(path), this.parseMatrixParams());
            }
            parseMatrixParams() {
                const params = {};
                while (this.consumeOptional(";")) {
                    this.parseParam(params);
                }
                return params;
            }
            parseParam(params) {
                const key = matchSegments(this.remaining);
                if (!key) {
                    return;
                }
                this.capture(key);
                let value = "";
                if (this.consumeOptional("=")) {
                    const valueMatch = matchSegments(this.remaining);
                    if (valueMatch) {
                        value = valueMatch;
                        this.capture(value);
                    }
                }
                params[decode(key)] = decode(value);
            }
            parseQueryParam(params) {
                const key = matchQueryParams(this.remaining);
                if (!key) {
                    return;
                }
                this.capture(key);
                let value = "";
                if (this.consumeOptional("=")) {
                    const valueMatch = matchUrlQueryParamValue(this.remaining);
                    if (valueMatch) {
                        value = valueMatch;
                        this.capture(value);
                    }
                }
                const decodedKey = decodeQuery(key);
                const decodedVal = decodeQuery(value);
                if (params.hasOwnProperty(decodedKey)) {
                    let currentVal = params[decodedKey];
                    if (!Array.isArray(currentVal)) {
                        currentVal = [ currentVal ];
                        params[decodedKey] = currentVal;
                    }
                    currentVal.push(decodedVal);
                } else {
                    params[decodedKey] = decodedVal;
                }
            }
            parseParens(allowPrimary) {
                const segments = {};
                this.capture("(");
                while (!this.consumeOptional(")") && this.remaining.length > 0) {
                    const path = matchSegments(this.remaining);
                    const next = this.remaining[path.length];
                    if (next !== "/" && next !== ")" && next !== ";") {
                        throw new RuntimeError(4010, NG_DEV_MODE$9 && `Cannot parse url '${this.url}'`);
                    }
                    let outletName = void 0;
                    if (path.indexOf(":") > -1) {
                        outletName = path.slice(0, path.indexOf(":"));
                        this.capture(outletName);
                        this.capture(":");
                    } else if (allowPrimary) {
                        outletName = PRIMARY_OUTLET;
                    }
                    const children = this.parseChildren();
                    segments[outletName] = Object.keys(children).length === 1 ? children[PRIMARY_OUTLET] : new UrlSegmentGroup([], children);
                    this.consumeOptional("//");
                }
                return segments;
            }
            peekStartsWith(str) {
                return this.remaining.startsWith(str);
            }
            consumeOptional(str) {
                if (this.peekStartsWith(str)) {
                    this.remaining = this.remaining.substring(str.length);
                    return true;
                }
                return false;
            }
            capture(str) {
                if (!this.consumeOptional(str)) {
                    throw new RuntimeError(4011, NG_DEV_MODE$9 && `Expected "${str}".`);
                }
            }
        }
        function createRoot(rootCandidate) {
            return rootCandidate.segments.length > 0 ? new UrlSegmentGroup([], {
                [PRIMARY_OUTLET]: rootCandidate
            }) : rootCandidate;
        }
        function squashSegmentGroup(segmentGroup) {
            const newChildren = {};
            for (const childOutlet of Object.keys(segmentGroup.children)) {
                const child = segmentGroup.children[childOutlet];
                const childCandidate = squashSegmentGroup(child);
                if (childCandidate.segments.length > 0 || childCandidate.hasChildren()) {
                    newChildren[childOutlet] = childCandidate;
                }
            }
            const s = new UrlSegmentGroup(segmentGroup.segments, newChildren);
            return mergeTrivialChildren(s);
        }
        function mergeTrivialChildren(s) {
            if (s.numberOfChildren === 1 && s.children[PRIMARY_OUTLET]) {
                const c = s.children[PRIMARY_OUTLET];
                return new UrlSegmentGroup(s.segments.concat(c.segments), c.children);
            }
            return s;
        }
        function isUrlTree(v) {
            return v instanceof UrlTree;
        }
        const NG_DEV_MODE$8 = false;
        function createUrlTreeFromSnapshot(relativeTo, commands, queryParams = null, fragment = null) {
            const relativeToUrlSegmentGroup = createSegmentGroupFromRoute(relativeTo);
            return createUrlTreeFromSegmentGroup(relativeToUrlSegmentGroup, commands, queryParams, fragment);
        }
        function createSegmentGroupFromRoute(route) {
            let targetGroup;
            function createSegmentGroupFromRouteRecursive(currentRoute) {
                const childOutlets = {};
                for (const childSnapshot of currentRoute.children) {
                    const root = createSegmentGroupFromRouteRecursive(childSnapshot);
                    childOutlets[childSnapshot.outlet] = root;
                }
                const segmentGroup = new UrlSegmentGroup(currentRoute.url, childOutlets);
                if (currentRoute === route) {
                    targetGroup = segmentGroup;
                }
                return segmentGroup;
            }
            const rootCandidate = createSegmentGroupFromRouteRecursive(route.root);
            const rootSegmentGroup = createRoot(rootCandidate);
            return targetGroup ?? rootSegmentGroup;
        }
        function createUrlTreeFromSegmentGroup(relativeTo, commands, queryParams, fragment) {
            let root = relativeTo;
            while (root.parent) {
                root = root.parent;
            }
            if (commands.length === 0) {
                return tree(root, root, root, queryParams, fragment);
            }
            const nav = computeNavigation(commands);
            if (nav.toRoot()) {
                return tree(root, root, new UrlSegmentGroup([], {}), queryParams, fragment);
            }
            const position = findStartingPositionForTargetGroup(nav, root, relativeTo);
            const newSegmentGroup = position.processChildren ? updateSegmentGroupChildren(position.segmentGroup, position.index, nav.commands) : updateSegmentGroup(position.segmentGroup, position.index, nav.commands);
            return tree(root, position.segmentGroup, newSegmentGroup, queryParams, fragment);
        }
        function createUrlTree(route, urlTree, commands, queryParams, fragment) {
            if (commands.length === 0) {
                return tree(urlTree.root, urlTree.root, urlTree.root, queryParams, fragment);
            }
            const nav = computeNavigation(commands);
            if (nav.toRoot()) {
                return tree(urlTree.root, urlTree.root, new UrlSegmentGroup([], {}), queryParams, fragment);
            }
            function createTreeUsingPathIndex(lastPathIndex) {
                const startingPosition = findStartingPosition(nav, urlTree, route.snapshot?._urlSegment, lastPathIndex);
                const segmentGroup = startingPosition.processChildren ? updateSegmentGroupChildren(startingPosition.segmentGroup, startingPosition.index, nav.commands) : updateSegmentGroup(startingPosition.segmentGroup, startingPosition.index, nav.commands);
                return tree(urlTree.root, startingPosition.segmentGroup, segmentGroup, queryParams, fragment);
            }
            const result = createTreeUsingPathIndex(route.snapshot?._lastPathIndex);
            if (false) {
                const correctedResult = createTreeUsingPathIndex(route.snapshot?._correctedLastPathIndex);
                if (correctedResult.toString() !== result.toString()) {
                    console.warn(`relativeLinkResolution: 'legacy' is deprecated and will be removed in a future version of Angular. The link to ${result.toString()} will change to ${correctedResult.toString()} if the code is not updated before then.`);
                }
            }
            return result;
        }
        function isMatrixParams(command) {
            return typeof command === "object" && command != null && !command.outlets && !command.segmentPath;
        }
        function isCommandWithOutlets(command) {
            return typeof command === "object" && command != null && command.outlets;
        }
        function tree(oldRoot, oldSegmentGroup, newSegmentGroup, queryParams, fragment) {
            let qp = {};
            if (queryParams) {
                forEach(queryParams, (value, name) => {
                    qp[name] = Array.isArray(value) ? value.map(v => `${v}`) : `${value}`;
                });
            }
            let rootCandidate;
            if (oldRoot === oldSegmentGroup) {
                rootCandidate = newSegmentGroup;
            } else {
                rootCandidate = replaceSegment(oldRoot, oldSegmentGroup, newSegmentGroup);
            }
            const newRoot = createRoot(squashSegmentGroup(rootCandidate));
            return new UrlTree(newRoot, qp, fragment);
        }
        function replaceSegment(current, oldSegment, newSegment) {
            const children = {};
            forEach(current.children, (c, outletName) => {
                if (c === oldSegment) {
                    children[outletName] = newSegment;
                } else {
                    children[outletName] = replaceSegment(c, oldSegment, newSegment);
                }
            });
            return new UrlSegmentGroup(current.segments, children);
        }
        class Navigation {
            constructor(isAbsolute, numberOfDoubleDots, commands) {
                this.isAbsolute = isAbsolute;
                this.numberOfDoubleDots = numberOfDoubleDots;
                this.commands = commands;
                if (isAbsolute && commands.length > 0 && isMatrixParams(commands[0])) {
                    throw new RuntimeError(4003, NG_DEV_MODE$8 && "Root segment cannot have matrix parameters");
                }
                const cmdWithOutlet = commands.find(isCommandWithOutlets);
                if (cmdWithOutlet && cmdWithOutlet !== router_last(commands)) {
                    throw new RuntimeError(4004, NG_DEV_MODE$8 && "{outlets:{}} has to be the last command");
                }
            }
            toRoot() {
                return this.isAbsolute && this.commands.length === 1 && this.commands[0] == "/";
            }
        }
        function computeNavigation(commands) {
            if (typeof commands[0] === "string" && commands.length === 1 && commands[0] === "/") {
                return new Navigation(true, 0, commands);
            }
            let numberOfDoubleDots = 0;
            let isAbsolute = false;
            const res = commands.reduce((res2, cmd, cmdIdx) => {
                if (typeof cmd === "object" && cmd != null) {
                    if (cmd.outlets) {
                        const outlets = {};
                        forEach(cmd.outlets, (commands2, name) => {
                            outlets[name] = typeof commands2 === "string" ? commands2.split("/") : commands2;
                        });
                        return [ ...res2, {
                            outlets
                        } ];
                    }
                    if (cmd.segmentPath) {
                        return [ ...res2, cmd.segmentPath ];
                    }
                }
                if (!(typeof cmd === "string")) {
                    return [ ...res2, cmd ];
                }
                if (cmdIdx === 0) {
                    cmd.split("/").forEach((urlPart, partIndex) => {
                        if (partIndex == 0 && urlPart === ".") {} else if (partIndex == 0 && urlPart === "") {
                            isAbsolute = true;
                        } else if (urlPart === "..") {
                            numberOfDoubleDots++;
                        } else if (urlPart != "") {
                            res2.push(urlPart);
                        }
                    });
                    return res2;
                }
                return [ ...res2, cmd ];
            }, []);
            return new Navigation(isAbsolute, numberOfDoubleDots, res);
        }
        class Position {
            constructor(segmentGroup, processChildren, index) {
                this.segmentGroup = segmentGroup;
                this.processChildren = processChildren;
                this.index = index;
            }
        }
        function findStartingPositionForTargetGroup(nav, root, target) {
            if (nav.isAbsolute) {
                return new Position(root, true, 0);
            }
            if (!target) {
                return new Position(root, false, NaN);
            }
            if (target.parent === null) {
                return new Position(target, true, 0);
            }
            const modifier = isMatrixParams(nav.commands[0]) ? 0 : 1;
            const index = target.segments.length - 1 + modifier;
            return createPositionApplyingDoubleDots(target, index, nav.numberOfDoubleDots);
        }
        function findStartingPosition(nav, tree2, segmentGroup, lastPathIndex) {
            if (nav.isAbsolute) {
                return new Position(tree2.root, true, 0);
            }
            if (lastPathIndex === -1) {
                const processChildren = segmentGroup === tree2.root;
                return new Position(segmentGroup, processChildren, 0);
            }
            const modifier = isMatrixParams(nav.commands[0]) ? 0 : 1;
            const index = lastPathIndex + modifier;
            return createPositionApplyingDoubleDots(segmentGroup, index, nav.numberOfDoubleDots);
        }
        function createPositionApplyingDoubleDots(group, index, numberOfDoubleDots) {
            let g = group;
            let ci = index;
            let dd = numberOfDoubleDots;
            while (dd > ci) {
                dd -= ci;
                g = g.parent;
                if (!g) {
                    throw new RuntimeError(4005, NG_DEV_MODE$8 && "Invalid number of '../'");
                }
                ci = g.segments.length;
            }
            return new Position(g, false, ci - dd);
        }
        function getOutlets(commands) {
            if (isCommandWithOutlets(commands[0])) {
                return commands[0].outlets;
            }
            return {
                [PRIMARY_OUTLET]: commands
            };
        }
        function updateSegmentGroup(segmentGroup, startIndex, commands) {
            if (!segmentGroup) {
                segmentGroup = new UrlSegmentGroup([], {});
            }
            if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {
                return updateSegmentGroupChildren(segmentGroup, startIndex, commands);
            }
            const m = prefixedWith(segmentGroup, startIndex, commands);
            const slicedCommands = commands.slice(m.commandIndex);
            if (m.match && m.pathIndex < segmentGroup.segments.length) {
                const g = new UrlSegmentGroup(segmentGroup.segments.slice(0, m.pathIndex), {});
                g.children[PRIMARY_OUTLET] = new UrlSegmentGroup(segmentGroup.segments.slice(m.pathIndex), segmentGroup.children);
                return updateSegmentGroupChildren(g, 0, slicedCommands);
            } else if (m.match && slicedCommands.length === 0) {
                return new UrlSegmentGroup(segmentGroup.segments, {});
            } else if (m.match && !segmentGroup.hasChildren()) {
                return createNewSegmentGroup(segmentGroup, startIndex, commands);
            } else if (m.match) {
                return updateSegmentGroupChildren(segmentGroup, 0, slicedCommands);
            } else {
                return createNewSegmentGroup(segmentGroup, startIndex, commands);
            }
        }
        function updateSegmentGroupChildren(segmentGroup, startIndex, commands) {
            if (commands.length === 0) {
                return new UrlSegmentGroup(segmentGroup.segments, {});
            } else {
                const outlets = getOutlets(commands);
                const children = {};
                forEach(outlets, (commands2, outlet) => {
                    if (typeof commands2 === "string") {
                        commands2 = [ commands2 ];
                    }
                    if (commands2 !== null) {
                        children[outlet] = updateSegmentGroup(segmentGroup.children[outlet], startIndex, commands2);
                    }
                });
                forEach(segmentGroup.children, (child, childOutlet) => {
                    if (outlets[childOutlet] === void 0) {
                        children[childOutlet] = child;
                    }
                });
                return new UrlSegmentGroup(segmentGroup.segments, children);
            }
        }
        function prefixedWith(segmentGroup, startIndex, commands) {
            let currentCommandIndex = 0;
            let currentPathIndex = startIndex;
            const noMatch2 = {
                match: false,
                pathIndex: 0,
                commandIndex: 0
            };
            while (currentPathIndex < segmentGroup.segments.length) {
                if (currentCommandIndex >= commands.length) {
                    return noMatch2;
                }
                const path = segmentGroup.segments[currentPathIndex];
                const command = commands[currentCommandIndex];
                if (isCommandWithOutlets(command)) {
                    break;
                }
                const curr = `${command}`;
                const next = currentCommandIndex < commands.length - 1 ? commands[currentCommandIndex + 1] : null;
                if (currentPathIndex > 0 && curr === void 0) {
                    break;
                }
                if (curr && next && typeof next === "object" && next.outlets === void 0) {
                    if (!compare(curr, next, path)) {
                        return noMatch2;
                    }
                    currentCommandIndex += 2;
                } else {
                    if (!compare(curr, {}, path)) {
                        return noMatch2;
                    }
                    currentCommandIndex++;
                }
                currentPathIndex++;
            }
            return {
                match: true,
                pathIndex: currentPathIndex,
                commandIndex: currentCommandIndex
            };
        }
        function createNewSegmentGroup(segmentGroup, startIndex, commands) {
            const paths = segmentGroup.segments.slice(0, startIndex);
            let i = 0;
            while (i < commands.length) {
                const command = commands[i];
                if (isCommandWithOutlets(command)) {
                    const children = createNewSegmentChildren(command.outlets);
                    return new UrlSegmentGroup(paths, children);
                }
                if (i === 0 && isMatrixParams(commands[0])) {
                    const p = segmentGroup.segments[startIndex];
                    paths.push(new UrlSegment(p.path, router_stringify(commands[0])));
                    i++;
                    continue;
                }
                const curr = isCommandWithOutlets(command) ? command.outlets[PRIMARY_OUTLET] : `${command}`;
                const next = i < commands.length - 1 ? commands[i + 1] : null;
                if (curr && next && isMatrixParams(next)) {
                    paths.push(new UrlSegment(curr, router_stringify(next)));
                    i += 2;
                } else {
                    paths.push(new UrlSegment(curr, {}));
                    i++;
                }
            }
            return new UrlSegmentGroup(paths, {});
        }
        function createNewSegmentChildren(outlets) {
            const children = {};
            forEach(outlets, (commands, outlet) => {
                if (typeof commands === "string") {
                    commands = [ commands ];
                }
                if (commands !== null) {
                    children[outlet] = createNewSegmentGroup(new UrlSegmentGroup([], {}), 0, commands);
                }
            });
            return children;
        }
        function router_stringify(params) {
            const res = {};
            forEach(params, (v, k) => res[k] = `${v}`);
            return res;
        }
        function compare(path, params, segment) {
            return path == segment.path && shallowEqual(params, segment.parameters);
        }
        class RouterEvent {
            constructor(id, url) {
                this.id = id;
                this.url = url;
            }
        }
        class NavigationStart extends RouterEvent {
            constructor(id, url, navigationTrigger = "imperative", restoredState = null) {
                super(id, url);
                this.type = 0;
                this.navigationTrigger = navigationTrigger;
                this.restoredState = restoredState;
            }
            toString() {
                return `NavigationStart(id: ${this.id}, url: '${this.url}')`;
            }
        }
        class NavigationEnd extends RouterEvent {
            constructor(id, url, urlAfterRedirects) {
                super(id, url);
                this.urlAfterRedirects = urlAfterRedirects;
                this.type = 1;
            }
            toString() {
                return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`;
            }
        }
        class NavigationCancel extends RouterEvent {
            constructor(id, url, reason, code) {
                super(id, url);
                this.reason = reason;
                this.code = code;
                this.type = 2;
            }
            toString() {
                return `NavigationCancel(id: ${this.id}, url: '${this.url}')`;
            }
        }
        class NavigationError extends RouterEvent {
            constructor(id, url, error, target) {
                super(id, url);
                this.error = error;
                this.target = target;
                this.type = 3;
            }
            toString() {
                return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`;
            }
        }
        class RoutesRecognized extends RouterEvent {
            constructor(id, url, urlAfterRedirects, state) {
                super(id, url);
                this.urlAfterRedirects = urlAfterRedirects;
                this.state = state;
                this.type = 4;
            }
            toString() {
                return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
            }
        }
        class GuardsCheckStart extends RouterEvent {
            constructor(id, url, urlAfterRedirects, state) {
                super(id, url);
                this.urlAfterRedirects = urlAfterRedirects;
                this.state = state;
                this.type = 7;
            }
            toString() {
                return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
            }
        }
        class GuardsCheckEnd extends RouterEvent {
            constructor(id, url, urlAfterRedirects, state, shouldActivate) {
                super(id, url);
                this.urlAfterRedirects = urlAfterRedirects;
                this.state = state;
                this.shouldActivate = shouldActivate;
                this.type = 8;
            }
            toString() {
                return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`;
            }
        }
        class ResolveStart extends RouterEvent {
            constructor(id, url, urlAfterRedirects, state) {
                super(id, url);
                this.urlAfterRedirects = urlAfterRedirects;
                this.state = state;
                this.type = 5;
            }
            toString() {
                return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
            }
        }
        class ResolveEnd extends RouterEvent {
            constructor(id, url, urlAfterRedirects, state) {
                super(id, url);
                this.urlAfterRedirects = urlAfterRedirects;
                this.state = state;
                this.type = 6;
            }
            toString() {
                return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
            }
        }
        class RouteConfigLoadStart {
            constructor(route) {
                this.route = route;
                this.type = 9;
            }
            toString() {
                return `RouteConfigLoadStart(path: ${this.route.path})`;
            }
        }
        class RouteConfigLoadEnd {
            constructor(route) {
                this.route = route;
                this.type = 10;
            }
            toString() {
                return `RouteConfigLoadEnd(path: ${this.route.path})`;
            }
        }
        class ChildActivationStart {
            constructor(snapshot) {
                this.snapshot = snapshot;
                this.type = 11;
            }
            toString() {
                const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || "";
                return `ChildActivationStart(path: '${path}')`;
            }
        }
        class ChildActivationEnd {
            constructor(snapshot) {
                this.snapshot = snapshot;
                this.type = 12;
            }
            toString() {
                const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || "";
                return `ChildActivationEnd(path: '${path}')`;
            }
        }
        class ActivationStart {
            constructor(snapshot) {
                this.snapshot = snapshot;
                this.type = 13;
            }
            toString() {
                const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || "";
                return `ActivationStart(path: '${path}')`;
            }
        }
        class ActivationEnd {
            constructor(snapshot) {
                this.snapshot = snapshot;
                this.type = 14;
            }
            toString() {
                const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || "";
                return `ActivationEnd(path: '${path}')`;
            }
        }
        class Scroll {
            constructor(routerEvent, position, anchor) {
                this.routerEvent = routerEvent;
                this.position = position;
                this.anchor = anchor;
                this.type = 15;
            }
            toString() {
                const pos = this.position ? `${this.position[0]}, ${this.position[1]}` : null;
                return `Scroll(anchor: '${this.anchor}', position: '${pos}')`;
            }
        }
        function stringifyEvent(routerEvent) {
            if (!("type" in routerEvent)) {
                return `Unknown Router Event: ${routerEvent.constructor.name}`;
            }
            switch (routerEvent.type) {
              case 14:
                return `ActivationEnd(path: '${routerEvent.snapshot.routeConfig?.path || ""}')`;

              case 13:
                return `ActivationStart(path: '${routerEvent.snapshot.routeConfig?.path || ""}')`;

              case 12:
                return `ChildActivationEnd(path: '${routerEvent.snapshot.routeConfig?.path || ""}')`;

              case 11:
                return `ChildActivationStart(path: '${routerEvent.snapshot.routeConfig?.path || ""}')`;

              case 8:
                return `GuardsCheckEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state}, shouldActivate: ${routerEvent.shouldActivate})`;

              case 7:
                return `GuardsCheckStart(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;

              case 2:
                return `NavigationCancel(id: ${routerEvent.id}, url: '${routerEvent.url}')`;

              case 1:
                return `NavigationEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}')`;

              case 3:
                return `NavigationError(id: ${routerEvent.id}, url: '${routerEvent.url}', error: ${routerEvent.error})`;

              case 0:
                return `NavigationStart(id: ${routerEvent.id}, url: '${routerEvent.url}')`;

              case 6:
                return `ResolveEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;

              case 5:
                return `ResolveStart(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;

              case 10:
                return `RouteConfigLoadEnd(path: ${routerEvent.route.path})`;

              case 9:
                return `RouteConfigLoadStart(path: ${routerEvent.route.path})`;

              case 4:
                return `RoutesRecognized(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;

              case 15:
                const pos = routerEvent.position ? `${routerEvent.position[0]}, ${routerEvent.position[1]}` : null;
                return `Scroll(anchor: '${routerEvent.anchor}', position: '${pos}')`;
            }
        }
        class Tree {
            constructor(root) {
                this._root = root;
            }
            get root() {
                return this._root.value;
            }
            parent(t) {
                const p = this.pathFromRoot(t);
                return p.length > 1 ? p[p.length - 2] : null;
            }
            children(t) {
                const n = findNode(t, this._root);
                return n ? n.children.map(t2 => t2.value) : [];
            }
            firstChild(t) {
                const n = findNode(t, this._root);
                return n && n.children.length > 0 ? n.children[0].value : null;
            }
            siblings(t) {
                const p = findPath(t, this._root);
                if (p.length < 2) {
                    return [];
                }
                const c = p[p.length - 2].children.map(c2 => c2.value);
                return c.filter(cc => cc !== t);
            }
            pathFromRoot(t) {
                return findPath(t, this._root).map(s => s.value);
            }
        }
        function findNode(value, node) {
            if (value === node.value) {
                return node;
            }
            for (const child of node.children) {
                const node2 = findNode(value, child);
                if (node2) {
                    return node2;
                }
            }
            return null;
        }
        function findPath(value, node) {
            if (value === node.value) {
                return [ node ];
            }
            for (const child of node.children) {
                const path = findPath(value, child);
                if (path.length) {
                    path.unshift(node);
                    return path;
                }
            }
            return [];
        }
        class TreeNode {
            constructor(value, children) {
                this.value = value;
                this.children = children;
            }
            toString() {
                return `TreeNode(${this.value})`;
            }
        }
        function nodeChildrenAsMap(node) {
            const map2 = {};
            if (node) {
                node.children.forEach(child => map2[child.value.outlet] = child);
            }
            return map2;
        }
        class RouterState extends Tree {
            constructor(root, snapshot) {
                super(root);
                this.snapshot = snapshot;
                setRouterState(this, root);
            }
            toString() {
                return this.snapshot.toString();
            }
        }
        function createEmptyState(urlTree, rootComponent) {
            const snapshot = createEmptyStateSnapshot(urlTree, rootComponent);
            const emptyUrl = new BehaviorSubject([ new UrlSegment("", {}) ]);
            const emptyParams = new BehaviorSubject({});
            const emptyData = new BehaviorSubject({});
            const emptyQueryParams = new BehaviorSubject({});
            const fragment = new BehaviorSubject("");
            const activated = new ActivatedRoute(emptyUrl, emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, snapshot.root);
            activated.snapshot = snapshot.root;
            return new RouterState(new TreeNode(activated, []), snapshot);
        }
        function createEmptyStateSnapshot(urlTree, rootComponent) {
            const emptyParams = {};
            const emptyData = {};
            const emptyQueryParams = {};
            const fragment = "";
            const activated = new ActivatedRouteSnapshot([], emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, null, urlTree.root, -1, {});
            return new RouterStateSnapshot("", new TreeNode(activated, []));
        }
        class ActivatedRoute {
            constructor(url, params, queryParams, fragment, data, outlet, component, futureSnapshot) {
                this.url = url;
                this.params = params;
                this.queryParams = queryParams;
                this.fragment = fragment;
                this.data = data;
                this.outlet = outlet;
                this.component = component;
                this.title = this.data?.pipe(map(d => d[RouteTitleKey])) ?? of_of(void 0);
                this._futureSnapshot = futureSnapshot;
            }
            get routeConfig() {
                return this._futureSnapshot.routeConfig;
            }
            get root() {
                return this._routerState.root;
            }
            get parent() {
                return this._routerState.parent(this);
            }
            get firstChild() {
                return this._routerState.firstChild(this);
            }
            get children() {
                return this._routerState.children(this);
            }
            get pathFromRoot() {
                return this._routerState.pathFromRoot(this);
            }
            get paramMap() {
                if (!this._paramMap) {
                    this._paramMap = this.params.pipe(map(p => convertToParamMap(p)));
                }
                return this._paramMap;
            }
            get queryParamMap() {
                if (!this._queryParamMap) {
                    this._queryParamMap = this.queryParams.pipe(map(p => convertToParamMap(p)));
                }
                return this._queryParamMap;
            }
            toString() {
                return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})`;
            }
        }
        function inheritedParamsDataResolve(route, paramsInheritanceStrategy = "emptyOnly") {
            const pathFromRoot = route.pathFromRoot;
            let inheritingStartingFrom = 0;
            if (paramsInheritanceStrategy !== "always") {
                inheritingStartingFrom = pathFromRoot.length - 1;
                while (inheritingStartingFrom >= 1) {
                    const current = pathFromRoot[inheritingStartingFrom];
                    const parent = pathFromRoot[inheritingStartingFrom - 1];
                    if (current.routeConfig && current.routeConfig.path === "") {
                        inheritingStartingFrom--;
                    } else if (!parent.component) {
                        inheritingStartingFrom--;
                    } else {
                        break;
                    }
                }
            }
            return flattenInherited(pathFromRoot.slice(inheritingStartingFrom));
        }
        function flattenInherited(pathFromRoot) {
            return pathFromRoot.reduce((res, curr) => {
                const params = {
                    ...res.params,
                    ...curr.params
                };
                const data = {
                    ...res.data,
                    ...curr.data
                };
                const resolve = {
                    ...curr.data,
                    ...res.resolve,
                    ...curr.routeConfig?.data,
                    ...curr._resolvedData
                };
                return {
                    params,
                    data,
                    resolve
                };
            }, {
                params: {},
                data: {},
                resolve: {}
            });
        }
        class ActivatedRouteSnapshot {
            constructor(url, params, queryParams, fragment, data, outlet, component, routeConfig, urlSegment, lastPathIndex, resolve, correctedLastPathIndex) {
                this.url = url;
                this.params = params;
                this.queryParams = queryParams;
                this.fragment = fragment;
                this.data = data;
                this.outlet = outlet;
                this.component = component;
                this.title = this.data?.[RouteTitleKey];
                this.routeConfig = routeConfig;
                this._urlSegment = urlSegment;
                this._lastPathIndex = lastPathIndex;
                this._correctedLastPathIndex = correctedLastPathIndex ?? lastPathIndex;
                this._resolve = resolve;
            }
            get root() {
                return this._routerState.root;
            }
            get parent() {
                return this._routerState.parent(this);
            }
            get firstChild() {
                return this._routerState.firstChild(this);
            }
            get children() {
                return this._routerState.children(this);
            }
            get pathFromRoot() {
                return this._routerState.pathFromRoot(this);
            }
            get paramMap() {
                if (!this._paramMap) {
                    this._paramMap = convertToParamMap(this.params);
                }
                return this._paramMap;
            }
            get queryParamMap() {
                if (!this._queryParamMap) {
                    this._queryParamMap = convertToParamMap(this.queryParams);
                }
                return this._queryParamMap;
            }
            toString() {
                const url = this.url.map(segment => segment.toString()).join("/");
                const matched = this.routeConfig ? this.routeConfig.path : "";
                return `Route(url:'${url}', path:'${matched}')`;
            }
        }
        class RouterStateSnapshot extends Tree {
            constructor(url, root) {
                super(root);
                this.url = url;
                setRouterState(this, root);
            }
            toString() {
                return serializeNode(this._root);
            }
        }
        function setRouterState(state, node) {
            node.value._routerState = state;
            node.children.forEach(c => setRouterState(state, c));
        }
        function serializeNode(node) {
            const c = node.children.length > 0 ? ` { ${node.children.map(serializeNode).join(", ")} } ` : "";
            return `${node.value}${c}`;
        }
        function advanceActivatedRoute(route) {
            if (route.snapshot) {
                const currentSnapshot = route.snapshot;
                const nextSnapshot = route._futureSnapshot;
                route.snapshot = nextSnapshot;
                if (!shallowEqual(currentSnapshot.queryParams, nextSnapshot.queryParams)) {
                    route.queryParams.next(nextSnapshot.queryParams);
                }
                if (currentSnapshot.fragment !== nextSnapshot.fragment) {
                    route.fragment.next(nextSnapshot.fragment);
                }
                if (!shallowEqual(currentSnapshot.params, nextSnapshot.params)) {
                    route.params.next(nextSnapshot.params);
                }
                if (!shallowEqualArrays(currentSnapshot.url, nextSnapshot.url)) {
                    route.url.next(nextSnapshot.url);
                }
                if (!shallowEqual(currentSnapshot.data, nextSnapshot.data)) {
                    route.data.next(nextSnapshot.data);
                }
            } else {
                route.snapshot = route._futureSnapshot;
                route.data.next(route._futureSnapshot.data);
            }
        }
        function equalParamsAndUrlSegments(a, b) {
            const equalUrlParams = shallowEqual(a.params, b.params) && equalSegments(a.url, b.url);
            const parentsMismatch = !a.parent !== !b.parent;
            return equalUrlParams && !parentsMismatch && (!a.parent || equalParamsAndUrlSegments(a.parent, b.parent));
        }
        function createRouterState(routeReuseStrategy, curr, prevState) {
            const root = createNode(routeReuseStrategy, curr._root, prevState ? prevState._root : void 0);
            return new RouterState(root, curr);
        }
        function createNode(routeReuseStrategy, curr, prevState) {
            if (prevState && routeReuseStrategy.shouldReuseRoute(curr.value, prevState.value.snapshot)) {
                const value = prevState.value;
                value._futureSnapshot = curr.value;
                const children = createOrReuseChildren(routeReuseStrategy, curr, prevState);
                return new TreeNode(value, children);
            } else {
                if (routeReuseStrategy.shouldAttach(curr.value)) {
                    const detachedRouteHandle = routeReuseStrategy.retrieve(curr.value);
                    if (detachedRouteHandle !== null) {
                        const tree2 = detachedRouteHandle.route;
                        tree2.value._futureSnapshot = curr.value;
                        tree2.children = curr.children.map(c => createNode(routeReuseStrategy, c));
                        return tree2;
                    }
                }
                const value = createActivatedRoute(curr.value);
                const children = curr.children.map(c => createNode(routeReuseStrategy, c));
                return new TreeNode(value, children);
            }
        }
        function createOrReuseChildren(routeReuseStrategy, curr, prevState) {
            return curr.children.map(child => {
                for (const p of prevState.children) {
                    if (routeReuseStrategy.shouldReuseRoute(child.value, p.value.snapshot)) {
                        return createNode(routeReuseStrategy, child, p);
                    }
                }
                return createNode(routeReuseStrategy, child);
            });
        }
        function createActivatedRoute(c) {
            return new ActivatedRoute(new BehaviorSubject(c.url), new BehaviorSubject(c.params), new BehaviorSubject(c.queryParams), new BehaviorSubject(c.fragment), new BehaviorSubject(c.data), c.outlet, c.component, c);
        }
        const NAVIGATION_CANCELING_ERROR = "ngNavigationCancelingError";
        function redirectingNavigationError(urlSerializer, redirect) {
            const {redirectTo, navigationBehaviorOptions} = isUrlTree(redirect) ? {
                redirectTo: redirect,
                navigationBehaviorOptions: void 0
            } : redirect;
            const error = navigationCancelingError(false, 0, redirect);
            error.url = redirectTo;
            error.navigationBehaviorOptions = navigationBehaviorOptions;
            return error;
        }
        function navigationCancelingError(message, code, redirectUrl) {
            const error = new Error("NavigationCancelingError: " + (message || ""));
            error[NAVIGATION_CANCELING_ERROR] = true;
            error.cancellationCode = code;
            if (redirectUrl) {
                error.url = redirectUrl;
            }
            return error;
        }
        function isRedirectingNavigationCancelingError$1(error) {
            return isNavigationCancelingError$1(error) && isUrlTree(error.url);
        }
        function isNavigationCancelingError$1(error) {
            return error && error[NAVIGATION_CANCELING_ERROR];
        }
        class OutletContext {
            constructor() {
                this.outlet = null;
                this.route = null;
                this.resolver = null;
                this.injector = null;
                this.children = new ChildrenOutletContexts;
                this.attachRef = null;
            }
        }
        let ChildrenOutletContexts = (() => {
            class ChildrenOutletContexts2 {
                constructor() {
                    this.contexts = new Map;
                }
                onChildOutletCreated(childName, outlet) {
                    const context2 = this.getOrCreateContext(childName);
                    context2.outlet = outlet;
                    this.contexts.set(childName, context2);
                }
                onChildOutletDestroyed(childName) {
                    const context2 = this.getContext(childName);
                    if (context2) {
                        context2.outlet = null;
                        context2.attachRef = null;
                    }
                }
                onOutletDeactivated() {
                    const contexts = this.contexts;
                    this.contexts = new Map;
                    return contexts;
                }
                onOutletReAttached(contexts) {
                    this.contexts = contexts;
                }
                getOrCreateContext(childName) {
                    let context2 = this.getContext(childName);
                    if (!context2) {
                        context2 = new OutletContext;
                        this.contexts.set(childName, context2);
                    }
                    return context2;
                }
                getContext(childName) {
                    return this.contexts.get(childName) || null;
                }
            }
            ChildrenOutletContexts2.fac = function ChildrenOutletContexts_Factory(t) {
                return new (t || ChildrenOutletContexts2);
            };
            ChildrenOutletContexts2.prov = defineInjectable({
                token: ChildrenOutletContexts2,
                factory: ChildrenOutletContexts2.fac,
                providedIn: "root"
            });
            return ChildrenOutletContexts2;
        })();
        (function() {})();
        const NG_DEV_MODE$7 = false;
        let RouterOutlet = (() => {
            class RouterOutlet2 {
                constructor(parentContexts, location2, name, changeDetector, environmentInjector) {
                    this.parentContexts = parentContexts;
                    this.location = location2;
                    this.changeDetector = changeDetector;
                    this.environmentInjector = environmentInjector;
                    this.activated = null;
                    this._activatedRoute = null;
                    this.activateEvents = new EventEmitter;
                    this.deactivateEvents = new EventEmitter;
                    this.attachEvents = new EventEmitter;
                    this.detachEvents = new EventEmitter;
                    this.name = name || PRIMARY_OUTLET;
                    parentContexts.onChildOutletCreated(this.name, this);
                }
                ngOnDestroy() {
                    if (this.parentContexts.getContext(this.name)?.outlet === this) {
                        this.parentContexts.onChildOutletDestroyed(this.name);
                    }
                }
                ngOnInit() {
                    if (!this.activated) {
                        const context2 = this.parentContexts.getContext(this.name);
                        if (context2 && context2.route) {
                            if (context2.attachRef) {
                                this.attach(context2.attachRef, context2.route);
                            } else {
                                this.activateWith(context2.route, context2.injector);
                            }
                        }
                    }
                }
                get isActivated() {
                    return !!this.activated;
                }
                get component() {
                    if (!this.activated) {
                        throw new RuntimeError(4012, NG_DEV_MODE$7 && "Outlet is not activated");
                    }
                    return this.activated.instance;
                }
                get activatedRoute() {
                    if (!this.activated) {
                        throw new RuntimeError(4012, NG_DEV_MODE$7 && "Outlet is not activated");
                    }
                    return this._activatedRoute;
                }
                get activatedRouteData() {
                    if (this._activatedRoute) {
                        return this._activatedRoute.snapshot.data;
                    }
                    return {};
                }
                detach() {
                    if (!this.activated) {
                        throw new RuntimeError(4012, NG_DEV_MODE$7 && "Outlet is not activated");
                    }
                    this.location.detach();
                    const cmp = this.activated;
                    this.activated = null;
                    this._activatedRoute = null;
                    this.detachEvents.emit(cmp.instance);
                    return cmp;
                }
                attach(ref, activatedRoute) {
                    this.activated = ref;
                    this._activatedRoute = activatedRoute;
                    this.location.insert(ref.hostView);
                    this.attachEvents.emit(ref.instance);
                }
                deactivate() {
                    if (this.activated) {
                        const c = this.component;
                        this.activated.destroy();
                        this.activated = null;
                        this._activatedRoute = null;
                        this.deactivateEvents.emit(c);
                    }
                }
                activateWith(activatedRoute, resolverOrInjector) {
                    if (this.isActivated) {
                        throw new RuntimeError(4013, NG_DEV_MODE$7 && "Cannot activate an already activated outlet");
                    }
                    this._activatedRoute = activatedRoute;
                    const location2 = this.location;
                    const snapshot = activatedRoute._futureSnapshot;
                    const component = snapshot.component;
                    const childContexts = this.parentContexts.getOrCreateContext(this.name).children;
                    const injector = new OutletInjector(activatedRoute, childContexts, location2.injector);
                    if (resolverOrInjector && isComponentFactoryResolver(resolverOrInjector)) {
                        const factory = resolverOrInjector.resolveComponentFactory(component);
                        this.activated = location2.createComponent(factory, location2.length, injector);
                    } else {
                        const environmentInjector = resolverOrInjector ?? this.environmentInjector;
                        this.activated = location2.createComponent(component, {
                            index: location2.length,
                            injector,
                            environmentInjector
                        });
                    }
                    this.changeDetector.markForCheck();
                    this.activateEvents.emit(this.activated.instance);
                }
            }
            RouterOutlet2.fac = function RouterOutlet_Factory(t) {
                return new (t || RouterOutlet2)(directiveInject(ChildrenOutletContexts), directiveInject(ViewContainerRef), injectAttribute("name"), directiveInject(ChangeDetectorRef), directiveInject(EnvironmentInjector));
            };
            RouterOutlet2.dir = defineDirective({
                type: RouterOutlet2,
                selectors: [ [ "router-outlet" ] ],
                outputs: {
                    activateEvents: "activate",
                    deactivateEvents: "deactivate",
                    attachEvents: "attach",
                    detachEvents: "detach"
                },
                exportAs: [ "outlet" ],
                standalone: true
            });
            return RouterOutlet2;
        })();
        (function() {})();
        class OutletInjector {
            constructor(route, childContexts, parent) {
                this.route = route;
                this.childContexts = childContexts;
                this.parent = parent;
            }
            get(token, notFoundValue) {
                if (token === ActivatedRoute) {
                    return this.route;
                }
                if (token === ChildrenOutletContexts) {
                    return this.childContexts;
                }
                return this.parent.get(token, notFoundValue);
            }
        }
        function isComponentFactoryResolver(item) {
            return !!item.resolveComponentFactory;
        }
        let EmptyOutletComponent = (() => {
            class EmptyOutletComponent2 {}
            EmptyOutletComponent2.fac = function EmptyOutletComponent_Factory(t) {
                return new (t || EmptyOutletComponent2);
            };
            EmptyOutletComponent2.cmp = defineComponent({
                type: EmptyOutletComponent2,
                selectors: [ [ "ng-component" ] ],
                standalone: true,
                features: [ StandaloneFeature ],
                decls: 1,
                vars: 0,
                template: function EmptyOutletComponent_Template(rf, ctx) {
                    if (rf & 1) {
                        element(0, "router-outlet");
                    }
                },
                dependencies: [ RouterOutlet ],
                encapsulation: 2
            });
            return EmptyOutletComponent2;
        })();
        (function() {})();
        function getOrCreateRouteInjectorIfNeeded(route, currentInjector) {
            if (route.providers && !route._injector) {
                route._injector = createEnvironmentInjector(route.providers, currentInjector, `Route: ${route.path}`);
            }
            return route._injector ?? currentInjector;
        }
        function getLoadedRoutes(route) {
            return route._loadedRoutes;
        }
        function getLoadedInjector(route) {
            return route._loadedInjector;
        }
        function getLoadedComponent(route) {
            return route._loadedComponent;
        }
        function getProvidersInjector(route) {
            return route._injector;
        }
        function validateConfig(config2, parentPath = "", requireStandaloneComponents = false) {
            for (let i = 0; i < config2.length; i++) {
                const route = config2[i];
                const fullPath = getFullPath(parentPath, route);
                validateNode(route, fullPath, requireStandaloneComponents);
            }
        }
        function assertStandalone(fullPath, component) {
            if (component && !isStandalone(component)) {
                throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}'. The component must be standalone.`);
            }
        }
        function validateNode(route, fullPath, requireStandaloneComponents) {
            if (false) {
                if (!route) {
                    throw new RuntimeError(4014, `\n      Invalid configuration of route '${fullPath}': Encountered undefined route.\n      The reason might be an extra comma.\n\n      Example:\n      const routes: Routes = [\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\n        { path: 'detail/:id', component: HeroDetailComponent }\n      ];\n    `);
                }
                if (Array.isArray(route)) {
                    throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': Array cannot be specified`);
                }
                if (!route.redirectTo && !route.component && !route.loadComponent && !route.children && !route.loadChildren && route.outlet && route.outlet !== PRIMARY_OUTLET) {
                    throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': a componentless route without children or loadChildren cannot have a named outlet set`);
                }
                if (route.redirectTo && route.children) {
                    throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': redirectTo and children cannot be used together`);
                }
                if (route.redirectTo && route.loadChildren) {
                    throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': redirectTo and loadChildren cannot be used together`);
                }
                if (route.children && route.loadChildren) {
                    throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': children and loadChildren cannot be used together`);
                }
                if (route.redirectTo && (route.component || route.loadComponent)) {
                    throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': redirectTo and component/loadComponent cannot be used together`);
                }
                if (route.component && route.loadComponent) {
                    throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': component and loadComponent cannot be used together`);
                }
                if (route.redirectTo && route.canActivate) {
                    throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': redirectTo and canActivate cannot be used together. Redirects happen before activation so canActivate will never be executed.`);
                }
                if (route.path && route.matcher) {
                    throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': path and matcher cannot be used together`);
                }
                if (route.redirectTo === void 0 && !route.component && !route.loadComponent && !route.children && !route.loadChildren) {
                    throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}'. One of the following must be provided: component, loadComponent, redirectTo, children or loadChildren`);
                }
                if (route.path === void 0 && route.matcher === void 0) {
                    throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': routes must have either a path or a matcher specified`);
                }
                if (typeof route.path === "string" && route.path.charAt(0) === "/") {
                    throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': path cannot start with a slash`);
                }
                if (route.path === "" && route.redirectTo !== void 0 && route.pathMatch === void 0) {
                    const exp = `The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.`;
                    throw new RuntimeError(4014, `Invalid configuration of route '{path: "${fullPath}", redirectTo: "${route.redirectTo}"}': please provide 'pathMatch'. ${exp}`);
                }
                if (requireStandaloneComponents) {
                    assertStandalone(fullPath, route.component);
                }
            }
            if (route.children) {
                validateConfig(route.children, fullPath, requireStandaloneComponents);
            }
        }
        function getFullPath(parentPath, currentRoute) {
            if (!currentRoute) {
                return parentPath;
            }
            if (!parentPath && !currentRoute.path) {
                return "";
            } else if (parentPath && !currentRoute.path) {
                return `${parentPath}/`;
            } else if (!parentPath && currentRoute.path) {
                return currentRoute.path;
            } else {
                return `${parentPath}/${currentRoute.path}`;
            }
        }
        function standardizeConfig(r) {
            const children = r.children && r.children.map(standardizeConfig);
            const c = children ? {
                ...r,
                children
            } : {
                ...r
            };
            if (!c.component && !c.loadComponent && (children || c.loadChildren) && c.outlet && c.outlet !== PRIMARY_OUTLET) {
                c.component = EmptyOutletComponent;
            }
            return c;
        }
        function getOutlet(route) {
            return route.outlet || PRIMARY_OUTLET;
        }
        function sortByMatchingOutlets(routes2, outletName) {
            const sortedConfig = routes2.filter(r => getOutlet(r) === outletName);
            sortedConfig.push(...routes2.filter(r => getOutlet(r) !== outletName));
            return sortedConfig;
        }
        function getClosestRouteInjector(snapshot) {
            if (!snapshot) {
                return null;
            }
            if (snapshot.routeConfig?._injector) {
                return snapshot.routeConfig._injector;
            }
            for (let s = snapshot.parent; s; s = s.parent) {
                const route = s.routeConfig;
                if (route?._loadedInjector) {
                    return route._loadedInjector;
                }
                if (route?._injector) {
                    return route._injector;
                }
            }
            return null;
        }
        const activateRoutes = (rootContexts, routeReuseStrategy, forwardEvent) => map(t => {
            new ActivateRoutes(routeReuseStrategy, t.targetRouterState, t.currentRouterState, forwardEvent).activate(rootContexts);
            return t;
        });
        class ActivateRoutes {
            constructor(routeReuseStrategy, futureState, currState, forwardEvent) {
                this.routeReuseStrategy = routeReuseStrategy;
                this.futureState = futureState;
                this.currState = currState;
                this.forwardEvent = forwardEvent;
            }
            activate(parentContexts) {
                const futureRoot = this.futureState._root;
                const currRoot = this.currState ? this.currState._root : null;
                this.deactivateChildRoutes(futureRoot, currRoot, parentContexts);
                advanceActivatedRoute(this.futureState.root);
                this.activateChildRoutes(futureRoot, currRoot, parentContexts);
            }
            deactivateChildRoutes(futureNode, currNode, contexts) {
                const children = nodeChildrenAsMap(currNode);
                futureNode.children.forEach(futureChild => {
                    const childOutletName = futureChild.value.outlet;
                    this.deactivateRoutes(futureChild, children[childOutletName], contexts);
                    delete children[childOutletName];
                });
                forEach(children, (v, childName) => {
                    this.deactivateRouteAndItsChildren(v, contexts);
                });
            }
            deactivateRoutes(futureNode, currNode, parentContext) {
                const future = futureNode.value;
                const curr = currNode ? currNode.value : null;
                if (future === curr) {
                    if (future.component) {
                        const context2 = parentContext.getContext(future.outlet);
                        if (context2) {
                            this.deactivateChildRoutes(futureNode, currNode, context2.children);
                        }
                    } else {
                        this.deactivateChildRoutes(futureNode, currNode, parentContext);
                    }
                } else {
                    if (curr) {
                        this.deactivateRouteAndItsChildren(currNode, parentContext);
                    }
                }
            }
            deactivateRouteAndItsChildren(route, parentContexts) {
                if (route.value.component && this.routeReuseStrategy.shouldDetach(route.value.snapshot)) {
                    this.detachAndStoreRouteSubtree(route, parentContexts);
                } else {
                    this.deactivateRouteAndOutlet(route, parentContexts);
                }
            }
            detachAndStoreRouteSubtree(route, parentContexts) {
                const context2 = parentContexts.getContext(route.value.outlet);
                const contexts = context2 && route.value.component ? context2.children : parentContexts;
                const children = nodeChildrenAsMap(route);
                for (const childOutlet of Object.keys(children)) {
                    this.deactivateRouteAndItsChildren(children[childOutlet], contexts);
                }
                if (context2 && context2.outlet) {
                    const componentRef = context2.outlet.detach();
                    const contexts2 = context2.children.onOutletDeactivated();
                    this.routeReuseStrategy.store(route.value.snapshot, {
                        componentRef,
                        route,
                        contexts: contexts2
                    });
                }
            }
            deactivateRouteAndOutlet(route, parentContexts) {
                const context2 = parentContexts.getContext(route.value.outlet);
                const contexts = context2 && route.value.component ? context2.children : parentContexts;
                const children = nodeChildrenAsMap(route);
                for (const childOutlet of Object.keys(children)) {
                    this.deactivateRouteAndItsChildren(children[childOutlet], contexts);
                }
                if (context2 && context2.outlet) {
                    context2.outlet.deactivate();
                    context2.children.onOutletDeactivated();
                    context2.attachRef = null;
                    context2.resolver = null;
                    context2.route = null;
                }
            }
            activateChildRoutes(futureNode, currNode, contexts) {
                const children = nodeChildrenAsMap(currNode);
                futureNode.children.forEach(c => {
                    this.activateRoutes(c, children[c.value.outlet], contexts);
                    this.forwardEvent(new ActivationEnd(c.value.snapshot));
                });
                if (futureNode.children.length) {
                    this.forwardEvent(new ChildActivationEnd(futureNode.value.snapshot));
                }
            }
            activateRoutes(futureNode, currNode, parentContexts) {
                const future = futureNode.value;
                const curr = currNode ? currNode.value : null;
                advanceActivatedRoute(future);
                if (future === curr) {
                    if (future.component) {
                        const context2 = parentContexts.getOrCreateContext(future.outlet);
                        this.activateChildRoutes(futureNode, currNode, context2.children);
                    } else {
                        this.activateChildRoutes(futureNode, currNode, parentContexts);
                    }
                } else {
                    if (future.component) {
                        const context2 = parentContexts.getOrCreateContext(future.outlet);
                        if (this.routeReuseStrategy.shouldAttach(future.snapshot)) {
                            const stored = this.routeReuseStrategy.retrieve(future.snapshot);
                            this.routeReuseStrategy.store(future.snapshot, null);
                            context2.children.onOutletReAttached(stored.contexts);
                            context2.attachRef = stored.componentRef;
                            context2.route = stored.route.value;
                            if (context2.outlet) {
                                context2.outlet.attach(stored.componentRef, stored.route.value);
                            }
                            advanceActivatedRoute(stored.route.value);
                            this.activateChildRoutes(futureNode, null, context2.children);
                        } else {
                            const injector = getClosestRouteInjector(future.snapshot);
                            const cmpFactoryResolver = injector?.get(ComponentFactoryResolver$1) ?? null;
                            context2.attachRef = null;
                            context2.route = future;
                            context2.resolver = cmpFactoryResolver;
                            context2.injector = injector;
                            if (context2.outlet) {
                                context2.outlet.activateWith(future, context2.injector);
                            }
                            this.activateChildRoutes(futureNode, null, context2.children);
                        }
                    } else {
                        this.activateChildRoutes(futureNode, null, parentContexts);
                    }
                }
            }
        }
        class CanActivate {
            constructor(path) {
                this.path = path;
                this.route = this.path[this.path.length - 1];
            }
        }
        class CanDeactivate {
            constructor(component, route) {
                this.component = component;
                this.route = route;
            }
        }
        function getAllRouteGuards(future, curr, parentContexts) {
            const futureRoot = future._root;
            const currRoot = curr ? curr._root : null;
            return getChildRouteGuards(futureRoot, currRoot, parentContexts, [ futureRoot.value ]);
        }
        function getCanActivateChild(p) {
            const canActivateChild = p.routeConfig ? p.routeConfig.canActivateChild : null;
            if (!canActivateChild || canActivateChild.length === 0) {
                return null;
            }
            return {
                node: p,
                guards: canActivateChild
            };
        }
        function getTokenOrFunctionIdentity(tokenOrFunction, injector) {
            const NOT_FOUND2 = Symbol();
            const result = injector.get(tokenOrFunction, NOT_FOUND2);
            if (result === NOT_FOUND2) {
                if (typeof tokenOrFunction === "function" && !isInjectable(tokenOrFunction)) {
                    return tokenOrFunction;
                } else {
                    return injector.get(tokenOrFunction);
                }
            }
            return result;
        }
        function getChildRouteGuards(futureNode, currNode, contexts, futurePath, checks = {
            canDeactivateChecks: [],
            canActivateChecks: []
        }) {
            const prevChildren = nodeChildrenAsMap(currNode);
            futureNode.children.forEach(c => {
                getRouteGuards(c, prevChildren[c.value.outlet], contexts, futurePath.concat([ c.value ]), checks);
                delete prevChildren[c.value.outlet];
            });
            forEach(prevChildren, (v, k) => deactivateRouteAndItsChildren(v, contexts.getContext(k), checks));
            return checks;
        }
        function getRouteGuards(futureNode, currNode, parentContexts, futurePath, checks = {
            canDeactivateChecks: [],
            canActivateChecks: []
        }) {
            const future = futureNode.value;
            const curr = currNode ? currNode.value : null;
            const context2 = parentContexts ? parentContexts.getContext(futureNode.value.outlet) : null;
            if (curr && future.routeConfig === curr.routeConfig) {
                const shouldRun = shouldRunGuardsAndResolvers(curr, future, future.routeConfig.runGuardsAndResolvers);
                if (shouldRun) {
                    checks.canActivateChecks.push(new CanActivate(futurePath));
                } else {
                    future.data = curr.data;
                    future._resolvedData = curr._resolvedData;
                }
                if (future.component) {
                    getChildRouteGuards(futureNode, currNode, context2 ? context2.children : null, futurePath, checks);
                } else {
                    getChildRouteGuards(futureNode, currNode, parentContexts, futurePath, checks);
                }
                if (shouldRun && context2 && context2.outlet && context2.outlet.isActivated) {
                    checks.canDeactivateChecks.push(new CanDeactivate(context2.outlet.component, curr));
                }
            } else {
                if (curr) {
                    deactivateRouteAndItsChildren(currNode, context2, checks);
                }
                checks.canActivateChecks.push(new CanActivate(futurePath));
                if (future.component) {
                    getChildRouteGuards(futureNode, null, context2 ? context2.children : null, futurePath, checks);
                } else {
                    getChildRouteGuards(futureNode, null, parentContexts, futurePath, checks);
                }
            }
            return checks;
        }
        function shouldRunGuardsAndResolvers(curr, future, mode) {
            if (typeof mode === "function") {
                return mode(curr, future);
            }
            switch (mode) {
              case "pathParamsChange":
                return !equalPath(curr.url, future.url);

              case "pathParamsOrQueryParamsChange":
                return !equalPath(curr.url, future.url) || !shallowEqual(curr.queryParams, future.queryParams);

              case "always":
                return true;

              case "paramsOrQueryParamsChange":
                return !equalParamsAndUrlSegments(curr, future) || !shallowEqual(curr.queryParams, future.queryParams);

              case "paramsChange":
              default:
                return !equalParamsAndUrlSegments(curr, future);
            }
        }
        function deactivateRouteAndItsChildren(route, context2, checks) {
            const children = nodeChildrenAsMap(route);
            const r = route.value;
            forEach(children, (node, childName) => {
                if (!r.component) {
                    deactivateRouteAndItsChildren(node, context2, checks);
                } else if (context2) {
                    deactivateRouteAndItsChildren(node, context2.children.getContext(childName), checks);
                } else {
                    deactivateRouteAndItsChildren(node, null, checks);
                }
            });
            if (!r.component) {
                checks.canDeactivateChecks.push(new CanDeactivate(null, r));
            } else if (context2 && context2.outlet && context2.outlet.isActivated) {
                checks.canDeactivateChecks.push(new CanDeactivate(context2.outlet.component, r));
            } else {
                checks.canDeactivateChecks.push(new CanDeactivate(null, r));
            }
        }
        function router_isFunction(v) {
            return typeof v === "function";
        }
        function isBoolean(v) {
            return typeof v === "boolean";
        }
        function isCanLoad(guard) {
            return guard && router_isFunction(guard.canLoad);
        }
        function isCanActivate(guard) {
            return guard && router_isFunction(guard.canActivate);
        }
        function isCanActivateChild(guard) {
            return guard && router_isFunction(guard.canActivateChild);
        }
        function isCanDeactivate(guard) {
            return guard && router_isFunction(guard.canDeactivate);
        }
        function isCanMatch(guard) {
            return guard && router_isFunction(guard.canMatch);
        }
        function isRedirectingNavigationCancelingError(error) {
            return isNavigationCancelingError(error) && isUrlTree(error.url);
        }
        function isNavigationCancelingError(error) {
            return error && error[NAVIGATION_CANCELING_ERROR];
        }
        function isEmptyError(e) {
            return e instanceof EmptyError || e?.name === "EmptyError";
        }
        const INITIAL_VALUE = Symbol("INITIAL_VALUE");
        function prioritizedGuardValue() {
            return switchMap(obs => combineLatest(obs.map(o => o.pipe(take(1), startWith(INITIAL_VALUE)))).pipe(map(results => {
                for (const result of results) {
                    if (result === true) {
                        continue;
                    } else if (result === INITIAL_VALUE) {
                        return INITIAL_VALUE;
                    } else if (result === false || result instanceof UrlTree) {
                        return result;
                    }
                }
                return true;
            }), filter(item => item !== INITIAL_VALUE), take(1)));
        }
        function checkGuards(injector, forwardEvent) {
            return mergeMap(t => {
                const {targetSnapshot, currentSnapshot, guards: {canActivateChecks, canDeactivateChecks}} = t;
                if (canDeactivateChecks.length === 0 && canActivateChecks.length === 0) {
                    return of_of({
                        ...t,
                        guardsResult: true
                    });
                }
                return runCanDeactivateChecks(canDeactivateChecks, targetSnapshot, currentSnapshot, injector).pipe(mergeMap(canDeactivate => canDeactivate && isBoolean(canDeactivate) ? runCanActivateChecks(targetSnapshot, canActivateChecks, injector, forwardEvent) : of_of(canDeactivate)), map(guardsResult => ({
                    ...t,
                    guardsResult
                })));
            });
        }
        function runCanDeactivateChecks(checks, futureRSS, currRSS, injector) {
            return from(checks).pipe(mergeMap(check => runCanDeactivate(check.component, check.route, currRSS, futureRSS, injector)), first(result => result !== true, true));
        }
        function runCanActivateChecks(futureSnapshot, checks, injector, forwardEvent) {
            return from(checks).pipe(concatMap(check => concat(fireChildActivationStart(check.route.parent, forwardEvent), fireActivationStart(check.route, forwardEvent), runCanActivateChild(futureSnapshot, check.path, injector), runCanActivate(futureSnapshot, check.route, injector))), first(result => result !== true, true));
        }
        function fireActivationStart(snapshot, forwardEvent) {
            if (snapshot !== null && forwardEvent) {
                forwardEvent(new ActivationStart(snapshot));
            }
            return of_of(true);
        }
        function fireChildActivationStart(snapshot, forwardEvent) {
            if (snapshot !== null && forwardEvent) {
                forwardEvent(new ChildActivationStart(snapshot));
            }
            return of_of(true);
        }
        function runCanActivate(futureRSS, futureARS, injector) {
            const canActivate = futureARS.routeConfig ? futureARS.routeConfig.canActivate : null;
            if (!canActivate || canActivate.length === 0) {
                return of_of(true);
            }
            const canActivateObservables = canActivate.map(canActivate2 => defer(() => {
                const closestInjector = getClosestRouteInjector(futureARS) ?? injector;
                const guard = getTokenOrFunctionIdentity(canActivate2, closestInjector);
                const guardVal = isCanActivate(guard) ? guard.canActivate(futureARS, futureRSS) : closestInjector.runInContext(() => guard(futureARS, futureRSS));
                return wrapIntoObservable(guardVal).pipe(first());
            }));
            return of_of(canActivateObservables).pipe(prioritizedGuardValue());
        }
        function runCanActivateChild(futureRSS, path, injector) {
            const futureARS = path[path.length - 1];
            const canActivateChildGuards = path.slice(0, path.length - 1).reverse().map(p => getCanActivateChild(p)).filter(_ => _ !== null);
            const canActivateChildGuardsMapped = canActivateChildGuards.map(d => defer(() => {
                const guardsMapped = d.guards.map(canActivateChild => {
                    const closestInjector = getClosestRouteInjector(d.node) ?? injector;
                    const guard = getTokenOrFunctionIdentity(canActivateChild, closestInjector);
                    const guardVal = isCanActivateChild(guard) ? guard.canActivateChild(futureARS, futureRSS) : closestInjector.runInContext(() => guard(futureARS, futureRSS));
                    return wrapIntoObservable(guardVal).pipe(first());
                });
                return of_of(guardsMapped).pipe(prioritizedGuardValue());
            }));
            return of_of(canActivateChildGuardsMapped).pipe(prioritizedGuardValue());
        }
        function runCanDeactivate(component, currARS, currRSS, futureRSS, injector) {
            const canDeactivate = currARS && currARS.routeConfig ? currARS.routeConfig.canDeactivate : null;
            if (!canDeactivate || canDeactivate.length === 0) {
                return of_of(true);
            }
            const canDeactivateObservables = canDeactivate.map(c => {
                const closestInjector = getClosestRouteInjector(currARS) ?? injector;
                const guard = getTokenOrFunctionIdentity(c, closestInjector);
                const guardVal = isCanDeactivate(guard) ? guard.canDeactivate(component, currARS, currRSS, futureRSS) : closestInjector.runInContext(() => guard(component, currARS, currRSS, futureRSS));
                return wrapIntoObservable(guardVal).pipe(first());
            });
            return of_of(canDeactivateObservables).pipe(prioritizedGuardValue());
        }
        function runCanLoadGuards(injector, route, segments, urlSerializer) {
            const canLoad = route.canLoad;
            if (canLoad === void 0 || canLoad.length === 0) {
                return of_of(true);
            }
            const canLoadObservables = canLoad.map(injectionToken => {
                const guard = getTokenOrFunctionIdentity(injectionToken, injector);
                const guardVal = isCanLoad(guard) ? guard.canLoad(route, segments) : injector.runInContext(() => guard(route, segments));
                return wrapIntoObservable(guardVal);
            });
            return of_of(canLoadObservables).pipe(prioritizedGuardValue(), redirectIfUrlTree(urlSerializer));
        }
        function redirectIfUrlTree(urlSerializer) {
            return pipe(tap(result => {
                if (!isUrlTree(result)) {
                    return;
                }
                throw redirectingNavigationError(urlSerializer, result);
            }), map(result => result === true));
        }
        function runCanMatchGuards(injector, route, segments, urlSerializer) {
            const canMatch = route.canMatch;
            if (!canMatch || canMatch.length === 0) {
                return of_of(true);
            }
            const canMatchObservables = canMatch.map(injectionToken => {
                const guard = getTokenOrFunctionIdentity(injectionToken, injector);
                const guardVal = isCanMatch(guard) ? guard.canMatch(route, segments) : injector.runInContext(() => guard(route, segments));
                return wrapIntoObservable(guardVal);
            });
            return of_of(canMatchObservables).pipe(prioritizedGuardValue(), redirectIfUrlTree(urlSerializer));
        }
        const noMatch$1 = {
            matched: false,
            consumedSegments: [],
            remainingSegments: [],
            parameters: {},
            positionalParamSegments: {}
        };
        function matchWithChecks(segmentGroup, route, segments, injector, urlSerializer) {
            const result = match(segmentGroup, route, segments);
            if (!result.matched) {
                return of_of(result);
            }
            injector = getOrCreateRouteInjectorIfNeeded(route, injector);
            return runCanMatchGuards(injector, route, segments, urlSerializer).pipe(map(v => v === true ? result : {
                ...noMatch$1
            }));
        }
        function match(segmentGroup, route, segments) {
            if (route.path === "") {
                if (route.pathMatch === "full" && (segmentGroup.hasChildren() || segments.length > 0)) {
                    return {
                        ...noMatch$1
                    };
                }
                return {
                    matched: true,
                    consumedSegments: [],
                    remainingSegments: segments,
                    parameters: {},
                    positionalParamSegments: {}
                };
            }
            const matcher = route.matcher || defaultUrlMatcher;
            const res = matcher(segments, segmentGroup, route);
            if (!res) {
                return {
                    ...noMatch$1
                };
            }
            const posParams = {};
            forEach(res.posParams, (v, k) => {
                posParams[k] = v.path;
            });
            const parameters = res.consumed.length > 0 ? {
                ...posParams,
                ...res.consumed[res.consumed.length - 1].parameters
            } : posParams;
            return {
                matched: true,
                consumedSegments: res.consumed,
                remainingSegments: segments.slice(res.consumed.length),
                parameters,
                positionalParamSegments: res.posParams ?? {}
            };
        }
        function split(segmentGroup, consumedSegments, slicedSegments, config2, relativeLinkResolution = "corrected") {
            if (slicedSegments.length > 0 && containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, config2)) {
                const s2 = new UrlSegmentGroup(consumedSegments, createChildrenForEmptyPaths(segmentGroup, consumedSegments, config2, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));
                s2._sourceSegment = segmentGroup;
                s2._segmentIndexShift = consumedSegments.length;
                return {
                    segmentGroup: s2,
                    slicedSegments: []
                };
            }
            if (slicedSegments.length === 0 && containsEmptyPathMatches(segmentGroup, slicedSegments, config2)) {
                const s2 = new UrlSegmentGroup(segmentGroup.segments, addEmptyPathsToChildrenIfNeeded(segmentGroup, consumedSegments, slicedSegments, config2, segmentGroup.children, relativeLinkResolution));
                s2._sourceSegment = segmentGroup;
                s2._segmentIndexShift = consumedSegments.length;
                return {
                    segmentGroup: s2,
                    slicedSegments
                };
            }
            const s = new UrlSegmentGroup(segmentGroup.segments, segmentGroup.children);
            s._sourceSegment = segmentGroup;
            s._segmentIndexShift = consumedSegments.length;
            return {
                segmentGroup: s,
                slicedSegments
            };
        }
        function addEmptyPathsToChildrenIfNeeded(segmentGroup, consumedSegments, slicedSegments, routes2, children, relativeLinkResolution) {
            const res = {};
            for (const r of routes2) {
                if (emptyPathMatch(segmentGroup, slicedSegments, r) && !children[getOutlet(r)]) {
                    const s = new UrlSegmentGroup([], {});
                    s._sourceSegment = segmentGroup;
                    if (relativeLinkResolution === "legacy") {
                        s._segmentIndexShift = segmentGroup.segments.length;
                        if (false) {
                            s._segmentIndexShiftCorrected = consumedSegments.length;
                        }
                    } else {
                        s._segmentIndexShift = consumedSegments.length;
                    }
                    res[getOutlet(r)] = s;
                }
            }
            return {
                ...children,
                ...res
            };
        }
        function createChildrenForEmptyPaths(segmentGroup, consumedSegments, routes2, primarySegment) {
            const res = {};
            res[PRIMARY_OUTLET] = primarySegment;
            primarySegment._sourceSegment = segmentGroup;
            primarySegment._segmentIndexShift = consumedSegments.length;
            for (const r of routes2) {
                if (r.path === "" && getOutlet(r) !== PRIMARY_OUTLET) {
                    const s = new UrlSegmentGroup([], {});
                    s._sourceSegment = segmentGroup;
                    s._segmentIndexShift = consumedSegments.length;
                    res[getOutlet(r)] = s;
                }
            }
            return res;
        }
        function containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, routes2) {
            return routes2.some(r => emptyPathMatch(segmentGroup, slicedSegments, r) && getOutlet(r) !== PRIMARY_OUTLET);
        }
        function containsEmptyPathMatches(segmentGroup, slicedSegments, routes2) {
            return routes2.some(r => emptyPathMatch(segmentGroup, slicedSegments, r));
        }
        function emptyPathMatch(segmentGroup, slicedSegments, r) {
            if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === "full") {
                return false;
            }
            return r.path === "";
        }
        function isImmediateMatch(route, rawSegment, segments, outlet) {
            if (getOutlet(route) !== outlet && (outlet === PRIMARY_OUTLET || !emptyPathMatch(rawSegment, segments, route))) {
                return false;
            }
            if (route.path === "**") {
                return true;
            }
            return match(rawSegment, route, segments).matched;
        }
        function noLeftoversInUrl(segmentGroup, segments, outlet) {
            return segments.length === 0 && !segmentGroup.children[outlet];
        }
        const NG_DEV_MODE$6 = false;
        class NoMatch$1 {
            constructor(segmentGroup) {
                this.segmentGroup = segmentGroup || null;
            }
        }
        class AbsoluteRedirect {
            constructor(urlTree) {
                this.urlTree = urlTree;
            }
        }
        function noMatch(segmentGroup) {
            return throwError_throwError(new NoMatch$1(segmentGroup));
        }
        function absoluteRedirect(newTree) {
            return throwError_throwError(new AbsoluteRedirect(newTree));
        }
        function namedOutletsRedirect(redirectTo) {
            return throwError_throwError(new RuntimeError(4e3, NG_DEV_MODE$6 && `Only absolute redirects can have named outlets. redirectTo: '${redirectTo}'`));
        }
        function canLoadFails(route) {
            return throwError_throwError(navigationCancelingError(NG_DEV_MODE$6 && `Cannot load children because the guard of the route "path: '${route.path}'" returned false`, 3));
        }
        function applyRedirects$1(injector, configLoader, urlSerializer, urlTree, config2) {
            return new ApplyRedirects(injector, configLoader, urlSerializer, urlTree, config2).apply();
        }
        class ApplyRedirects {
            constructor(injector, configLoader, urlSerializer, urlTree, config2) {
                this.injector = injector;
                this.configLoader = configLoader;
                this.urlSerializer = urlSerializer;
                this.urlTree = urlTree;
                this.config = config2;
                this.allowRedirects = true;
            }
            apply() {
                const splitGroup = split(this.urlTree.root, [], [], this.config).segmentGroup;
                const rootSegmentGroup = new UrlSegmentGroup(splitGroup.segments, splitGroup.children);
                const expanded$ = this.expandSegmentGroup(this.injector, this.config, rootSegmentGroup, PRIMARY_OUTLET);
                const urlTrees$ = expanded$.pipe(map(rootSegmentGroup2 => this.createUrlTree(squashSegmentGroup(rootSegmentGroup2), this.urlTree.queryParams, this.urlTree.fragment)));
                return urlTrees$.pipe(catchError_catchError(e => {
                    if (e instanceof AbsoluteRedirect) {
                        this.allowRedirects = false;
                        return this.match(e.urlTree);
                    }
                    if (e instanceof NoMatch$1) {
                        throw this.noMatchError(e);
                    }
                    throw e;
                }));
            }
            match(tree2) {
                const expanded$ = this.expandSegmentGroup(this.injector, this.config, tree2.root, PRIMARY_OUTLET);
                const mapped$ = expanded$.pipe(map(rootSegmentGroup => this.createUrlTree(squashSegmentGroup(rootSegmentGroup), tree2.queryParams, tree2.fragment)));
                return mapped$.pipe(catchError_catchError(e => {
                    if (e instanceof NoMatch$1) {
                        throw this.noMatchError(e);
                    }
                    throw e;
                }));
            }
            noMatchError(e) {
                return new RuntimeError(4002, NG_DEV_MODE$6 && `Cannot match any routes. URL Segment: '${e.segmentGroup}'`);
            }
            createUrlTree(rootCandidate, queryParams, fragment) {
                const root = createRoot(rootCandidate);
                return new UrlTree(root, queryParams, fragment);
            }
            expandSegmentGroup(injector, routes2, segmentGroup, outlet) {
                if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {
                    return this.expandChildren(injector, routes2, segmentGroup).pipe(map(children => new UrlSegmentGroup([], children)));
                }
                return this.expandSegment(injector, segmentGroup, routes2, segmentGroup.segments, outlet, true);
            }
            expandChildren(injector, routes2, segmentGroup) {
                const childOutlets = [];
                for (const child of Object.keys(segmentGroup.children)) {
                    if (child === "primary") {
                        childOutlets.unshift(child);
                    } else {
                        childOutlets.push(child);
                    }
                }
                return from(childOutlets).pipe(concatMap(childOutlet => {
                    const child = segmentGroup.children[childOutlet];
                    const sortedRoutes = sortByMatchingOutlets(routes2, childOutlet);
                    return this.expandSegmentGroup(injector, sortedRoutes, child, childOutlet).pipe(map(s => ({
                        segment: s,
                        outlet: childOutlet
                    })));
                }), scan((children, expandedChild) => {
                    children[expandedChild.outlet] = expandedChild.segment;
                    return children;
                }, {}), last_last());
            }
            expandSegment(injector, segmentGroup, routes2, segments, outlet, allowRedirects) {
                return from(routes2).pipe(concatMap(r => {
                    const expanded$ = this.expandSegmentAgainstRoute(injector, segmentGroup, routes2, r, segments, outlet, allowRedirects);
                    return expanded$.pipe(catchError_catchError(e => {
                        if (e instanceof NoMatch$1) {
                            return of_of(null);
                        }
                        throw e;
                    }));
                }), first(s => !!s), catchError_catchError((e, _) => {
                    if (isEmptyError(e)) {
                        if (noLeftoversInUrl(segmentGroup, segments, outlet)) {
                            return of_of(new UrlSegmentGroup([], {}));
                        }
                        return noMatch(segmentGroup);
                    }
                    throw e;
                }));
            }
            expandSegmentAgainstRoute(injector, segmentGroup, routes2, route, paths, outlet, allowRedirects) {
                if (!isImmediateMatch(route, segmentGroup, paths, outlet)) {
                    return noMatch(segmentGroup);
                }
                if (route.redirectTo === void 0) {
                    return this.matchSegmentAgainstRoute(injector, segmentGroup, route, paths, outlet);
                }
                if (allowRedirects && this.allowRedirects) {
                    return this.expandSegmentAgainstRouteUsingRedirect(injector, segmentGroup, routes2, route, paths, outlet);
                }
                return noMatch(segmentGroup);
            }
            expandSegmentAgainstRouteUsingRedirect(injector, segmentGroup, routes2, route, segments, outlet) {
                if (route.path === "**") {
                    return this.expandWildCardWithParamsAgainstRouteUsingRedirect(injector, routes2, route, outlet);
                }
                return this.expandRegularSegmentAgainstRouteUsingRedirect(injector, segmentGroup, routes2, route, segments, outlet);
            }
            expandWildCardWithParamsAgainstRouteUsingRedirect(injector, routes2, route, outlet) {
                const newTree = this.applyRedirectCommands([], route.redirectTo, {});
                if (route.redirectTo.startsWith("/")) {
                    return absoluteRedirect(newTree);
                }
                return this.lineralizeSegments(route, newTree).pipe(mergeMap(newSegments => {
                    const group = new UrlSegmentGroup(newSegments, {});
                    return this.expandSegment(injector, group, routes2, newSegments, outlet, false);
                }));
            }
            expandRegularSegmentAgainstRouteUsingRedirect(injector, segmentGroup, routes2, route, segments, outlet) {
                const {matched, consumedSegments, remainingSegments, positionalParamSegments} = match(segmentGroup, route, segments);
                if (!matched) {
                    return noMatch(segmentGroup);
                }
                const newTree = this.applyRedirectCommands(consumedSegments, route.redirectTo, positionalParamSegments);
                if (route.redirectTo.startsWith("/")) {
                    return absoluteRedirect(newTree);
                }
                return this.lineralizeSegments(route, newTree).pipe(mergeMap(newSegments => this.expandSegment(injector, segmentGroup, routes2, newSegments.concat(remainingSegments), outlet, false)));
            }
            matchSegmentAgainstRoute(injector, rawSegmentGroup, route, segments, outlet) {
                if (route.path === "**") {
                    injector = getOrCreateRouteInjectorIfNeeded(route, injector);
                    if (route.loadChildren) {
                        const loaded$ = route._loadedRoutes ? of_of({
                            routes: route._loadedRoutes,
                            injector: route._loadedInjector
                        }) : this.configLoader.loadChildren(injector, route);
                        return loaded$.pipe(map(cfg => {
                            route._loadedRoutes = cfg.routes;
                            route._loadedInjector = cfg.injector;
                            return new UrlSegmentGroup(segments, {});
                        }));
                    }
                    return of_of(new UrlSegmentGroup(segments, {}));
                }
                return matchWithChecks(rawSegmentGroup, route, segments, injector, this.urlSerializer).pipe(switchMap(({matched, consumedSegments, remainingSegments}) => {
                    if (!matched) {
                        return noMatch(rawSegmentGroup);
                    }
                    injector = route._injector ?? injector;
                    const childConfig$ = this.getChildConfig(injector, route, segments);
                    return childConfig$.pipe(mergeMap(routerConfig => {
                        const childInjector = routerConfig.injector ?? injector;
                        const childConfig = routerConfig.routes;
                        const {segmentGroup: splitSegmentGroup, slicedSegments} = split(rawSegmentGroup, consumedSegments, remainingSegments, childConfig);
                        const segmentGroup = new UrlSegmentGroup(splitSegmentGroup.segments, splitSegmentGroup.children);
                        if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {
                            const expanded$2 = this.expandChildren(childInjector, childConfig, segmentGroup);
                            return expanded$2.pipe(map(children => new UrlSegmentGroup(consumedSegments, children)));
                        }
                        if (childConfig.length === 0 && slicedSegments.length === 0) {
                            return of_of(new UrlSegmentGroup(consumedSegments, {}));
                        }
                        const matchedOnOutlet = getOutlet(route) === outlet;
                        const expanded$ = this.expandSegment(childInjector, segmentGroup, childConfig, slicedSegments, matchedOnOutlet ? PRIMARY_OUTLET : outlet, true);
                        return expanded$.pipe(map(cs => new UrlSegmentGroup(consumedSegments.concat(cs.segments), cs.children)));
                    }));
                }));
            }
            getChildConfig(injector, route, segments) {
                if (route.children) {
                    return of_of({
                        routes: route.children,
                        injector
                    });
                }
                if (route.loadChildren) {
                    if (route._loadedRoutes !== void 0) {
                        return of_of({
                            routes: route._loadedRoutes,
                            injector: route._loadedInjector
                        });
                    }
                    return runCanLoadGuards(injector, route, segments, this.urlSerializer).pipe(mergeMap(shouldLoadResult => {
                        if (shouldLoadResult) {
                            return this.configLoader.loadChildren(injector, route).pipe(tap(cfg => {
                                route._loadedRoutes = cfg.routes;
                                route._loadedInjector = cfg.injector;
                            }));
                        }
                        return canLoadFails(route);
                    }));
                }
                return of_of({
                    routes: [],
                    injector
                });
            }
            lineralizeSegments(route, urlTree) {
                let res = [];
                let c = urlTree.root;
                while (true) {
                    res = res.concat(c.segments);
                    if (c.numberOfChildren === 0) {
                        return of_of(res);
                    }
                    if (c.numberOfChildren > 1 || !c.children[PRIMARY_OUTLET]) {
                        return namedOutletsRedirect(route.redirectTo);
                    }
                    c = c.children[PRIMARY_OUTLET];
                }
            }
            applyRedirectCommands(segments, redirectTo, posParams) {
                return this.applyRedirectCreateUrlTree(redirectTo, this.urlSerializer.parse(redirectTo), segments, posParams);
            }
            applyRedirectCreateUrlTree(redirectTo, urlTree, segments, posParams) {
                const newRoot = this.createSegmentGroup(redirectTo, urlTree.root, segments, posParams);
                return new UrlTree(newRoot, this.createQueryParams(urlTree.queryParams, this.urlTree.queryParams), urlTree.fragment);
            }
            createQueryParams(redirectToParams, actualParams) {
                const res = {};
                forEach(redirectToParams, (v, k) => {
                    const copySourceValue = typeof v === "string" && v.startsWith(":");
                    if (copySourceValue) {
                        const sourceName = v.substring(1);
                        res[k] = actualParams[sourceName];
                    } else {
                        res[k] = v;
                    }
                });
                return res;
            }
            createSegmentGroup(redirectTo, group, segments, posParams) {
                const updatedSegments = this.createSegments(redirectTo, group.segments, segments, posParams);
                let children = {};
                forEach(group.children, (child, name) => {
                    children[name] = this.createSegmentGroup(redirectTo, child, segments, posParams);
                });
                return new UrlSegmentGroup(updatedSegments, children);
            }
            createSegments(redirectTo, redirectToSegments, actualSegments, posParams) {
                return redirectToSegments.map(s => s.path.startsWith(":") ? this.findPosParam(redirectTo, s, posParams) : this.findOrReturn(s, actualSegments));
            }
            findPosParam(redirectTo, redirectToUrlSegment, posParams) {
                const pos = posParams[redirectToUrlSegment.path.substring(1)];
                if (!pos) {
                    throw new RuntimeError(4001, NG_DEV_MODE$6 && `Cannot redirect to '${redirectTo}'. Cannot find '${redirectToUrlSegment.path}'.`);
                }
                return pos;
            }
            findOrReturn(redirectToUrlSegment, actualSegments) {
                let idx = 0;
                for (const s of actualSegments) {
                    if (s.path === redirectToUrlSegment.path) {
                        actualSegments.splice(idx);
                        return s;
                    }
                    idx++;
                }
                return redirectToUrlSegment;
            }
        }
        function applyRedirects(environmentInjector, configLoader, urlSerializer, config2) {
            return switchMap(t => applyRedirects$1(environmentInjector, configLoader, urlSerializer, t.extractedUrl, config2).pipe(map(urlAfterRedirects => ({
                ...t,
                urlAfterRedirects
            }))));
        }
        const NG_DEV_MODE$5 = false;
        class NoMatch {}
        function newObservableError(e) {
            return new Observable_Observable(obs => obs.error(e));
        }
        function recognize$1(injector, rootComponentType, config2, urlTree, url, urlSerializer, paramsInheritanceStrategy = "emptyOnly", relativeLinkResolution = "legacy") {
            return new Recognizer(injector, rootComponentType, config2, urlTree, url, paramsInheritanceStrategy, relativeLinkResolution, urlSerializer).recognize().pipe(switchMap(result => {
                if (result === null) {
                    return newObservableError(new NoMatch);
                } else {
                    return of_of(result);
                }
            }));
        }
        class Recognizer {
            constructor(injector, rootComponentType, config2, urlTree, url, paramsInheritanceStrategy, relativeLinkResolution, urlSerializer) {
                this.injector = injector;
                this.rootComponentType = rootComponentType;
                this.config = config2;
                this.urlTree = urlTree;
                this.url = url;
                this.paramsInheritanceStrategy = paramsInheritanceStrategy;
                this.relativeLinkResolution = relativeLinkResolution;
                this.urlSerializer = urlSerializer;
            }
            recognize() {
                const rootSegmentGroup = split(this.urlTree.root, [], [], this.config.filter(c => c.redirectTo === void 0), this.relativeLinkResolution).segmentGroup;
                return this.processSegmentGroup(this.injector, this.config, rootSegmentGroup, PRIMARY_OUTLET).pipe(map(children => {
                    if (children === null) {
                        return null;
                    }
                    const root = new ActivatedRouteSnapshot([], Object.freeze({}), Object.freeze({
                        ...this.urlTree.queryParams
                    }), this.urlTree.fragment, {}, PRIMARY_OUTLET, this.rootComponentType, null, this.urlTree.root, -1, {});
                    const rootNode = new TreeNode(root, children);
                    const routeState = new RouterStateSnapshot(this.url, rootNode);
                    this.inheritParamsAndData(routeState._root);
                    return routeState;
                }));
            }
            inheritParamsAndData(routeNode) {
                const route = routeNode.value;
                const i = inheritedParamsDataResolve(route, this.paramsInheritanceStrategy);
                route.params = Object.freeze(i.params);
                route.data = Object.freeze(i.data);
                routeNode.children.forEach(n => this.inheritParamsAndData(n));
            }
            processSegmentGroup(injector, config2, segmentGroup, outlet) {
                if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {
                    return this.processChildren(injector, config2, segmentGroup);
                }
                return this.processSegment(injector, config2, segmentGroup, segmentGroup.segments, outlet);
            }
            processChildren(injector, config2, segmentGroup) {
                return from(Object.keys(segmentGroup.children)).pipe(concatMap(childOutlet => {
                    const child = segmentGroup.children[childOutlet];
                    const sortedConfig = sortByMatchingOutlets(config2, childOutlet);
                    return this.processSegmentGroup(injector, sortedConfig, child, childOutlet);
                }), scan((children, outletChildren) => {
                    if (!children || !outletChildren) {
                        return null;
                    }
                    children.push(...outletChildren);
                    return children;
                }), takeWhile(children => children !== null), defaultIfEmpty(null), last_last(), map(children => {
                    if (children === null) {
                        return null;
                    }
                    const mergedChildren = mergeEmptyPathMatches(children);
                    if (NG_DEV_MODE$5) {
                        checkOutletNameUniqueness(mergedChildren);
                    }
                    sortActivatedRouteSnapshots(mergedChildren);
                    return mergedChildren;
                }));
            }
            processSegment(injector, routes2, segmentGroup, segments, outlet) {
                return from(routes2).pipe(concatMap(r => this.processSegmentAgainstRoute(r._injector ?? injector, r, segmentGroup, segments, outlet)), first(x => !!x), catchError_catchError(e => {
                    if (isEmptyError(e)) {
                        if (noLeftoversInUrl(segmentGroup, segments, outlet)) {
                            return of_of([]);
                        }
                        return of_of(null);
                    }
                    throw e;
                }));
            }
            processSegmentAgainstRoute(injector, route, rawSegment, segments, outlet) {
                if (route.redirectTo || !isImmediateMatch(route, rawSegment, segments, outlet)) {
                    return of_of(null);
                }
                let matchResult;
                if (route.path === "**") {
                    const params = segments.length > 0 ? router_last(segments).parameters : {};
                    const pathIndexShift = getPathIndexShift(rawSegment) + segments.length;
                    const snapshot = new ActivatedRouteSnapshot(segments, params, Object.freeze({
                        ...this.urlTree.queryParams
                    }), this.urlTree.fragment, getData(route), getOutlet(route), route.component ?? route._loadedComponent ?? null, route, getSourceSegmentGroup(rawSegment), pathIndexShift, getResolve(route), NG_DEV_MODE$5 ? getCorrectedPathIndexShift(rawSegment) + segments.length : pathIndexShift);
                    matchResult = of_of({
                        snapshot,
                        consumedSegments: [],
                        remainingSegments: []
                    });
                } else {
                    matchResult = matchWithChecks(rawSegment, route, segments, injector, this.urlSerializer).pipe(map(({matched, consumedSegments, remainingSegments, parameters}) => {
                        if (!matched) {
                            return null;
                        }
                        const pathIndexShift = getPathIndexShift(rawSegment) + consumedSegments.length;
                        const snapshot = new ActivatedRouteSnapshot(consumedSegments, parameters, Object.freeze({
                            ...this.urlTree.queryParams
                        }), this.urlTree.fragment, getData(route), getOutlet(route), route.component ?? route._loadedComponent ?? null, route, getSourceSegmentGroup(rawSegment), pathIndexShift, getResolve(route), NG_DEV_MODE$5 ? getCorrectedPathIndexShift(rawSegment) + consumedSegments.length : pathIndexShift);
                        return {
                            snapshot,
                            consumedSegments,
                            remainingSegments
                        };
                    }));
                }
                return matchResult.pipe(switchMap(result => {
                    if (result === null) {
                        return of_of(null);
                    }
                    const {snapshot, consumedSegments, remainingSegments} = result;
                    injector = route._injector ?? injector;
                    const childInjector = route._loadedInjector ?? injector;
                    const childConfig = getChildConfig(route);
                    const {segmentGroup, slicedSegments} = split(rawSegment, consumedSegments, remainingSegments, childConfig.filter(c => c.redirectTo === void 0), this.relativeLinkResolution);
                    if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {
                        return this.processChildren(childInjector, childConfig, segmentGroup).pipe(map(children => {
                            if (children === null) {
                                return null;
                            }
                            return [ new TreeNode(snapshot, children) ];
                        }));
                    }
                    if (childConfig.length === 0 && slicedSegments.length === 0) {
                        return of_of([ new TreeNode(snapshot, []) ]);
                    }
                    const matchedOnOutlet = getOutlet(route) === outlet;
                    return this.processSegment(childInjector, childConfig, segmentGroup, slicedSegments, matchedOnOutlet ? PRIMARY_OUTLET : outlet).pipe(map(children => {
                        if (children === null) {
                            return null;
                        }
                        return [ new TreeNode(snapshot, children) ];
                    }));
                }));
            }
        }
        function sortActivatedRouteSnapshots(nodes) {
            nodes.sort((a, b) => {
                if (a.value.outlet === PRIMARY_OUTLET) {
                    return -1;
                }
                if (b.value.outlet === PRIMARY_OUTLET) {
                    return 1;
                }
                return a.value.outlet.localeCompare(b.value.outlet);
            });
        }
        function getChildConfig(route) {
            if (route.children) {
                return route.children;
            }
            if (route.loadChildren) {
                return route._loadedRoutes;
            }
            return [];
        }
        function hasEmptyPathConfig(node) {
            const config2 = node.value.routeConfig;
            return config2 && config2.path === "" && config2.redirectTo === void 0;
        }
        function mergeEmptyPathMatches(nodes) {
            const result = [];
            const mergedNodes = new Set;
            for (const node of nodes) {
                if (!hasEmptyPathConfig(node)) {
                    result.push(node);
                    continue;
                }
                const duplicateEmptyPathNode = result.find(resultNode => node.value.routeConfig === resultNode.value.routeConfig);
                if (duplicateEmptyPathNode !== void 0) {
                    duplicateEmptyPathNode.children.push(...node.children);
                    mergedNodes.add(duplicateEmptyPathNode);
                } else {
                    result.push(node);
                }
            }
            for (const mergedNode of mergedNodes) {
                const mergedChildren = mergeEmptyPathMatches(mergedNode.children);
                result.push(new TreeNode(mergedNode.value, mergedChildren));
            }
            return result.filter(n => !mergedNodes.has(n));
        }
        function checkOutletNameUniqueness(nodes) {
            const names = {};
            nodes.forEach(n => {
                const routeWithSameOutletName = names[n.value.outlet];
                if (routeWithSameOutletName) {
                    const p = routeWithSameOutletName.url.map(s => s.toString()).join("/");
                    const c = n.value.url.map(s => s.toString()).join("/");
                    throw new RuntimeError(4006, NG_DEV_MODE$5 && `Two segments cannot have the same outlet name: '${p}' and '${c}'.`);
                }
                names[n.value.outlet] = n.value;
            });
        }
        function getSourceSegmentGroup(segmentGroup) {
            let s = segmentGroup;
            while (s._sourceSegment) {
                s = s._sourceSegment;
            }
            return s;
        }
        function getPathIndexShift(segmentGroup) {
            let s = segmentGroup;
            let res = s._segmentIndexShift ?? 0;
            while (s._sourceSegment) {
                s = s._sourceSegment;
                res += s._segmentIndexShift ?? 0;
            }
            return res - 1;
        }
        function getCorrectedPathIndexShift(segmentGroup) {
            let s = segmentGroup;
            let res = s._segmentIndexShiftCorrected ?? s._segmentIndexShift ?? 0;
            while (s._sourceSegment) {
                s = s._sourceSegment;
                res += s._segmentIndexShiftCorrected ?? s._segmentIndexShift ?? 0;
            }
            return res - 1;
        }
        function getData(route) {
            return route.data || {};
        }
        function getResolve(route) {
            return route.resolve || {};
        }
        function recognize(injector, rootComponentType, config2, serializer, paramsInheritanceStrategy, relativeLinkResolution) {
            return mergeMap(t => recognize$1(injector, rootComponentType, config2, t.urlAfterRedirects, serializer.serialize(t.urlAfterRedirects), serializer, paramsInheritanceStrategy, relativeLinkResolution).pipe(map(targetSnapshot => ({
                ...t,
                targetSnapshot
            }))));
        }
        function resolveData(paramsInheritanceStrategy, injector) {
            return mergeMap(t => {
                const {targetSnapshot, guards: {canActivateChecks}} = t;
                if (!canActivateChecks.length) {
                    return of_of(t);
                }
                let canActivateChecksResolved = 0;
                return from(canActivateChecks).pipe(concatMap(check => runResolve(check.route, targetSnapshot, paramsInheritanceStrategy, injector)), tap(() => canActivateChecksResolved++), takeLast(1), mergeMap(_ => canActivateChecksResolved === canActivateChecks.length ? of_of(t) : EMPTY));
            });
        }
        function runResolve(futureARS, futureRSS, paramsInheritanceStrategy, injector) {
            const config2 = futureARS.routeConfig;
            const resolve = futureARS._resolve;
            if (config2?.title !== void 0 && !hasStaticTitle(config2)) {
                resolve[RouteTitleKey] = config2.title;
            }
            return resolveNode(resolve, futureARS, futureRSS, injector).pipe(map(resolvedData => {
                futureARS._resolvedData = resolvedData;
                futureARS.data = inheritedParamsDataResolve(futureARS, paramsInheritanceStrategy).resolve;
                if (config2 && hasStaticTitle(config2)) {
                    futureARS.data[RouteTitleKey] = config2.title;
                }
                return null;
            }));
        }
        function resolveNode(resolve, futureARS, futureRSS, injector) {
            const keys = getDataKeys(resolve);
            if (keys.length === 0) {
                return of_of({});
            }
            const data = {};
            return from(keys).pipe(mergeMap(key => getResolver(resolve[key], futureARS, futureRSS, injector).pipe(first(), tap(value => {
                data[key] = value;
            }))), takeLast(1), mapTo(data), catchError_catchError(e => isEmptyError(e) ? EMPTY : throwError_throwError(e)));
        }
        function getDataKeys(obj) {
            return [ ...Object.keys(obj), ...Object.getOwnPropertySymbols(obj) ];
        }
        function getResolver(injectionToken, futureARS, futureRSS, injector) {
            const closestInjector = getClosestRouteInjector(futureARS) ?? injector;
            const resolver = getTokenOrFunctionIdentity(injectionToken, closestInjector);
            const resolverValue = resolver.resolve ? resolver.resolve(futureARS, futureRSS) : closestInjector.runInContext(() => resolver(futureARS, futureRSS));
            return wrapIntoObservable(resolverValue);
        }
        function hasStaticTitle(config2) {
            return typeof config2.title === "string" || config2.title === null;
        }
        function switchTap(next) {
            return switchMap(v => {
                const nextResult = next(v);
                if (nextResult) {
                    return from(nextResult).pipe(map(() => v));
                }
                return of_of(v);
            });
        }
        let TitleStrategy = (() => {
            class TitleStrategy2 {
                buildTitle(snapshot) {
                    let pageTitle;
                    let route = snapshot.root;
                    while (route !== void 0) {
                        pageTitle = this.getResolvedTitleForRoute(route) ?? pageTitle;
                        route = route.children.find(child => child.outlet === PRIMARY_OUTLET);
                    }
                    return pageTitle;
                }
                getResolvedTitleForRoute(snapshot) {
                    return snapshot.data[RouteTitleKey];
                }
            }
            TitleStrategy2.fac = function TitleStrategy_Factory(t) {
                return new (t || TitleStrategy2);
            };
            TitleStrategy2.prov = defineInjectable({
                token: TitleStrategy2,
                factory: function() {
                    return (() => fesm2020_core_inject(DefaultTitleStrategy))();
                },
                providedIn: "root"
            });
            return TitleStrategy2;
        })();
        (function() {})();
        let DefaultTitleStrategy = (() => {
            class DefaultTitleStrategy2 extends TitleStrategy {
                constructor(title) {
                    super();
                    this.title = title;
                }
                updateTitle(snapshot) {
                    const title = this.buildTitle(snapshot);
                    if (title !== void 0) {
                        this.title.setTitle(title);
                    }
                }
            }
            DefaultTitleStrategy2.fac = function DefaultTitleStrategy_Factory(t) {
                return new (t || DefaultTitleStrategy2)(core_inject(Title));
            };
            DefaultTitleStrategy2.prov = defineInjectable({
                token: DefaultTitleStrategy2,
                factory: DefaultTitleStrategy2.fac,
                providedIn: "root"
            });
            return DefaultTitleStrategy2;
        })();
        (function() {})();
        function assignRelativeLinkResolution(router) {}
        class RouteReuseStrategy {}
        class BaseRouteReuseStrategy {
            shouldDetach(route) {
                return false;
            }
            store(route, detachedTree) {}
            shouldAttach(route) {
                return false;
            }
            retrieve(route) {
                return null;
            }
            shouldReuseRoute(future, curr) {
                return future.routeConfig === curr.routeConfig;
            }
        }
        class DefaultRouteReuseStrategy extends BaseRouteReuseStrategy {}
        const NG_DEV_MODE$4 = false;
        const ROUTER_CONFIGURATION = new InjectionToken(NG_DEV_MODE$4 ? "router config" : "", {
            providedIn: "root",
            factory: () => ({})
        });
        const NG_DEV_MODE$3 = false;
        const ROUTES = new InjectionToken("ROUTES");
        let RouterConfigLoader = (() => {
            class RouterConfigLoader2 {
                constructor(injector, compiler) {
                    this.injector = injector;
                    this.compiler = compiler;
                    this.componentLoaders = new WeakMap;
                    this.childrenLoaders = new WeakMap;
                }
                loadComponent(route) {
                    if (this.componentLoaders.get(route)) {
                        return this.componentLoaders.get(route);
                    } else if (route._loadedComponent) {
                        return of_of(route._loadedComponent);
                    }
                    if (this.onLoadStartListener) {
                        this.onLoadStartListener(route);
                    }
                    const loadRunner = wrapIntoObservable(route.loadComponent()).pipe(tap(component => {
                        if (this.onLoadEndListener) {
                            this.onLoadEndListener(route);
                        }
                        NG_DEV_MODE$3 && assertStandalone(route.path ?? "", component);
                        route._loadedComponent = component;
                    }), finalize(() => {
                        this.componentLoaders.delete(route);
                    }));
                    const loader = new ConnectableObservable(loadRunner, () => new Subject).pipe(refCount());
                    this.componentLoaders.set(route, loader);
                    return loader;
                }
                loadChildren(parentInjector, route) {
                    if (this.childrenLoaders.get(route)) {
                        return this.childrenLoaders.get(route);
                    } else if (route._loadedRoutes) {
                        return of_of({
                            routes: route._loadedRoutes,
                            injector: route._loadedInjector
                        });
                    }
                    if (this.onLoadStartListener) {
                        this.onLoadStartListener(route);
                    }
                    const moduleFactoryOrRoutes$ = this.loadModuleFactoryOrRoutes(route.loadChildren);
                    const loadRunner = moduleFactoryOrRoutes$.pipe(map(factoryOrRoutes => {
                        if (this.onLoadEndListener) {
                            this.onLoadEndListener(route);
                        }
                        let injector;
                        let rawRoutes;
                        let requireStandaloneComponents = false;
                        if (Array.isArray(factoryOrRoutes)) {
                            rawRoutes = factoryOrRoutes;
                            requireStandaloneComponents = true;
                        } else {
                            injector = factoryOrRoutes.create(parentInjector).injector;
                            rawRoutes = router_flatten(injector.get(ROUTES, [], InjectFlags.Self | InjectFlags.Optional));
                        }
                        const routes2 = rawRoutes.map(standardizeConfig);
                        NG_DEV_MODE$3 && validateConfig(routes2, route.path, requireStandaloneComponents);
                        return {
                            routes: routes2,
                            injector
                        };
                    }), finalize(() => {
                        this.childrenLoaders.delete(route);
                    }));
                    const loader = new ConnectableObservable(loadRunner, () => new Subject).pipe(refCount());
                    this.childrenLoaders.set(route, loader);
                    return loader;
                }
                loadModuleFactoryOrRoutes(loadChildren) {
                    return wrapIntoObservable(loadChildren()).pipe(mergeMap(t => {
                        if (t instanceof NgModuleFactory$1 || Array.isArray(t)) {
                            return of_of(t);
                        } else {
                            return from(this.compiler.compileModuleAsync(t));
                        }
                    }));
                }
            }
            RouterConfigLoader2.fac = function RouterConfigLoader_Factory(t) {
                return new (t || RouterConfigLoader2)(core_inject(core_Injector), core_inject(Compiler));
            };
            RouterConfigLoader2.prov = defineInjectable({
                token: RouterConfigLoader2,
                factory: RouterConfigLoader2.fac,
                providedIn: "root"
            });
            return RouterConfigLoader2;
        })();
        (function() {})();
        class UrlHandlingStrategy {}
        class DefaultUrlHandlingStrategy {
            shouldProcessUrl(url) {
                return true;
            }
            extract(url) {
                return url;
            }
            merge(newUrlPart, wholeUrl) {
                return newUrlPart;
            }
        }
        const NG_DEV_MODE$2 = false;
        function router_defaultErrorHandler(error) {
            throw error;
        }
        function defaultMalformedUriErrorHandler(error, urlSerializer, url) {
            return urlSerializer.parse("/");
        }
        const exactMatchOptions = {
            paths: "exact",
            fragment: "ignored",
            matrixParams: "ignored",
            queryParams: "exact"
        };
        const subsetMatchOptions = {
            paths: "subset",
            fragment: "ignored",
            matrixParams: "ignored",
            queryParams: "subset"
        };
        function assignExtraOptionsToRouter(opts, router) {
            if (opts.errorHandler) {
                router.errorHandler = opts.errorHandler;
            }
            if (opts.malformedUriErrorHandler) {
                router.malformedUriErrorHandler = opts.malformedUriErrorHandler;
            }
            if (opts.onSameUrlNavigation) {
                router.onSameUrlNavigation = opts.onSameUrlNavigation;
            }
            if (opts.paramsInheritanceStrategy) {
                router.paramsInheritanceStrategy = opts.paramsInheritanceStrategy;
            }
            if (opts.relativeLinkResolution) {
                router.relativeLinkResolution = opts.relativeLinkResolution;
            }
            if (opts.urlUpdateStrategy) {
                router.urlUpdateStrategy = opts.urlUpdateStrategy;
            }
            if (opts.canceledNavigationResolution) {
                router.canceledNavigationResolution = opts.canceledNavigationResolution;
            }
        }
        function setupRouter() {
            const urlSerializer = fesm2020_core_inject(UrlSerializer);
            const contexts = fesm2020_core_inject(ChildrenOutletContexts);
            const location2 = fesm2020_core_inject(Location);
            const injector = fesm2020_core_inject(core_Injector);
            const compiler = fesm2020_core_inject(Compiler);
            const config2 = fesm2020_core_inject(ROUTES, {
                optional: true
            }) ?? [];
            const opts = fesm2020_core_inject(ROUTER_CONFIGURATION, {
                optional: true
            }) ?? {};
            const defaultTitleStrategy = fesm2020_core_inject(DefaultTitleStrategy);
            const titleStrategy = fesm2020_core_inject(TitleStrategy, {
                optional: true
            });
            const urlHandlingStrategy = fesm2020_core_inject(UrlHandlingStrategy, {
                optional: true
            });
            const routeReuseStrategy = fesm2020_core_inject(RouteReuseStrategy, {
                optional: true
            });
            const router = new Router(null, urlSerializer, contexts, location2, injector, compiler, router_flatten(config2));
            if (urlHandlingStrategy) {
                router.urlHandlingStrategy = urlHandlingStrategy;
            }
            if (routeReuseStrategy) {
                router.routeReuseStrategy = routeReuseStrategy;
            }
            router.titleStrategy = titleStrategy ?? defaultTitleStrategy;
            assignExtraOptionsToRouter(opts, router);
            assignRelativeLinkResolution(router);
            return router;
        }
        let Router = (() => {
            class Router2 {
                constructor(rootComponentType, urlSerializer, rootContexts, location2, injector, compiler, config2) {
                    this.rootComponentType = rootComponentType;
                    this.urlSerializer = urlSerializer;
                    this.rootContexts = rootContexts;
                    this.location = location2;
                    this.config = config2;
                    this.lastSuccessfulNavigation = null;
                    this.currentNavigation = null;
                    this.disposed = false;
                    this.navigationId = 0;
                    this.currentPageId = 0;
                    this.isNgZoneEnabled = false;
                    this.events = new Subject;
                    this.errorHandler = router_defaultErrorHandler;
                    this.malformedUriErrorHandler = defaultMalformedUriErrorHandler;
                    this.navigated = false;
                    this.lastSuccessfulId = -1;
                    this.afterPreactivation = () => of_of(void 0);
                    this.urlHandlingStrategy = new DefaultUrlHandlingStrategy;
                    this.routeReuseStrategy = new DefaultRouteReuseStrategy;
                    this.onSameUrlNavigation = "ignore";
                    this.paramsInheritanceStrategy = "emptyOnly";
                    this.urlUpdateStrategy = "deferred";
                    this.relativeLinkResolution = "corrected";
                    this.canceledNavigationResolution = "replace";
                    const onLoadStart = r => this.triggerEvent(new RouteConfigLoadStart(r));
                    const onLoadEnd = r => this.triggerEvent(new RouteConfigLoadEnd(r));
                    this.configLoader = injector.get(RouterConfigLoader);
                    this.configLoader.onLoadEndListener = onLoadEnd;
                    this.configLoader.onLoadStartListener = onLoadStart;
                    this.ngModule = injector.get(NgModuleRef$1);
                    this.console = injector.get(Console);
                    const ngZone = injector.get(core_NgZone);
                    this.isNgZoneEnabled = ngZone instanceof core_NgZone && core_NgZone.isInAngularZone();
                    this.resetConfig(config2);
                    this.currentUrlTree = createEmptyUrlTree();
                    this.rawUrlTree = this.currentUrlTree;
                    this.browserUrlTree = this.currentUrlTree;
                    this.routerState = createEmptyState(this.currentUrlTree, this.rootComponentType);
                    this.transitions = new BehaviorSubject({
                        id: 0,
                        targetPageId: 0,
                        currentUrlTree: this.currentUrlTree,
                        currentRawUrl: this.currentUrlTree,
                        extractedUrl: this.urlHandlingStrategy.extract(this.currentUrlTree),
                        urlAfterRedirects: this.urlHandlingStrategy.extract(this.currentUrlTree),
                        rawUrl: this.currentUrlTree,
                        extras: {},
                        resolve: null,
                        reject: null,
                        promise: Promise.resolve(true),
                        source: "imperative",
                        restoredState: null,
                        currentSnapshot: this.routerState.snapshot,
                        targetSnapshot: null,
                        currentRouterState: this.routerState,
                        targetRouterState: null,
                        guards: {
                            canActivateChecks: [],
                            canDeactivateChecks: []
                        },
                        guardsResult: null
                    });
                    this.navigations = this.setupNavigations(this.transitions);
                    this.processNavigations();
                }
                get browserPageId() {
                    return this.location.getState()?.routerPageId;
                }
                setupNavigations(transitions) {
                    const eventsSubject = this.events;
                    return transitions.pipe(filter(t => t.id !== 0), map(t => ({
                        ...t,
                        extractedUrl: this.urlHandlingStrategy.extract(t.rawUrl)
                    })), switchMap(overallTransitionState => {
                        let completed = false;
                        let errored = false;
                        return of_of(overallTransitionState).pipe(tap(t => {
                            this.currentNavigation = {
                                id: t.id,
                                initialUrl: t.rawUrl,
                                extractedUrl: t.extractedUrl,
                                trigger: t.source,
                                extras: t.extras,
                                previousNavigation: this.lastSuccessfulNavigation ? {
                                    ...this.lastSuccessfulNavigation,
                                    previousNavigation: null
                                } : null
                            };
                        }), switchMap(t => {
                            const browserUrlTree = this.browserUrlTree.toString();
                            const urlTransition = !this.navigated || t.extractedUrl.toString() !== browserUrlTree || browserUrlTree !== this.currentUrlTree.toString();
                            const processCurrentUrl = (this.onSameUrlNavigation === "reload" ? true : urlTransition) && this.urlHandlingStrategy.shouldProcessUrl(t.rawUrl);
                            if (processCurrentUrl) {
                                if (isBrowserTriggeredNavigation(t.source)) {
                                    this.browserUrlTree = t.extractedUrl;
                                }
                                return of_of(t).pipe(switchMap(t2 => {
                                    const transition = this.transitions.getValue();
                                    eventsSubject.next(new NavigationStart(t2.id, this.serializeUrl(t2.extractedUrl), t2.source, t2.restoredState));
                                    if (transition !== this.transitions.getValue()) {
                                        return EMPTY;
                                    }
                                    return Promise.resolve(t2);
                                }), applyRedirects(this.ngModule.injector, this.configLoader, this.urlSerializer, this.config), tap(t2 => {
                                    this.currentNavigation = {
                                        ...this.currentNavigation,
                                        finalUrl: t2.urlAfterRedirects
                                    };
                                    overallTransitionState.urlAfterRedirects = t2.urlAfterRedirects;
                                }), recognize(this.ngModule.injector, this.rootComponentType, this.config, this.urlSerializer, this.paramsInheritanceStrategy, this.relativeLinkResolution), tap(t2 => {
                                    overallTransitionState.targetSnapshot = t2.targetSnapshot;
                                    if (this.urlUpdateStrategy === "eager") {
                                        if (!t2.extras.skipLocationChange) {
                                            const rawUrl = this.urlHandlingStrategy.merge(t2.urlAfterRedirects, t2.rawUrl);
                                            this.setBrowserUrl(rawUrl, t2);
                                        }
                                        this.browserUrlTree = t2.urlAfterRedirects;
                                    }
                                    const routesRecognized = new RoutesRecognized(t2.id, this.serializeUrl(t2.extractedUrl), this.serializeUrl(t2.urlAfterRedirects), t2.targetSnapshot);
                                    eventsSubject.next(routesRecognized);
                                }));
                            } else {
                                const processPreviousUrl = urlTransition && this.rawUrlTree && this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree);
                                if (processPreviousUrl) {
                                    const {id, extractedUrl, source, restoredState, extras} = t;
                                    const navStart = new NavigationStart(id, this.serializeUrl(extractedUrl), source, restoredState);
                                    eventsSubject.next(navStart);
                                    const targetSnapshot = createEmptyState(extractedUrl, this.rootComponentType).snapshot;
                                    overallTransitionState = {
                                        ...t,
                                        targetSnapshot,
                                        urlAfterRedirects: extractedUrl,
                                        extras: {
                                            ...extras,
                                            skipLocationChange: false,
                                            replaceUrl: false
                                        }
                                    };
                                    return of_of(overallTransitionState);
                                } else {
                                    this.rawUrlTree = t.rawUrl;
                                    t.resolve(null);
                                    return EMPTY;
                                }
                            }
                        }), tap(t => {
                            const guardsStart = new GuardsCheckStart(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot);
                            this.triggerEvent(guardsStart);
                        }), map(t => {
                            overallTransitionState = {
                                ...t,
                                guards: getAllRouteGuards(t.targetSnapshot, t.currentSnapshot, this.rootContexts)
                            };
                            return overallTransitionState;
                        }), checkGuards(this.ngModule.injector, evt => this.triggerEvent(evt)), tap(t => {
                            overallTransitionState.guardsResult = t.guardsResult;
                            if (isUrlTree(t.guardsResult)) {
                                throw redirectingNavigationError(this.urlSerializer, t.guardsResult);
                            }
                            const guardsEnd = new GuardsCheckEnd(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot, !!t.guardsResult);
                            this.triggerEvent(guardsEnd);
                        }), filter(t => {
                            if (!t.guardsResult) {
                                this.restoreHistory(t);
                                this.cancelNavigationTransition(t, "", 3);
                                return false;
                            }
                            return true;
                        }), switchTap(t => {
                            if (t.guards.canActivateChecks.length) {
                                return of_of(t).pipe(tap(t2 => {
                                    const resolveStart = new ResolveStart(t2.id, this.serializeUrl(t2.extractedUrl), this.serializeUrl(t2.urlAfterRedirects), t2.targetSnapshot);
                                    this.triggerEvent(resolveStart);
                                }), switchMap(t2 => {
                                    let dataResolved = false;
                                    return of_of(t2).pipe(resolveData(this.paramsInheritanceStrategy, this.ngModule.injector), tap({
                                        next: () => dataResolved = true,
                                        complete: () => {
                                            if (!dataResolved) {
                                                this.restoreHistory(t2);
                                                this.cancelNavigationTransition(t2, NG_DEV_MODE$2 ? `At least one route resolver didn't emit any value.` : "", 2);
                                            }
                                        }
                                    }));
                                }), tap(t2 => {
                                    const resolveEnd = new ResolveEnd(t2.id, this.serializeUrl(t2.extractedUrl), this.serializeUrl(t2.urlAfterRedirects), t2.targetSnapshot);
                                    this.triggerEvent(resolveEnd);
                                }));
                            }
                            return void 0;
                        }), switchTap(t => {
                            const loadComponents = route => {
                                const loaders = [];
                                if (route.routeConfig?.loadComponent && !route.routeConfig._loadedComponent) {
                                    loaders.push(this.configLoader.loadComponent(route.routeConfig).pipe(tap(loadedComponent => {
                                        route.component = loadedComponent;
                                    }), map(() => void 0)));
                                }
                                for (const child of route.children) {
                                    loaders.push(...loadComponents(child));
                                }
                                return loaders;
                            };
                            return combineLatest(loadComponents(t.targetSnapshot.root)).pipe(defaultIfEmpty(), take(1));
                        }), switchTap(() => this.afterPreactivation()), map(t => {
                            const targetRouterState = createRouterState(this.routeReuseStrategy, t.targetSnapshot, t.currentRouterState);
                            overallTransitionState = {
                                ...t,
                                targetRouterState
                            };
                            return overallTransitionState;
                        }), tap(t => {
                            this.currentUrlTree = t.urlAfterRedirects;
                            this.rawUrlTree = this.urlHandlingStrategy.merge(t.urlAfterRedirects, t.rawUrl);
                            this.routerState = t.targetRouterState;
                            if (this.urlUpdateStrategy === "deferred") {
                                if (!t.extras.skipLocationChange) {
                                    this.setBrowserUrl(this.rawUrlTree, t);
                                }
                                this.browserUrlTree = t.urlAfterRedirects;
                            }
                        }), activateRoutes(this.rootContexts, this.routeReuseStrategy, evt => this.triggerEvent(evt)), tap({
                            next() {
                                completed = true;
                            },
                            complete() {
                                completed = true;
                            }
                        }), finalize(() => {
                            if (!completed && !errored) {
                                const cancelationReason = NG_DEV_MODE$2 ? `Navigation ID ${overallTransitionState.id} is not equal to the current navigation id ${this.navigationId}` : "";
                                this.cancelNavigationTransition(overallTransitionState, cancelationReason, 1);
                            }
                            if (this.currentNavigation?.id === overallTransitionState.id) {
                                this.currentNavigation = null;
                            }
                        }), catchError_catchError(e => {
                            errored = true;
                            if (isNavigationCancelingError$1(e)) {
                                if (!isRedirectingNavigationCancelingError$1(e)) {
                                    this.navigated = true;
                                    this.restoreHistory(overallTransitionState, true);
                                }
                                const navCancel = new NavigationCancel(overallTransitionState.id, this.serializeUrl(overallTransitionState.extractedUrl), e.message, e.cancellationCode);
                                eventsSubject.next(navCancel);
                                if (!isRedirectingNavigationCancelingError$1(e)) {
                                    overallTransitionState.resolve(false);
                                } else {
                                    const mergedTree = this.urlHandlingStrategy.merge(e.url, this.rawUrlTree);
                                    const extras = {
                                        skipLocationChange: overallTransitionState.extras.skipLocationChange,
                                        replaceUrl: this.urlUpdateStrategy === "eager" || isBrowserTriggeredNavigation(overallTransitionState.source)
                                    };
                                    this.scheduleNavigation(mergedTree, "imperative", null, extras, {
                                        resolve: overallTransitionState.resolve,
                                        reject: overallTransitionState.reject,
                                        promise: overallTransitionState.promise
                                    });
                                }
                            } else {
                                this.restoreHistory(overallTransitionState, true);
                                const navError = new NavigationError(overallTransitionState.id, this.serializeUrl(overallTransitionState.extractedUrl), e, overallTransitionState.targetSnapshot ?? void 0);
                                eventsSubject.next(navError);
                                try {
                                    overallTransitionState.resolve(this.errorHandler(e));
                                } catch (ee) {
                                    overallTransitionState.reject(ee);
                                }
                            }
                            return EMPTY;
                        }));
                    }));
                }
                resetRootComponentType(rootComponentType) {
                    this.rootComponentType = rootComponentType;
                    this.routerState.root.component = this.rootComponentType;
                }
                setTransition(t) {
                    this.transitions.next({
                        ...this.transitions.value,
                        ...t
                    });
                }
                initialNavigation() {
                    this.setUpLocationChangeListener();
                    if (this.navigationId === 0) {
                        this.navigateByUrl(this.location.path(true), {
                            replaceUrl: true
                        });
                    }
                }
                setUpLocationChangeListener() {
                    if (!this.locationSubscription) {
                        this.locationSubscription = this.location.subscribe(event => {
                            const source = event["type"] === "popstate" ? "popstate" : "hashchange";
                            if (source === "popstate") {
                                setTimeout(() => {
                                    const extras = {
                                        replaceUrl: true
                                    };
                                    const state = event.state?.navigationId ? event.state : null;
                                    if (state) {
                                        const stateCopy = {
                                            ...state
                                        };
                                        delete stateCopy.navigationId;
                                        delete stateCopy.routerPageId;
                                        if (Object.keys(stateCopy).length !== 0) {
                                            extras.state = stateCopy;
                                        }
                                    }
                                    const urlTree = this.parseUrl(event["url"]);
                                    this.scheduleNavigation(urlTree, source, state, extras);
                                }, 0);
                            }
                        });
                    }
                }
                get url() {
                    return this.serializeUrl(this.currentUrlTree);
                }
                getCurrentNavigation() {
                    return this.currentNavigation;
                }
                triggerEvent(event) {
                    this.events.next(event);
                }
                resetConfig(config2) {
                    NG_DEV_MODE$2 && validateConfig(config2);
                    this.config = config2.map(standardizeConfig);
                    this.navigated = false;
                    this.lastSuccessfulId = -1;
                }
                ngOnDestroy() {
                    this.dispose();
                }
                dispose() {
                    this.transitions.complete();
                    if (this.locationSubscription) {
                        this.locationSubscription.unsubscribe();
                        this.locationSubscription = void 0;
                    }
                    this.disposed = true;
                }
                createUrlTree(commands, navigationExtras = {}) {
                    const {relativeTo, queryParams, fragment, queryParamsHandling, preserveFragment} = navigationExtras;
                    const a = relativeTo || this.routerState.root;
                    const f = preserveFragment ? this.currentUrlTree.fragment : fragment;
                    let q = null;
                    switch (queryParamsHandling) {
                      case "merge":
                        q = {
                            ...this.currentUrlTree.queryParams,
                            ...queryParams
                        };
                        break;

                      case "preserve":
                        q = this.currentUrlTree.queryParams;
                        break;

                      default:
                        q = queryParams || null;
                    }
                    if (q !== null) {
                        q = this.removeEmptyProps(q);
                    }
                    return createUrlTree(a, this.currentUrlTree, commands, q, f ?? null);
                }
                navigateByUrl(url, extras = {
                    skipLocationChange: false
                }) {
                    if (false) {
                        this.console.warn(`Navigation triggered outside Angular zone, did you forget to call 'ngZone.run()'?`);
                    }
                    const urlTree = isUrlTree(url) ? url : this.parseUrl(url);
                    const mergedTree = this.urlHandlingStrategy.merge(urlTree, this.rawUrlTree);
                    return this.scheduleNavigation(mergedTree, "imperative", null, extras);
                }
                navigate(commands, extras = {
                    skipLocationChange: false
                }) {
                    validateCommands(commands);
                    return this.navigateByUrl(this.createUrlTree(commands, extras), extras);
                }
                serializeUrl(url) {
                    return this.urlSerializer.serialize(url);
                }
                parseUrl(url) {
                    let urlTree;
                    try {
                        urlTree = this.urlSerializer.parse(url);
                    } catch (e) {
                        urlTree = this.malformedUriErrorHandler(e, this.urlSerializer, url);
                    }
                    return urlTree;
                }
                isActive(url, matchOptions) {
                    let options;
                    if (matchOptions === true) {
                        options = {
                            ...exactMatchOptions
                        };
                    } else if (matchOptions === false) {
                        options = {
                            ...subsetMatchOptions
                        };
                    } else {
                        options = matchOptions;
                    }
                    if (isUrlTree(url)) {
                        return containsTree(this.currentUrlTree, url, options);
                    }
                    const urlTree = this.parseUrl(url);
                    return containsTree(this.currentUrlTree, urlTree, options);
                }
                removeEmptyProps(params) {
                    return Object.keys(params).reduce((result, key) => {
                        const value = params[key];
                        if (value !== null && value !== void 0) {
                            result[key] = value;
                        }
                        return result;
                    }, {});
                }
                processNavigations() {
                    this.navigations.subscribe(t => {
                        this.navigated = true;
                        this.lastSuccessfulId = t.id;
                        this.currentPageId = t.targetPageId;
                        this.events.next(new NavigationEnd(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(this.currentUrlTree)));
                        this.lastSuccessfulNavigation = this.currentNavigation;
                        this.titleStrategy?.updateTitle(this.routerState.snapshot);
                        t.resolve(true);
                    }, e => {
                        this.console.warn(`Unhandled Navigation Error: ${e}`);
                    });
                }
                scheduleNavigation(rawUrl, source, restoredState, extras, priorPromise) {
                    if (this.disposed) {
                        return Promise.resolve(false);
                    }
                    let resolve;
                    let reject;
                    let promise2;
                    if (priorPromise) {
                        resolve = priorPromise.resolve;
                        reject = priorPromise.reject;
                        promise2 = priorPromise.promise;
                    } else {
                        promise2 = new Promise((res, rej) => {
                            resolve = res;
                            reject = rej;
                        });
                    }
                    const id = ++this.navigationId;
                    let targetPageId;
                    if (this.canceledNavigationResolution === "computed") {
                        const isInitialPage = this.currentPageId === 0;
                        if (isInitialPage) {
                            restoredState = this.location.getState();
                        }
                        if (restoredState && restoredState.routerPageId) {
                            targetPageId = restoredState.routerPageId;
                        } else {
                            if (extras.replaceUrl || extras.skipLocationChange) {
                                targetPageId = this.browserPageId ?? 0;
                            } else {
                                targetPageId = (this.browserPageId ?? 0) + 1;
                            }
                        }
                    } else {
                        targetPageId = 0;
                    }
                    this.setTransition({
                        id,
                        targetPageId,
                        source,
                        restoredState,
                        currentUrlTree: this.currentUrlTree,
                        currentRawUrl: this.rawUrlTree,
                        rawUrl,
                        extras,
                        resolve,
                        reject,
                        promise: promise2,
                        currentSnapshot: this.routerState.snapshot,
                        currentRouterState: this.routerState
                    });
                    return promise2.catch(e => Promise.reject(e));
                }
                setBrowserUrl(url, t) {
                    const path = this.urlSerializer.serialize(url);
                    const state = {
                        ...t.extras.state,
                        ...this.generateNgRouterState(t.id, t.targetPageId)
                    };
                    if (this.location.isCurrentPathEqualTo(path) || !!t.extras.replaceUrl) {
                        this.location.replaceState(path, "", state);
                    } else {
                        this.location.go(path, "", state);
                    }
                }
                restoreHistory(t, restoringFromCaughtError = false) {
                    if (this.canceledNavigationResolution === "computed") {
                        const targetPagePosition = this.currentPageId - t.targetPageId;
                        const browserUrlUpdateOccurred = t.source === "popstate" || this.urlUpdateStrategy === "eager" || this.currentUrlTree === this.currentNavigation?.finalUrl;
                        if (browserUrlUpdateOccurred && targetPagePosition !== 0) {
                            this.location.historyGo(targetPagePosition);
                        } else if (this.currentUrlTree === this.currentNavigation?.finalUrl && targetPagePosition === 0) {
                            this.resetState(t);
                            this.browserUrlTree = t.currentUrlTree;
                            this.resetUrlToCurrentUrlTree();
                        } else {}
                    } else if (this.canceledNavigationResolution === "replace") {
                        if (restoringFromCaughtError) {
                            this.resetState(t);
                        }
                        this.resetUrlToCurrentUrlTree();
                    }
                }
                resetState(t) {
                    this.routerState = t.currentRouterState;
                    this.currentUrlTree = t.currentUrlTree;
                    this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, t.rawUrl);
                }
                resetUrlToCurrentUrlTree() {
                    this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), "", this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId));
                }
                cancelNavigationTransition(t, reason, code) {
                    const navCancel = new NavigationCancel(t.id, this.serializeUrl(t.extractedUrl), reason, code);
                    this.triggerEvent(navCancel);
                    t.resolve(false);
                }
                generateNgRouterState(navigationId, routerPageId) {
                    if (this.canceledNavigationResolution === "computed") {
                        return {
                            navigationId,
                            routerPageId: routerPageId
                        };
                    }
                    return {
                        navigationId
                    };
                }
            }
            Router2.fac = function Router_Factory(t) {
                invalidFactory();
            };
            Router2.prov = defineInjectable({
                token: Router2,
                factory: function() {
                    return setupRouter();
                },
                providedIn: "root"
            });
            return Router2;
        })();
        (function() {})();
        function validateCommands(commands) {
            for (let i = 0; i < commands.length; i++) {
                const cmd = commands[i];
                if (cmd == null) {
                    throw new RuntimeError(4008, NG_DEV_MODE$2 && `The requested path contains ${cmd} segment at index ${i}`);
                }
            }
        }
        function isBrowserTriggeredNavigation(source) {
            return source !== "imperative";
        }
        let RouterLink = (() => {
            class RouterLink2 {
                constructor(router, route, tabIndexAttribute, renderer, el) {
                    this.router = router;
                    this.route = route;
                    this.tabIndexAttribute = tabIndexAttribute;
                    this.renderer = renderer;
                    this.el = el;
                    this._preserveFragment = false;
                    this._skipLocationChange = false;
                    this._replaceUrl = false;
                    this.commands = null;
                    this.onChanges = new Subject;
                    this.setTabIndexIfNotOnNativeEl("0");
                }
                set preserveFragment(preserveFragment) {
                    this._preserveFragment = coerceToBoolean(preserveFragment);
                }
                get preserveFragment() {
                    return this._preserveFragment;
                }
                set skipLocationChange(skipLocationChange) {
                    this._skipLocationChange = coerceToBoolean(skipLocationChange);
                }
                get skipLocationChange() {
                    return this._skipLocationChange;
                }
                set replaceUrl(replaceUrl) {
                    this._replaceUrl = coerceToBoolean(replaceUrl);
                }
                get replaceUrl() {
                    return this._replaceUrl;
                }
                setTabIndexIfNotOnNativeEl(newTabIndex) {
                    if (this.tabIndexAttribute != null) {
                        return;
                    }
                    const renderer = this.renderer;
                    const nativeElement = this.el.nativeElement;
                    if (newTabIndex !== null) {
                        renderer.setAttribute(nativeElement, "tabindex", newTabIndex);
                    } else {
                        renderer.removeAttribute(nativeElement, "tabindex");
                    }
                }
                ngOnChanges(changes) {
                    this.onChanges.next(this);
                }
                set routerLink(commands) {
                    if (commands != null) {
                        this.commands = Array.isArray(commands) ? commands : [ commands ];
                        this.setTabIndexIfNotOnNativeEl("0");
                    } else {
                        this.commands = null;
                        this.setTabIndexIfNotOnNativeEl(null);
                    }
                }
                onClick() {
                    if (this.urlTree === null) {
                        return true;
                    }
                    const extras = {
                        skipLocationChange: this.skipLocationChange,
                        replaceUrl: this.replaceUrl,
                        state: this.state
                    };
                    this.router.navigateByUrl(this.urlTree, extras);
                    return true;
                }
                get urlTree() {
                    if (this.commands === null) {
                        return null;
                    }
                    return this.router.createUrlTree(this.commands, {
                        relativeTo: this.relativeTo !== void 0 ? this.relativeTo : this.route,
                        queryParams: this.queryParams,
                        fragment: this.fragment,
                        queryParamsHandling: this.queryParamsHandling,
                        preserveFragment: this.preserveFragment
                    });
                }
            }
            RouterLink2.fac = function RouterLink_Factory(t) {
                return new (t || RouterLink2)(directiveInject(Router), directiveInject(ActivatedRoute), injectAttribute("tabindex"), directiveInject(core_Renderer2), directiveInject(core_ElementRef));
            };
            RouterLink2.dir = defineDirective({
                type: RouterLink2,
                selectors: [ [ "", "routerLink", "", 5, "a", 5, "area" ] ],
                hostBindings: function RouterLink_HostBindings(rf, ctx) {
                    if (rf & 1) {
                        listener("click", function RouterLink_click_HostBindingHandler() {
                            return ctx.onClick();
                        });
                    }
                },
                inputs: {
                    queryParams: "queryParams",
                    fragment: "fragment",
                    queryParamsHandling: "queryParamsHandling",
                    state: "state",
                    relativeTo: "relativeTo",
                    preserveFragment: "preserveFragment",
                    skipLocationChange: "skipLocationChange",
                    replaceUrl: "replaceUrl",
                    routerLink: "routerLink"
                },
                standalone: true,
                features: [ NgOnChangesFeature ]
            });
            return RouterLink2;
        })();
        (function() {})();
        let RouterLinkWithHref = (() => {
            class RouterLinkWithHref2 {
                constructor(router, route, locationStrategy) {
                    this.router = router;
                    this.route = route;
                    this.locationStrategy = locationStrategy;
                    this._preserveFragment = false;
                    this._skipLocationChange = false;
                    this._replaceUrl = false;
                    this.commands = null;
                    this.href = null;
                    this.onChanges = new Subject;
                    this.subscription = router.events.subscribe(s => {
                        if (s instanceof NavigationEnd) {
                            this.updateTargetUrlAndHref();
                        }
                    });
                }
                set preserveFragment(preserveFragment) {
                    this._preserveFragment = coerceToBoolean(preserveFragment);
                }
                get preserveFragment() {
                    return this._preserveFragment;
                }
                set skipLocationChange(skipLocationChange) {
                    this._skipLocationChange = coerceToBoolean(skipLocationChange);
                }
                get skipLocationChange() {
                    return this._skipLocationChange;
                }
                set replaceUrl(replaceUrl) {
                    this._replaceUrl = coerceToBoolean(replaceUrl);
                }
                get replaceUrl() {
                    return this._replaceUrl;
                }
                set routerLink(commands) {
                    if (commands != null) {
                        this.commands = Array.isArray(commands) ? commands : [ commands ];
                    } else {
                        this.commands = null;
                    }
                }
                ngOnChanges(changes) {
                    this.updateTargetUrlAndHref();
                    this.onChanges.next(this);
                }
                ngOnDestroy() {
                    this.subscription.unsubscribe();
                }
                onClick(button, ctrlKey, shiftKey, altKey, metaKey) {
                    if (button !== 0 || ctrlKey || shiftKey || altKey || metaKey) {
                        return true;
                    }
                    if (typeof this.target === "string" && this.target != "_self" || this.urlTree === null) {
                        return true;
                    }
                    const extras = {
                        skipLocationChange: this.skipLocationChange,
                        replaceUrl: this.replaceUrl,
                        state: this.state
                    };
                    this.router.navigateByUrl(this.urlTree, extras);
                    return false;
                }
                updateTargetUrlAndHref() {
                    this.href = this.urlTree !== null ? this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.urlTree)) : null;
                }
                get urlTree() {
                    if (this.commands === null) {
                        return null;
                    }
                    return this.router.createUrlTree(this.commands, {
                        relativeTo: this.relativeTo !== void 0 ? this.relativeTo : this.route,
                        queryParams: this.queryParams,
                        fragment: this.fragment,
                        queryParamsHandling: this.queryParamsHandling,
                        preserveFragment: this.preserveFragment
                    });
                }
            }
            RouterLinkWithHref2.fac = function RouterLinkWithHref_Factory(t) {
                return new (t || RouterLinkWithHref2)(directiveInject(Router), directiveInject(ActivatedRoute), directiveInject(LocationStrategy));
            };
            RouterLinkWithHref2.dir = defineDirective({
                type: RouterLinkWithHref2,
                selectors: [ [ "a", "routerLink", "" ], [ "area", "routerLink", "" ] ],
                hostVars: 2,
                hostBindings: function RouterLinkWithHref_HostBindings(rf, ctx) {
                    if (rf & 1) {
                        listener("click", function RouterLinkWithHref_click_HostBindingHandler($event) {
                            return ctx.onClick($event.button, $event.ctrlKey, $event.shiftKey, $event.altKey, $event.metaKey);
                        });
                    }
                    if (rf & 2) {
                        attribute("target", ctx.target)("href", ctx.href, sanitizeUrl);
                    }
                },
                inputs: {
                    target: "target",
                    queryParams: "queryParams",
                    fragment: "fragment",
                    queryParamsHandling: "queryParamsHandling",
                    state: "state",
                    relativeTo: "relativeTo",
                    preserveFragment: "preserveFragment",
                    skipLocationChange: "skipLocationChange",
                    replaceUrl: "replaceUrl",
                    routerLink: "routerLink"
                },
                standalone: true,
                features: [ NgOnChangesFeature ]
            });
            return RouterLinkWithHref2;
        })();
        (function() {})();
        let RouterLinkActive = (() => {
            class RouterLinkActive2 {
                constructor(router, element, renderer, cdr, link, linkWithHref) {
                    this.router = router;
                    this.element = element;
                    this.renderer = renderer;
                    this.cdr = cdr;
                    this.link = link;
                    this.linkWithHref = linkWithHref;
                    this.classes = [];
                    this.isActive = false;
                    this.routerLinkActiveOptions = {
                        exact: false
                    };
                    this.isActiveChange = new EventEmitter;
                    this.routerEventsSubscription = router.events.subscribe(s => {
                        if (s instanceof NavigationEnd) {
                            this.update();
                        }
                    });
                }
                ngAfterContentInit() {
                    of_of(this.links.changes, this.linksWithHrefs.changes, of_of(null)).pipe(mergeAll()).subscribe(_ => {
                        this.update();
                        this.subscribeToEachLinkOnChanges();
                    });
                }
                subscribeToEachLinkOnChanges() {
                    this.linkInputChangesSubscription?.unsubscribe();
                    const allLinkChanges = [ ...this.links.toArray(), ...this.linksWithHrefs.toArray(), this.link, this.linkWithHref ].filter(link => !!link).map(link => link.onChanges);
                    this.linkInputChangesSubscription = from(allLinkChanges).pipe(mergeAll()).subscribe(link => {
                        if (this.isActive !== this.isLinkActive(this.router)(link)) {
                            this.update();
                        }
                    });
                }
                set routerLinkActive(data) {
                    const classes = Array.isArray(data) ? data : data.split(" ");
                    this.classes = classes.filter(c => !!c);
                }
                ngOnChanges(changes) {
                    this.update();
                }
                ngOnDestroy() {
                    this.routerEventsSubscription.unsubscribe();
                    this.linkInputChangesSubscription?.unsubscribe();
                }
                update() {
                    if (!this.links || !this.linksWithHrefs || !this.router.navigated) {
                        return;
                    }
                    Promise.resolve().then(() => {
                        const hasActiveLinks = this.hasActiveLinks();
                        if (this.isActive !== hasActiveLinks) {
                            this.isActive = hasActiveLinks;
                            this.cdr.markForCheck();
                            this.classes.forEach(c => {
                                if (hasActiveLinks) {
                                    this.renderer.addClass(this.element.nativeElement, c);
                                } else {
                                    this.renderer.removeClass(this.element.nativeElement, c);
                                }
                            });
                            if (hasActiveLinks && this.ariaCurrentWhenActive !== void 0) {
                                this.renderer.setAttribute(this.element.nativeElement, "aria-current", this.ariaCurrentWhenActive.toString());
                            } else {
                                this.renderer.removeAttribute(this.element.nativeElement, "aria-current");
                            }
                            this.isActiveChange.emit(hasActiveLinks);
                        }
                    });
                }
                isLinkActive(router) {
                    const options = isActiveMatchOptions(this.routerLinkActiveOptions) ? this.routerLinkActiveOptions : this.routerLinkActiveOptions.exact || false;
                    return link => link.urlTree ? router.isActive(link.urlTree, options) : false;
                }
                hasActiveLinks() {
                    const isActiveCheckFn = this.isLinkActive(this.router);
                    return this.link && isActiveCheckFn(this.link) || this.linkWithHref && isActiveCheckFn(this.linkWithHref) || this.links.some(isActiveCheckFn) || this.linksWithHrefs.some(isActiveCheckFn);
                }
            }
            RouterLinkActive2.fac = function RouterLinkActive_Factory(t) {
                return new (t || RouterLinkActive2)(directiveInject(Router), directiveInject(core_ElementRef), directiveInject(core_Renderer2), directiveInject(ChangeDetectorRef), directiveInject(RouterLink, 8), directiveInject(RouterLinkWithHref, 8));
            };
            RouterLinkActive2.dir = defineDirective({
                type: RouterLinkActive2,
                selectors: [ [ "", "routerLinkActive", "" ] ],
                contentQueries: function RouterLinkActive_ContentQueries(rf, ctx, dirIndex) {
                    if (rf & 1) {
                        contentQuery(dirIndex, RouterLink, 5);
                        contentQuery(dirIndex, RouterLinkWithHref, 5);
                    }
                    if (rf & 2) {
                        let _t;
                        queryRefresh(_t = loadQuery()) && (ctx.links = _t);
                        queryRefresh(_t = loadQuery()) && (ctx.linksWithHrefs = _t);
                    }
                },
                inputs: {
                    routerLinkActiveOptions: "routerLinkActiveOptions",
                    ariaCurrentWhenActive: "ariaCurrentWhenActive",
                    routerLinkActive: "routerLinkActive"
                },
                outputs: {
                    isActiveChange: "isActiveChange"
                },
                exportAs: [ "routerLinkActive" ],
                standalone: true,
                features: [ NgOnChangesFeature ]
            });
            return RouterLinkActive2;
        })();
        (function() {})();
        function isActiveMatchOptions(options) {
            return !!options.paths;
        }
        class PreloadingStrategy {}
        let PreloadAllModules = null;
        (function() {})();
        let NoPreloading = null;
        (function() {})();
        let RouterPreloader = (() => {
            class RouterPreloader2 {
                constructor(router, compiler, injector, preloadingStrategy, loader) {
                    this.router = router;
                    this.injector = injector;
                    this.preloadingStrategy = preloadingStrategy;
                    this.loader = loader;
                }
                setUpPreloading() {
                    this.subscription = this.router.events.pipe(filter(e => e instanceof NavigationEnd), concatMap(() => this.preload())).subscribe(() => {});
                }
                preload() {
                    return this.processRoutes(this.injector, this.router.config);
                }
                ngOnDestroy() {
                    if (this.subscription) {
                        this.subscription.unsubscribe();
                    }
                }
                processRoutes(injector, routes2) {
                    const res = [];
                    for (const route of routes2) {
                        if (route.providers && !route._injector) {
                            route._injector = createEnvironmentInjector(route.providers, injector, `Route: ${route.path}`);
                        }
                        const injectorForCurrentRoute = route._injector ?? injector;
                        const injectorForChildren = route._loadedInjector ?? injectorForCurrentRoute;
                        if (route.loadChildren && !route._loadedRoutes && route.canLoad === void 0 || route.loadComponent && !route._loadedComponent) {
                            res.push(this.preloadConfig(injectorForCurrentRoute, route));
                        } else if (route.children || route._loadedRoutes) {
                            res.push(this.processRoutes(injectorForChildren, route.children ?? route._loadedRoutes));
                        }
                    }
                    return from(res).pipe(mergeAll());
                }
                preloadConfig(injector, route) {
                    return this.preloadingStrategy.preload(route, () => {
                        let loadedChildren$;
                        if (route.loadChildren && route.canLoad === void 0) {
                            loadedChildren$ = this.loader.loadChildren(injector, route);
                        } else {
                            loadedChildren$ = of_of(null);
                        }
                        const recursiveLoadChildren$ = loadedChildren$.pipe(mergeMap(config2 => {
                            if (config2 === null) {
                                return of_of(void 0);
                            }
                            route._loadedRoutes = config2.routes;
                            route._loadedInjector = config2.injector;
                            return this.processRoutes(config2.injector ?? injector, config2.routes);
                        }));
                        if (route.loadComponent && !route._loadedComponent) {
                            const loadComponent$ = this.loader.loadComponent(route);
                            return from([ recursiveLoadChildren$, loadComponent$ ]).pipe(mergeAll());
                        } else {
                            return recursiveLoadChildren$;
                        }
                    });
                }
            }
            RouterPreloader2.fac = function RouterPreloader_Factory(t) {
                return new (t || RouterPreloader2)(core_inject(Router), core_inject(Compiler), core_inject(EnvironmentInjector), core_inject(PreloadingStrategy), core_inject(RouterConfigLoader));
            };
            RouterPreloader2.prov = defineInjectable({
                token: RouterPreloader2,
                factory: RouterPreloader2.fac,
                providedIn: "root"
            });
            return RouterPreloader2;
        })();
        (function() {})();
        const ROUTER_SCROLLER = new InjectionToken("");
        let RouterScroller = (() => {
            class RouterScroller2 {
                constructor(router, viewportScroller, options = {}) {
                    this.router = router;
                    this.viewportScroller = viewportScroller;
                    this.options = options;
                    this.lastId = 0;
                    this.lastSource = "imperative";
                    this.restoredId = 0;
                    this.store = {};
                    options.scrollPositionRestoration = options.scrollPositionRestoration || "disabled";
                    options.anchorScrolling = options.anchorScrolling || "disabled";
                }
                init() {
                    if (this.options.scrollPositionRestoration !== "disabled") {
                        this.viewportScroller.setHistoryScrollRestoration("manual");
                    }
                    this.routerEventsSubscription = this.createScrollEvents();
                    this.scrollEventsSubscription = this.consumeScrollEvents();
                }
                createScrollEvents() {
                    return this.router.events.subscribe(e => {
                        if (e instanceof NavigationStart) {
                            this.store[this.lastId] = this.viewportScroller.getScrollPosition();
                            this.lastSource = e.navigationTrigger;
                            this.restoredId = e.restoredState ? e.restoredState.navigationId : 0;
                        } else if (e instanceof NavigationEnd) {
                            this.lastId = e.id;
                            this.scheduleScrollEvent(e, this.router.parseUrl(e.urlAfterRedirects).fragment);
                        }
                    });
                }
                consumeScrollEvents() {
                    return this.router.events.subscribe(e => {
                        if (!(e instanceof Scroll)) {
                            return;
                        }
                        if (e.position) {
                            if (this.options.scrollPositionRestoration === "top") {
                                this.viewportScroller.scrollToPosition([ 0, 0 ]);
                            } else if (this.options.scrollPositionRestoration === "enabled") {
                                this.viewportScroller.scrollToPosition(e.position);
                            }
                        } else {
                            if (e.anchor && this.options.anchorScrolling === "enabled") {
                                this.viewportScroller.scrollToAnchor(e.anchor);
                            } else if (this.options.scrollPositionRestoration !== "disabled") {
                                this.viewportScroller.scrollToPosition([ 0, 0 ]);
                            }
                        }
                    });
                }
                scheduleScrollEvent(routerEvent, anchor) {
                    this.router.triggerEvent(new Scroll(routerEvent, this.lastSource === "popstate" ? this.store[this.restoredId] : null, anchor));
                }
                ngOnDestroy() {
                    if (this.routerEventsSubscription) {
                        this.routerEventsSubscription.unsubscribe();
                    }
                    if (this.scrollEventsSubscription) {
                        this.scrollEventsSubscription.unsubscribe();
                    }
                }
            }
            RouterScroller2.fac = function RouterScroller_Factory(t) {
                invalidFactory();
            };
            RouterScroller2.prov = defineInjectable({
                token: RouterScroller2,
                factory: RouterScroller2.fac
            });
            return RouterScroller2;
        })();
        (function() {})();
        const router_NG_DEV_MODE$1 = false;
        function provideRouter(routes2, ...features) {
            return [ provideRoutes(routes2), {
                provide: ActivatedRoute,
                useFactory: rootRoute,
                deps: [ Router ]
            }, {
                provide: APP_BOOTSTRAP_LISTENER,
                multi: true,
                useFactory: getBootstrapListener
            }, features.map(feature => feature.providers) ];
        }
        function rootRoute(router) {
            return router.routerState.root;
        }
        function routerFeature(kind, providers) {
            return {
                kind: kind,
                providers: providers
            };
        }
        function provideRoutes(routes2) {
            return [ {
                provide: ROUTES,
                multi: true,
                useValue: routes2
            } ];
        }
        function withInMemoryScrolling(options = {}) {
            const providers = [ {
                provide: ROUTER_SCROLLER,
                useFactory: () => {
                    const router = inject(Router);
                    const viewportScroller = inject(ViewportScroller);
                    return new RouterScroller(router, viewportScroller, options);
                }
            } ];
            return routerFeature(4, providers);
        }
        function getBootstrapListener() {
            const injector = fesm2020_core_inject(core_Injector);
            return bootstrappedComponentRef => {
                const ref = injector.get(core_ApplicationRef);
                if (bootstrappedComponentRef !== ref.components[0]) {
                    return;
                }
                const router = injector.get(Router);
                const bootstrapDone = injector.get(BOOTSTRAP_DONE);
                if (injector.get(INITIAL_NAVIGATION) === 1) {
                    router.initialNavigation();
                }
                injector.get(ROUTER_PRELOADER, null, InjectFlags.Optional)?.setUpPreloading();
                injector.get(ROUTER_SCROLLER, null, InjectFlags.Optional)?.init();
                router.resetRootComponentType(ref.componentTypes[0]);
                if (!bootstrapDone.closed) {
                    bootstrapDone.next();
                    bootstrapDone.unsubscribe();
                }
            };
        }
        const BOOTSTRAP_DONE = new InjectionToken(router_NG_DEV_MODE$1 ? "bootstrap done indicator" : "", {
            factory: () => new Subject
        });
        const INITIAL_NAVIGATION = new InjectionToken(router_NG_DEV_MODE$1 ? "initial navigation" : "", {
            providedIn: "root",
            factory: () => 1
        });
        function withEnabledBlockingInitialNavigation() {
            const providers = [ {
                provide: INITIAL_NAVIGATION,
                useValue: 0
            }, {
                provide: APP_INITIALIZER,
                multi: true,
                deps: [ core_Injector ],
                useFactory: injector => {
                    const locationInitialized = injector.get(LOCATION_INITIALIZED, Promise.resolve());
                    let initNavigation = false;
                    function afterNextNavigation(action) {
                        const router = injector.get(Router);
                        router.events.pipe(filter(e => e instanceof NavigationEnd || e instanceof NavigationCancel || e instanceof NavigationError), map(e => {
                            if (e instanceof NavigationEnd) {
                                return true;
                            }
                            const redirecting = e instanceof NavigationCancel ? e.code === 0 || e.code === 1 : false;
                            return redirecting ? null : false;
                        }), filter(result => result !== null), take(1)).subscribe(() => {
                            action();
                        });
                    }
                    return () => locationInitialized.then(() => new Promise(resolve => {
                        const router = injector.get(Router);
                        const bootstrapDone = injector.get(BOOTSTRAP_DONE);
                        afterNextNavigation(() => {
                            resolve(true);
                            initNavigation = true;
                        });
                        router.afterPreactivation = () => {
                            resolve(true);
                            if (!initNavigation) {
                                return bootstrapDone.closed ? of_of(void 0) : bootstrapDone;
                            } else {
                                return of_of(void 0);
                            }
                        };
                        router.initialNavigation();
                    }));
                }
            } ];
            return routerFeature(2, providers);
        }
        function withDisabledInitialNavigation() {
            const providers = [ {
                provide: APP_INITIALIZER,
                multi: true,
                useFactory: () => {
                    const router = fesm2020_core_inject(Router);
                    return () => {
                        router.setUpLocationChangeListener();
                    };
                }
            }, {
                provide: INITIAL_NAVIGATION,
                useValue: 2
            } ];
            return routerFeature(3, providers);
        }
        function withDebugTracing() {
            let providers = [];
            if (router_NG_DEV_MODE$1) {
                providers = [ {
                    provide: ENVIRONMENT_INITIALIZER,
                    multi: true,
                    useFactory: () => {
                        const router = fesm2020_core_inject(Router);
                        return () => router.events.subscribe(e => {
                            console.group?.(`Router Event: ${e.constructor.name}`);
                            console.log(stringifyEvent(e));
                            console.log(e);
                            console.groupEnd?.();
                        });
                    }
                } ];
            } else {
                providers = [];
            }
            return routerFeature(1, providers);
        }
        const ROUTER_PRELOADER = new InjectionToken(router_NG_DEV_MODE$1 ? "router preloader" : "");
        function withPreloading(preloadingStrategy) {
            const providers = [ {
                provide: ROUTER_PRELOADER,
                useExisting: RouterPreloader
            }, {
                provide: PreloadingStrategy,
                useExisting: preloadingStrategy
            } ];
            return routerFeature(0, providers);
        }
        function withRouterConfig(options) {
            const providers = [ {
                provide: ROUTER_CONFIGURATION,
                useValue: options
            } ];
            return routerFeature(5, providers);
        }
        const router_NG_DEV_MODE = false;
        const ROUTER_DIRECTIVES = [ RouterOutlet, RouterLink, RouterLinkWithHref, RouterLinkActive, EmptyOutletComponent ];
        const ROUTER_FORROOT_GUARD = new InjectionToken(router_NG_DEV_MODE ? "router duplicate forRoot guard" : "ROUTER_FORROOT_GUARD");
        const ROUTER_PROVIDERS = [ Location, {
            provide: UrlSerializer,
            useClass: DefaultUrlSerializer
        }, {
            provide: Router,
            useFactory: setupRouter
        }, ChildrenOutletContexts, {
            provide: ActivatedRoute,
            useFactory: rootRoute,
            deps: [ Router ]
        }, RouterConfigLoader ];
        function routerNgProbeToken() {
            return new NgProbeToken("Router", Router);
        }
        let RouterModule = (() => {
            class RouterModule2 {
                constructor(guard) {}
                static forRoot(routes2, config2) {
                    return {
                        ngModule: RouterModule2,
                        providers: [ ROUTER_PROVIDERS, router_NG_DEV_MODE ? config2?.enableTracing ? withDebugTracing().providers : [] : [], provideRoutes(routes2), {
                            provide: ROUTER_FORROOT_GUARD,
                            useFactory: provideForRootGuard,
                            deps: [ [ Router, new core_Optional, new SkipSelf ] ]
                        }, {
                            provide: ROUTER_CONFIGURATION,
                            useValue: config2 ? config2 : {}
                        }, config2?.useHash ? provideHashLocationStrategy() : providePathLocationStrategy(), provideRouterScroller(), config2?.preloadingStrategy ? withPreloading(config2.preloadingStrategy).providers : [], {
                            provide: NgProbeToken,
                            multi: true,
                            useFactory: routerNgProbeToken
                        }, config2?.initialNavigation ? provideInitialNavigation(config2) : [], provideRouterInitializer() ]
                    };
                }
                static forChild(routes2) {
                    return {
                        ngModule: RouterModule2,
                        providers: [ provideRoutes(routes2) ]
                    };
                }
            }
            RouterModule2.fac = function RouterModule_Factory(t) {
                return new (t || RouterModule2)(core_inject(ROUTER_FORROOT_GUARD, 8));
            };
            RouterModule2.mod = defineNgModule({
                type: RouterModule2
            });
            RouterModule2.inj = defineInjector({
                imports: [ EmptyOutletComponent ]
            });
            return RouterModule2;
        })();
        (function() {})();
        function provideRouterScroller() {
            return {
                provide: ROUTER_SCROLLER,
                useFactory: () => {
                    const router = fesm2020_core_inject(Router);
                    const viewportScroller = fesm2020_core_inject(common_ViewportScroller);
                    const config2 = fesm2020_core_inject(ROUTER_CONFIGURATION);
                    if (config2.scrollOffset) {
                        viewportScroller.setOffset(config2.scrollOffset);
                    }
                    return new RouterScroller(router, viewportScroller, config2);
                }
            };
        }
        function provideHashLocationStrategy() {
            return {
                provide: LocationStrategy,
                useClass: HashLocationStrategy
            };
        }
        function providePathLocationStrategy() {
            return {
                provide: LocationStrategy,
                useClass: PathLocationStrategy
            };
        }
        function provideForRootGuard(router) {
            if (router_NG_DEV_MODE && router) {
                throw new RuntimeError(4007, `The Router was provided more than once. This can happen if 'forRoot' is used outside of the root injector. Lazy loaded modules should use RouterModule.forChild() instead.`);
            }
            return "guarded";
        }
        function provideInitialNavigation(config2) {
            return [ config2.initialNavigation === "disabled" ? withDisabledInitialNavigation().providers : [], config2.initialNavigation === "enabledBlocking" ? withEnabledBlockingInitialNavigation().providers : [] ];
        }
        const ROUTER_INITIALIZER = new InjectionToken(router_NG_DEV_MODE ? "Router Initializer" : "");
        function provideRouterInitializer() {
            return [ {
                provide: ROUTER_INITIALIZER,
                useFactory: getBootstrapListener
            }, {
                provide: core_APP_BOOTSTRAP_LISTENER,
                multi: true,
                useExisting: ROUTER_INITIALIZER
            } ];
        }
        const router_VERSION = new Version("14.3.0");
        function uuid() {
            let uuid2 = "";
            for (let i = 0; i < 32; i++) {
                const random = Math.random() * 16 | 0;
                if (i === 8 || i === 12 || i === 16 || i === 20) {
                    uuid2 += "-";
                }
                uuid2 += (i === 12 ? 4 : i === 16 ? random & 3 | 8 : random).toString(16);
            }
            return uuid2;
        }
        let TodosService = (() => {
            class TodosService2 {
                constructor() {
                    this.todos = [];
                }
                addItem(title) {
                    const todo = {
                        id: uuid(),
                        title,
                        completed: false
                    };
                    this.todos.push(todo);
                }
                removeItem(todo) {
                    const index = this.todos.indexOf(todo);
                    this.todos.splice(index, 1);
                }
                clearCompleted() {
                    this.todos = this.todos.filter(todo => !todo.completed);
                }
                toggleAll(completed) {
                    this.todos = this.todos.map(todo => ({
                        ...todo,
                        completed
                    }));
                }
                getItems(type = "all") {
                    switch (type) {
                      case "active":
                        return this.todos.filter(todo => !todo.completed);

                      case "completed":
                        return this.todos.filter(todo => todo.completed);
                    }
                    return this.todos;
                }
            }
            TodosService2.fac = function TodosService_Factory(t) {
                return new (t || TodosService2);
            };
            TodosService2.prov = defineInjectable({
                token: TodosService2,
                factory: TodosService2.fac,
                providedIn: "root"
            });
            return TodosService2;
        })();
        let TodoHeaderComponent = (() => {
            class TodoHeaderComponent2 {
                constructor(todosService) {
                    this.todosService = todosService;
                    this.titleFormControl = new FormControl("");
                }
                addTodo() {
                    const title = this.titleFormControl.getRawValue()?.trim();
                    if (!title) {
                        return;
                    }
                    this.todosService.addItem(title);
                    this.titleFormControl.setValue("");
                }
            }
            TodoHeaderComponent2.fac = function TodoHeaderComponent_Factory(t) {
                return new (t || TodoHeaderComponent2)(directiveInject(TodosService));
            };
            TodoHeaderComponent2.cmp = defineComponent({
                type: TodoHeaderComponent2,
                selectors: [ [ "app-todo-header" ] ],
                decls: 4,
                vars: 1,
                consts: [ [ 1, "header" ], [ "placeholder", "What needs to be done?", "autofocus", "", 1, "new-todo", 3, "formControl", "keyup.enter" ] ],
                template: function TodoHeaderComponent_Template(rf, ctx) {
                    if (rf & 1) {
                        elementStart(0, "header", 0)(1, "h1");
                        text(2, "todos");
                        elementEnd();
                        elementStart(3, "input", 1);
                        listener("keyup.enter", function TodoHeaderComponent_Template_input_keyup_enter_3_listener() {
                            return ctx.addTodo();
                        });
                        elementEnd()();
                    }
                    if (rf & 2) {
                        advance(3);
                        property("formControl", ctx.titleFormControl);
                    }
                },
                dependencies: [ DefaultValueAccessor, NgControlStatus, FormControlDirective ],
                encapsulation: 2
            });
            return TodoHeaderComponent2;
        })();
        const _c0 = [ "todoInputRef" ];
        function TodoItemComponent_div_6_Template(rf, ctx) {
            if (rf & 1) {
                const _r3 = getCurrentView();
                elementStart(0, "div", 5)(1, "input", 6, 7);
                listener("focus", function TodoItemComponent_div_6_Template_input_focus_1_listener($event) {
                    restoreView(_r3);
                    const ctx_r2 = nextContext();
                    return resetView(ctx_r2.handleFocus($event));
                })("blur", function TodoItemComponent_div_6_Template_input_blur_1_listener($event) {
                    restoreView(_r3);
                    const ctx_r4 = nextContext();
                    return resetView(ctx_r4.handleBlur($event));
                })("keyup.enter", function TodoItemComponent_div_6_Template_input_keyup_enter_1_listener() {
                    restoreView(_r3);
                    const ctx_r5 = nextContext();
                    return resetView(ctx_r5.updateTodo());
                });
                elementEnd();
                elementStart(3, "label", 8);
                text(4, " Edit Todo Input ");
                elementEnd()();
            }
            if (rf & 2) {
                const ctx_r0 = nextContext();
                advance(1);
                property("formControl", ctx_r0.titleFormControl);
            }
        }
        let TodoItemComponent = (() => {
            class TodoItemComponent2 {
                constructor() {
                    this.todo = {
                        id: "",
                        title: "",
                        completed: false
                    };
                    this.index = 0;
                    this.deleteEvent = new EventEmitter;
                    this.titleFormControl = new FormControl("");
                    this.isEditing = false;
                }
                toggleTodo() {
                    this.todo.completed = !this.todo.completed;
                }
                removeTodo() {
                    this.deleteEvent.emit(this.todo);
                }
                startEdit() {
                    this.isEditing = true;
                }
                handleBlur(e) {
                    this.isEditing = false;
                }
                handleFocus(e) {
                    this.titleFormControl.setValue(this.todo.title);
                }
                updateTodo() {
                    const title = this.titleFormControl.getRawValue()?.trimEnd();
                    if (!title) {
                        this.deleteEvent.emit(this.todo);
                    } else {
                        this.todo.title = title;
                    }
                    this.isEditing = false;
                }
                ngAfterViewChecked() {
                    if (this.isEditing) {
                        this.inputRef?.nativeElement.focus();
                    }
                }
            }
            TodoItemComponent2.fac = function TodoItemComponent_Factory(t) {
                return new (t || TodoItemComponent2);
            };
            TodoItemComponent2.cmp = defineComponent({
                type: TodoItemComponent2,
                selectors: [ [ "app-todo-item" ] ],
                viewQuery: function TodoItemComponent_Query(rf, ctx) {
                    if (rf & 1) {
                        viewQuery(_c0, 5);
                    }
                    if (rf & 2) {
                        let _t;
                        queryRefresh(_t = loadQuery()) && (ctx.inputRef = _t.first);
                    }
                },
                inputs: {
                    todo: "todo",
                    index: "index"
                },
                outputs: {
                    deleteEvent: "deleteEvent"
                },
                decls: 7,
                vars: 5,
                consts: [ [ 3, "ngClass" ], [ "type", "checkbox", 1, "toggle", 3, "checked", "click" ], [ 3, "dblclick" ], [ 1, "destroy", 3, "click" ], [ "class", "input-container", 4, "ngIf" ], [ 1, "input-container" ], [ "id", "edit-todo-input", 1, "edit", 3, "formControl", "focus", "blur", "keyup.enter" ], [ "todoInputRef", "" ], [ "htmlFor", "edit-todo-input", 1, "visually-hidden" ] ],
                template: function TodoItemComponent_Template(rf, ctx) {
                    if (rf & 1) {
                        elementStart(0, "li", 0)(1, "div", 0)(2, "input", 1);
                        listener("click", function TodoItemComponent_Template_input_click_2_listener() {
                            return ctx.toggleTodo();
                        });
                        elementEnd();
                        elementStart(3, "label", 2);
                        listener("dblclick", function TodoItemComponent_Template_label_dblclick_3_listener() {
                            return ctx.startEdit();
                        });
                        text(4);
                        elementEnd();
                        elementStart(5, "button", 3);
                        listener("click", function TodoItemComponent_Template_button_click_5_listener() {
                            return ctx.removeTodo();
                        });
                        elementEnd()();
                        template(6, TodoItemComponent_div_6_Template, 5, 1, "div", 4);
                        elementEnd();
                    }
                    if (rf & 2) {
                        property("ngClass", "targeted li-" + ctx.index + (ctx.todo.completed ? " completed" : "") + (ctx.isEditing ? " editing" : ""));
                        advance(1);
                        property("ngClass", "targeted view-" + ctx.index);
                        advance(1);
                        property("checked", ctx.todo.completed);
                        advance(2);
                        textInterpolate(ctx.todo.title);
                        advance(2);
                        property("ngIf", ctx.isEditing);
                    }
                },
                dependencies: [ NgClass, NgIf, DefaultValueAccessor, NgControlStatus, FormControlDirective ],
                encapsulation: 2,
                changeDetection: 0
            });
            return TodoItemComponent2;
        })();
        function TodoListComponent_main_0_app_todo_item_6_Template(rf, ctx) {
            if (rf & 1) {
                const _r5 = getCurrentView();
                elementStart(0, "app-todo-item", 7);
                listener("deleteEvent", function TodoListComponent_main_0_app_todo_item_6_Template_app_todo_item_deleteEvent_0_listener($event) {
                    restoreView(_r5);
                    const ctx_r4 = nextContext(2);
                    return resetView(ctx_r4.removeTodo($event));
                });
                elementEnd();
            }
            if (rf & 2) {
                const todo_r2 = ctx.$implicit;
                const i_r3 = ctx.index;
                property("todo", todo_r2)("index", i_r3);
            }
        }
        function TodoListComponent_main_0_Template(rf, ctx) {
            if (rf & 1) {
                const _r7 = getCurrentView();
                elementStart(0, "main", 1)(1, "div", 2)(2, "input", 3);
                listener("change", function TodoListComponent_main_0_Template_input_change_2_listener($event) {
                    restoreView(_r7);
                    const ctx_r6 = nextContext();
                    return resetView(ctx_r6.toggleAll($event));
                });
                elementEnd();
                elementStart(3, "label", 4);
                text(4, " Toggle All Input ");
                elementEnd()();
                elementStart(5, "ul", 5);
                template(6, TodoListComponent_main_0_app_todo_item_6_Template, 1, 2, "app-todo-item", 6);
                elementEnd()();
            }
            if (rf & 2) {
                const ctx_r0 = nextContext();
                advance(2);
                property("checked", !ctx_r0.activeTodos.length);
                advance(4);
                property("ngForOf", ctx_r0.todos)("ngForTrackBy", ctx_r0.trackByItem);
            }
        }
        let TodoListComponent = (() => {
            class TodoListComponent2 {
                constructor(todosService, location2) {
                    this.todosService = todosService;
                    this.location = location2;
                }
                get todos() {
                    const filter2 = this.location.path().split("/")[1] || "all";
                    return this.todosService.getItems(filter2);
                }
                get activeTodos() {
                    return this.todosService.getItems("active");
                }
                removeTodo(todo) {
                    this.todosService.removeItem(todo);
                }
                toggleAll(e) {
                    const input = e.target;
                    this.todosService.toggleAll(input.checked);
                }
                trackByItem(index, todo) {
                    return todo.id;
                }
            }
            TodoListComponent2.fac = function TodoListComponent_Factory(t) {
                return new (t || TodoListComponent2)(directiveInject(TodosService), directiveInject(Location));
            };
            TodoListComponent2.cmp = defineComponent({
                type: TodoListComponent2,
                selectors: [ [ "app-todo-list" ] ],
                decls: 1,
                vars: 1,
                consts: [ [ "class", "main", 4, "ngIf" ], [ 1, "main" ], [ 1, "toggle-all-container" ], [ "type", "checkbox", 1, "toggle-all", 3, "checked", "change" ], [ "htmlFor", "toggle-all", 1, "toggle-all-label" ], [ 1, "todo-list" ], [ 3, "todo", "index", "deleteEvent", 4, "ngFor", "ngForOf", "ngForTrackBy" ], [ 3, "todo", "index", "deleteEvent" ] ],
                template: function TodoListComponent_Template(rf, ctx) {
                    if (rf & 1) {
                        template(0, TodoListComponent_main_0_Template, 7, 3, "main", 0);
                    }
                    if (rf & 2) {
                        property("ngIf", ctx.todos.length > 0);
                    }
                },
                dependencies: [ NgForOf, NgIf, TodoItemComponent ],
                encapsulation: 2
            });
            return TodoListComponent2;
        })();
        function TodoFooterComponent_footer_0_button_15_Template(rf, ctx) {
            if (rf & 1) {
                const _r3 = getCurrentView();
                elementStart(0, "button", 8);
                listener("click", function TodoFooterComponent_footer_0_button_15_Template_button_click_0_listener() {
                    restoreView(_r3);
                    const ctx_r2 = nextContext(2);
                    return resetView(ctx_r2.clearCompleted());
                });
                text(1, "Clear Completed");
                elementEnd();
            }
        }
        function TodoFooterComponent_footer_0_Template(rf, ctx) {
            if (rf & 1) {
                elementStart(0, "footer", 1)(1, "span", 2)(2, "strong");
                text(3);
                elementEnd();
                text(4);
                elementEnd();
                elementStart(5, "ul", 3)(6, "li")(7, "a", 4);
                text(8, " All ");
                elementEnd()();
                elementStart(9, "li")(10, "a", 5);
                text(11, " Active ");
                elementEnd()();
                elementStart(12, "li")(13, "a", 6);
                text(14, " Completed ");
                elementEnd()()();
                template(15, TodoFooterComponent_footer_0_button_15_Template, 2, 0, "button", 7);
                elementEnd();
            }
            if (rf & 2) {
                const ctx_r0 = nextContext();
                advance(3);
                textInterpolate(ctx_r0.activeTodos.length);
                advance(1);
                textInterpolate1(" ", ctx_r0.activeTodos.length == 1 ? "item" : "items", " left");
                advance(3);
                classProp("selected", ctx_r0.filter === "all");
                advance(3);
                classProp("selected", ctx_r0.filter === "active");
                advance(3);
                classProp("selected", ctx_r0.filter === "completed");
                advance(2);
                property("ngIf", ctx_r0.completedTodos.length);
            }
        }
        let TodoFooterComponent = (() => {
            class TodoFooterComponent2 {
                constructor(todosService, location2) {
                    this.todosService = todosService;
                    this.location = location2;
                }
                get todos() {
                    return this.todosService.getItems();
                }
                get activeTodos() {
                    return this.todosService.getItems("active");
                }
                get completedTodos() {
                    return this.todosService.getItems("completed");
                }
                get filter() {
                    return this.location.path().split("/")[1] || "all";
                }
                clearCompleted() {
                    this.todosService.clearCompleted();
                }
            }
            TodoFooterComponent2.fac = function TodoFooterComponent_Factory(t) {
                return new (t || TodoFooterComponent2)(directiveInject(TodosService), directiveInject(Location));
            };
            TodoFooterComponent2.cmp = defineComponent({
                type: TodoFooterComponent2,
                selectors: [ [ "app-todo-footer" ] ],
                decls: 1,
                vars: 1,
                consts: [ [ "class", "footer", 4, "ngIf" ], [ 1, "footer" ], [ 1, "todo-count" ], [ 1, "filters" ], [ "routerLink", "/" ], [ "routerLink", "/active" ], [ "routerLink", "/completed" ], [ "type", "button", "class", "clear-completed", 3, "click", 4, "ngIf" ], [ "type", "button", 1, "clear-completed", 3, "click" ] ],
                template: function TodoFooterComponent_Template(rf, ctx) {
                    if (rf & 1) {
                        template(0, TodoFooterComponent_footer_0_Template, 16, 9, "footer", 0);
                    }
                    if (rf & 2) {
                        property("ngIf", ctx.todos.length > 0);
                    }
                },
                dependencies: [ NgIf, RouterLinkWithHref ],
                encapsulation: 2
            });
            return TodoFooterComponent2;
        })();
        let AppComponent = (() => {
            class AppComponent2 {
                constructor() {
                    this.title = "angular";
                }
            }
            AppComponent2.fac = function AppComponent_Factory(t) {
                return new (t || AppComponent2);
            };
            AppComponent2.cmp = defineComponent({
                type: AppComponent2,
                selectors: [ [ "app-root" ] ],
                decls: 4,
                vars: 0,
                consts: [ [ 1, "todoapp" ] ],
                template: function AppComponent_Template(rf, ctx) {
                    if (rf & 1) {
                        elementStart(0, "section", 0);
                        element(1, "app-todo-header")(2, "app-todo-list")(3, "app-todo-footer");
                        elementEnd();
                    }
                },
                dependencies: [ TodoHeaderComponent, TodoListComponent, TodoFooterComponent ],
                encapsulation: 2
            });
            return AppComponent2;
        })();
        const routes = [ {
            path: "all",
            component: AppComponent
        }, {
            path: "active",
            component: AppComponent
        }, {
            path: "completed",
            component: AppComponent
        }, {
            path: "",
            redirectTo: "/all",
            pathMatch: "full"
        } ];
        let AppRoutingModule = (() => {
            class AppRoutingModule2 {}
            AppRoutingModule2.fac = function AppRoutingModule_Factory(t) {
                return new (t || AppRoutingModule2);
            };
            AppRoutingModule2.mod = defineNgModule({
                type: AppRoutingModule2
            });
            AppRoutingModule2.inj = defineInjector({
                imports: [ RouterModule.forRoot(routes, {
                    useHash: true
                }), RouterModule ]
            });
            return AppRoutingModule2;
        })();
        let AppModule = (() => {
            class AppModule2 {}
            AppModule2.fac = function AppModule_Factory(t) {
                return new (t || AppModule2);
            };
            AppModule2.mod = defineNgModule({
                type: AppModule2,
                bootstrap: [ AppComponent ]
            });
            AppModule2.inj = defineInjector({
                imports: [ BrowserModule, AppRoutingModule, ReactiveFormsModule ]
            });
            return AppModule2;
        })();
        platformBrowser().bootstrapModule(AppModule).catch(err => console.error(err));
    }
}, __webpack_require__ => {
    var __webpack_exec__ = moduleId => __webpack_require__(__webpack_require__.s = moduleId);
    var __webpack_exports__ = __webpack_exec__(677);
} ]);